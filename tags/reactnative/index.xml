<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reactnative on Hujiawei Bujidao</title>
    <link>http://javayhu.me/tags/reactnative/index.xml</link>
    <description>Recent content in Reactnative on Hujiawei Bujidao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved &amp;copy; 2013 - 2017</copyright>
    <atom:link href="http://javayhu.me/tags/reactnative/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>React Native Upgrade</title>
      <link>http://javayhu.me/blog/2017/07/28/react-native-upgrade/</link>
      <pubDate>Fri, 28 Jul 2017 10:46:33 +0800</pubDate>
      
      <guid>http://javayhu.me/blog/2017/07/28/react-native-upgrade/</guid>
      <description>&lt;p&gt;本文主要分享Android和iOS端升级RN到0.44.0版本的经验。&lt;/p&gt;

&lt;p&gt;今天收到一封不知来自哪个国家的友人的感谢邮件，说是我之前的一篇文章帮助到了他，这才看了看自己的博客，发现我真的有很久没分享东西了。毕业一年有余，换了一次工作，一直忙忙碌碌，日子很充实，收获很多，其实真的很想都分享出来，但是周末却总是变得懒散不想动，慢慢地就积压了很多想分享的内容。这次终于战胜自己，重新开始分享，希望能够坚持下去。&lt;/p&gt;

&lt;p&gt;首先，我要告诉大家一件事情，我正式开始做iOS啦，撒花~ 现在产品迭代中交给我的需求如果工作量不是很大的话，那么Android和iOS端就都交给我一个人搞啦，真好。&lt;/p&gt;

&lt;p&gt;其次，我开始正式接触React Native啦，撒花again~ RN在我们的产品中也是比较重要的模块，首页以及多个二级界面都是RN完成的，体验还好，但是带来的crash也不少！&lt;/p&gt;

&lt;p&gt;考虑到我们的RN版本有点老，问题较多，所以最近对RN进行一次升级，升级到0.44.0版本，并对Android和iOS的RN模块进行代码改造。期间我主要是完成Android和iOS端RN模块代码的改造工作，另一位前端同学配合一起解决升级过程出现的问题。&lt;/p&gt;

&lt;p&gt;作为一个接到RN升级任务的RN小白，下面我就大致介绍下自己完成这个任务时遇到的坑，希望能有所帮助。&lt;br /&gt;
&lt;strong&gt;文中的代码和图片我都反复检查过了，基本上没有泄露公司的重要信息的数据，如若发现有泄露的话请立即告知我 ;-)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-替换rn新版本的依赖库-同时更新相关配置&#34;&gt;&lt;strong&gt;1.替换RN新版本的依赖库，同时更新相关配置&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;我们的项目不是直接基于RN开始的，而是已有的项目集成RN。此外，RN集成的方式也不是源码集成，而是使用RN源码编译生成的静态库。&lt;/p&gt;

&lt;p&gt;(1)对于Android来说，项目中依赖的是RN源码下ReactAndroid项目构建得到的aar文件(你还可以继续精简成一个jar文件)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何生成这个aar文件呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按照&lt;a href=&#34;http://facebook.github.io/react-native/docs/tutorial.html&#34;&gt;官网教程&lt;/a&gt;下载RN源码并配置好RN环境之后，在源码根目录下新建&lt;code&gt;gradle.properties&lt;/code&gt;文件(用来配置gradle的代理)和&lt;code&gt;local.properties&lt;/code&gt;文件(用来指定&lt;code&gt;sdk.dir&lt;/code&gt;和&lt;code&gt;ndk.dir&lt;/code&gt;)，执行&lt;code&gt;./gradlew :ReactAndroid:installArchives&lt;/code&gt;即可看到源码下多了一个android目录，其中就放着我们需要的aar文件。默认的名称是&lt;code&gt;1000.0.0-master&lt;/code&gt;，如果你想修改生成的aar的名称，可以通过修改&lt;code&gt;ReactAndroid/gradle.properties&lt;/code&gt;文件中的&lt;code&gt;VERSION_NAME&lt;/code&gt;来实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;：&lt;br /&gt;
1.编译RN源码的时候需要配置NDK，版本必须是&lt;code&gt;r10e&lt;/code&gt;，不能是更高版本，&lt;a href=&#34;https://developer.android.google.cn/ndk/downloads/older_releases.html&#34;&gt;点击进入下载地址&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2.更新RN的aar文件之后，除了需要修改部分API的调用方式之外，还要修改gradle脚本中依赖库的版本号以及混淆规则！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//libraries for RN 0.44.0
compile &#39;javax.inject:javax.inject:1&#39;
compile &#39;com.facebook.fbui.textlayoutbuilder:textlayoutbuilder:1.0.0&#39;
compile &#39;com.facebook.fresco:fresco:1.0.1&#39;
compile &#39;com.facebook.fresco:imagepipeline-okhttp3:1.0.1&#39;
compile &#39;com.facebook.soloader:soloader:0.1.0&#39;
compile &#39;com.google.code.findbugs:jsr305:3.0.0&#39;
compile &#39;com.squareup.okhttp3:okhttp:3.4.1&#39;
compile &#39;com.squareup.okhttp3:okhttp-urlconnection:3.4.1&#39;
compile &#39;com.squareup.okhttp3:okhttp-ws:3.4.1&#39;
compile &#39;com.squareup.okio:okio:1.9.0&#39;
compile &#39;org.webkit:android-jsc:r174650&#39;

//import RN aar
compile(name: &#39;react-native-0.44.0&#39;, ext: &#39;aar&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;混淆规则 (注意最后一句，不加会产生问题，不过我觉得这可能不是解决问题最好的方式)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;#============================= React Native start =============================#
# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Disabling obfuscation is useful if you collect stack traces from production crashes
# (unless you are using a system that supports de-obfuscate the stack traces).
#-dontobfuscate

# React Native

# Keep our interfaces so they can be used by other ProGuard rules.
# See http://sourceforge.net/p/proguard/bugs/466/
-keep,allowobfuscation @interface com.facebook.proguard.annotations.DoNotStrip
-keep,allowobfuscation @interface com.facebook.proguard.annotations.KeepGettersAndSetters
-keep,allowobfuscation @interface com.facebook.common.internal.DoNotStrip

# Do not strip any method/class that is annotated with @DoNotStrip
-keep @com.facebook.proguard.annotations.DoNotStrip class *
-keep @com.facebook.common.internal.DoNotStrip class *
-keepclassmembers class * {
    @com.facebook.proguard.annotations.DoNotStrip *;
    @com.facebook.common.internal.DoNotStrip *;
}

-keepclassmembers @com.facebook.proguard.annotations.KeepGettersAndSetters class * {
  void set*(***);
  *** get*();
}

-keep class * extends com.facebook.react.bridge.JavaScriptModule { *; }
-keep class * extends com.facebook.react.bridge.NativeModule { *; }
-keepclassmembers,includedescriptorclasses class * { native &amp;lt;methods&amp;gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.UIProp &amp;lt;fields&amp;gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactProp &amp;lt;methods&amp;gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactPropGroup &amp;lt;methods&amp;gt;; }

-dontwarn com.facebook.react.**

# TextLayoutBuilder uses a non-public Android constructor within StaticLayout.
# See libs/proxy/src/main/java/com/facebook/fbui/textlayoutbuilder/proxy for details.
-dontwarn android.text.StaticLayout

# okhttp
-keepattributes Signature
-keepattributes *Annotation*
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }
-dontwarn okhttp3.**

# okio
-keep class sun.misc.Unsafe { *; }
-dontwarn java.nio.file.*
-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-dontwarn okio.**

# Caused by: java.lang.NoSuchFieldError: no field with name=&#39;mHybridData&#39;
# ref: http://blog.csdn.net/it_talk/article/details/52789251
-keep class com.facebook.** { *; }
#============================= React Native end =============================#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.默认情况下，以上编译操作生成的aar文件中只包含&lt;code&gt;armeabi-v7a&lt;/code&gt;和&lt;code&gt;x86&lt;/code&gt;两种ABI下的so文件，如果运行时提示找不到so文件，那么可能就是你的&lt;code&gt;abiFilter&lt;/code&gt;配置错了。但是如果你的应用的&lt;code&gt;abiFilter&lt;/code&gt;只能配置为&lt;code&gt;armeabi&lt;/code&gt;的话，可以考虑下面的做法：先解压aar文件，在jni目录下新建&lt;code&gt;armeabi&lt;/code&gt;文件 夹，并将&lt;code&gt;armeabi-v7a&lt;/code&gt;下面的so复制到&lt;code&gt;armeabi&lt;/code&gt;中，然后删除&lt;code&gt;x86&lt;/code&gt;和&lt;code&gt;armeabi-v7a&lt;/code&gt;目录，最后重新压缩生成aar文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_android_aar.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2)对于iOS来说，项目中依赖的是11个RN Xcode子项目生成的静态库(.a)文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何生成RN静态库呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里可以通过&lt;code&gt;react-native init&lt;/code&gt;命令创建一个新的RN demo项目，然后修改&lt;code&gt;package.json&lt;/code&gt;文件，将RN版本调整为&lt;code&gt;0.44.0&lt;/code&gt;版本，然后执行&lt;code&gt;npm install&lt;/code&gt;，最后打开ios目录下的Xcode项目即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;：&lt;br /&gt;
1.RN升级到0.44.0版本之后，Deployment Target要设置为&lt;code&gt;8.0&lt;/code&gt;以上 (实际上从0.36版本的RN就需要做这个配置了)。&lt;/p&gt;

&lt;p&gt;2.项目中除了要引入11个静态库文件，还需要引入RN相关的头文件，这些头文件可以在上面的demo项目的构建结果中找到，一般路径为&lt;code&gt;/Users/[user]/Library/Developer/Xcode/DerivedData/[demo-project]/Build/Products/[Release-xxx]/include&lt;/code&gt;，引入之后别忘了添加到&lt;code&gt;Header Search Path&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;3.一定要以&lt;code&gt;release&lt;/code&gt;模式构建demo应用，否则生成静态库中RN环境实际上是dev环境，在手机摇晃的情况下会弹出RN的调试菜单！出现异常的还会显示RN的红屏界面！&lt;/p&gt;

&lt;p&gt;4.生成静态库的时候要根据项目的配置来确定支持的平台，例如有可能项目需要的是同时支持armv7, arm64, i386, x86_64平台的静态库，那么这个时候就需要使用&lt;code&gt;lipo&lt;/code&gt;命令，其中&lt;code&gt;lipo -info&lt;/code&gt;命令可以查看一个静态库支持的平台，&lt;code&gt;lipo -create&lt;/code&gt;命令可以将支持不同平台的静态库合并。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_staticlibs.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;5.如果项目依赖高版本的RN静态库，可以正常加载低版本的RN打出来的bundle文件；反之，如果项目依赖的是低版本的RN静态库，那么加载高版本的RN打出来的bundle文件的时候会报错&lt;code&gt;DeviceInfo native module is not installed correctly&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;6.iOS端RN升级之后出现过cookie失效的问题，这个问题修改下JS端的代码，在请求的时候添加&lt;code&gt;credentials&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;2-关键路径日志补全-将rn源码内部重要日志定向到应用日志中&#34;&gt;&lt;strong&gt;2.关键路径日志补全，将RN源码内部重要日志定向到应用日志中&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在应用输出的日志中补全关键路径的信息，例如bundle加载时使用的bundle文件位置、版本，bundle更新重载时使用的bundle文件位置、版本等。这里还做了个功能是将RN源码内部的重要日志定向到应用日志中，这样的话可以丰富应用日志的内容，方便在遇到问题的时候定位问题。&lt;/p&gt;

&lt;p&gt;(1)对于Android来说，日志重定向功能是依靠&lt;code&gt;FLog&lt;/code&gt;的&lt;code&gt;setLoggingDelegate&lt;/code&gt;方法来实现的，只要实现自定义的&lt;code&gt;LoggingDelegate&lt;/code&gt;就可以将RN源码端的日志定向到应用日志中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_android_log.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2)对于iOS来说，日志重定向功能是依靠&lt;code&gt;RCTAddLogFunction&lt;/code&gt;方法来实现的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_log.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-重点流程耗时统计-关键事件数据上报&#34;&gt;&lt;strong&gt;3.重点流程耗时统计，关键事件数据上报&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;RN模块很容易出现问题，所以对它的重点流程的数据统计和上报也是非常重要的。例如bundle加载耗时多少，RN环境初始化耗时多少，bundle加载失败了多少次等等，这些数据都需要进行上报，以便后期提供更好的容错机制。&lt;/p&gt;

&lt;p&gt;一般来说，大家都想知道的是bundle加载耗时多少、RN环境初始化耗时多少、RN界面渲染耗时多少这三个数据。&lt;/p&gt;

&lt;p&gt;(1)对于Android来说，在RN的Android端源码中，&lt;code&gt;ReactMarker&lt;/code&gt;会在很多重要事件的起始和结束设置标志，而&lt;code&gt;ReactMarkerListener&lt;/code&gt;可以监听这些重要事件，所以如果我们设置了ReactMarkerListener的话，就能够在事件发生的时候收到回调从而统计耗时。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_android_time.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2)对于iOS来说，在RN的iOS端源码中，&lt;code&gt;RCTBridge&lt;/code&gt;的&lt;code&gt;PerformanceLogger&lt;/code&gt;会在重要事件的起始和结束时设置tag并统计耗时，通过它可以直接取出各项事件的耗时数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_time.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-完善bundle的更新时机-实现bundle立即生效方案&#34;&gt;&lt;strong&gt;4.完善bundle的更新时机，实现bundle立即生效方案&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;一般来说，为了方便和稳定，应用一般是在当次运行过程中下载好更新的bundle，但是在下次启动的时候才让新bundle生效。那如果想要实现在应用不重启的情况下让bundle当次立即生效怎么办呢？(&lt;strong&gt;需要注意的是，往往重新加载bundle文件的时候bundle文件位置可能不是原来那个位置&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;(1)对于iOS来说，在RN的iOS端源码中&lt;code&gt;RCTBridge&lt;/code&gt;提供了&lt;code&gt;reload&lt;/code&gt;方法来重新加载bundle文件，还提供了&lt;code&gt;setBundleURL&lt;/code&gt;方法来设置bundle文件的位置，所以iOS端RN离线包立即生效方案就是先设置新的bundle文件位置，然后再调用&lt;code&gt;reload&lt;/code&gt;方法进行重载即可，不需要修改RN源码再重新编译。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_reload.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2)对于Android来说，RN的Android端源码并没有提供修改bundle文件位置的方法，所以这里修改了RN源码中的&lt;code&gt;ReactInstanceManager&lt;/code&gt;类，删掉&lt;code&gt;mBundleLoader&lt;/code&gt;变量的&lt;code&gt;final&lt;/code&gt;修饰符，并为其提供set方法。和iOS端类似，RN离线包立即生效就是先根据新的bundle文件的位置设置ReactInstanceManager的&lt;code&gt;JSBundlerLoader&lt;/code&gt;，然后调用&lt;code&gt;recreateReactContextInBackground&lt;/code&gt;方法即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_android_reload.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;:&lt;br /&gt;
1.无论是Android端还是iOS端，bundle重载时最好要检查下当前屏幕是竖屏还是横屏，因为bundle重载的时候会重新加载和渲染之前已经attached的RN View(假设是按照横屏来布局的)，如果bundle重载时手机是横屏，那么这个RN View会按照横屏进行布局，这样回来的时候界面就会显示异常了。&lt;/p&gt;

&lt;p&gt;2.最好不要在应用当前处于RN界面的时候进行bundle重新加载，因为可能造成不可预计的数据异常或者界面显示异常，我们出现过一种数据异常导致应用crash的情况。&lt;/p&gt;

&lt;h4 id=&#34;5-bundle文件加载容错机制&#34;&gt;&lt;strong&gt;5.Bundle文件加载容错机制&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;默认情况下我们发出去的app中自带一个稳定版本的bundle，在其他bundle加载失败的情况下，就使用app自带的bundle文件进行容错。目前Android端还没有做这个功能，iOS因为可以接收到bundle加载失败的通知所以实现了这个功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_bundle_fail.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;除了bundle文件加载容错机制外，一般还要在RN界面出现crash的时候降级到H5的容灾方案，这块目前还在计划开发中。因为要做到完整的容灾的话，可能需要能够拦截到RN模块大部分的异常，虽然RN源码提供了拦截方法，但是这只是其中的部分异常，还有不少异常情况并没有被拦截到。&lt;/p&gt;

&lt;h4 id=&#34;6-给ios端的rn开发阶段新增调试功能&#34;&gt;&lt;strong&gt;6.给iOS端的RN开发阶段新增调试功能&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;众所周知，Android的RN调试菜单中可以指定server和port，这样就可以从network上加载指定的bundle文件，但是iOS的RN调试菜单中却没有这个功能，所以我实现了一个简易的针对iOS端开发阶段加载指定server上的bundle文件的调试功能，原理是利用&lt;code&gt;RCTBundleURLProvider&lt;/code&gt;的&lt;code&gt;jsBundleURLForBundleRoot:packagerHost:enableDev:enableMinification&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://javayhu.me/images/rn_ios_debug.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK，可能花了一晚上只是写了一堆废话吧，谢谢你看完，如果内容有什么错误或者想咨询的可以通过邮件联系我，因为多说关闭了，本想着什么时候换成网易云跟帖，结果前段时间听说也要关闭了，所以我想算了吧，不想再去接入其他的评论系统了。&lt;/p&gt;

&lt;p&gt;很明显，本文并没有提到RN专题中常见的性能优化和组件定制，这块我的经验尚浅，待有朝一日熟悉了再来说点废话吧，晚安。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>