<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Hujiawei Bujidao</title>
    <link>https://hujiaweibujidao.github.io/tags/android/</link>
    <description>Recent content in Android on Hujiawei Bujidao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved &amp;copy; 2016</copyright>
    <lastBuildDate>Tue, 24 Jan 2017 10:46:33 +0800</lastBuildDate>
    <atom:link href="https://hujiaweibujidao.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to know your application’s battery stats</title>
      <link>https://hujiaweibujidao.github.io/blog/2017/01/24/how-to-know-your-applications-battery-stats/</link>
      <pubDate>Tue, 24 Jan 2017 10:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2017/01/24/how-to-know-your-applications-battery-stats/</guid>
      <description>&lt;p&gt;本文总结下关于Android应用的耗电量的统计分析。&lt;/p&gt;

&lt;p&gt;本文简单总结下关于Android应用的耗电量的统计分析方法和工具。&lt;/p&gt;

&lt;p&gt;众所周知，Android系统内置了应用的耗电量统计分析功能，但是并没有提供相应的API和文档，只是可以查看耗电量排行榜前10的应用的耗电百分比。此外，随着Android系统版本的迭代，各个版本耗电量统计的方式略有不同，但庆幸的是其统计模型并没有什么大变化。本文在前人的研究基础上总结Android平台的耗电量统计相关的计算方法和辅助工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1)Android系统是如何进行应用的耗电量统计的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想了解Android系统是如何对应用进行耗电量统计计算的话建议先阅读：&lt;a href=&#34;http://gityuan.com/2016/01/10/power_rank/&#34;&gt;Android耗电统计算法&lt;/a&gt;这篇文章，&lt;strong&gt;作者是小米的MIUI系统工程师Gityuan(如果你想了解Android系统中常见模块的实现细节的话，非常推荐阅读这位开发者的博客，他的博客中文章的质量都非常高)&lt;/strong&gt;，此文从Android 6.0系统源码的角度详细分析了应用的耗电量的计算方法。阅读上文可知，耗电量计算包括软件耗电量计算和硬件耗电量计算，并且有各自的计算方法。&lt;/p&gt;

&lt;p&gt;下图是软件的耗电量统计项以及它的功耗计算公式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery_software_items.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery_software.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下图是硬件的功耗计算公式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery_hardware.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其他文章推荐：&lt;br /&gt;
1.&lt;a href=&#34;http://blog.csdn.net/itfootball/article/details/49155979&#34;&gt;Android性能专项测试之耗电量统计API&lt;/a&gt;&lt;br /&gt;
该文也是以Android 6.0系统源码来分析应用耗电量统计&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;http://www.cnblogs.com/hyddd/p/4402621.html&#34;&gt;深入浅出Android App耗电量统计&lt;/a&gt;&lt;br /&gt;
该文是耗电量统计方面最早的文章，分析的是Android 4.3系统源码中的应用耗电量统计&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&#34;http://blog.csdn.net/tangdl86/article/details/46958175&#34;&gt;Android应用的耗电量统计&lt;/a&gt;&lt;br /&gt;
该文是在上面的文章2的基础上做的分析，分析的是Android 5.1系统源码&lt;/p&gt;

&lt;p&gt;下面是从源码的分析得出的对于电量统计的通俗介绍：&lt;br /&gt;
&lt;code&gt;PowerUsageSummary&lt;/code&gt;类的作用是筛选耗电量最多的前10个应用，并且展示。真正计算耗电量数据的，是&lt;code&gt;com.android.internal.os.BatteryStatsHelper&lt;/code&gt;类，它计算所有应用的耗电。其中软件排行榜的计算算法：&lt;code&gt;BatteryStatsHelper&lt;/code&gt;类中的&lt;code&gt;processAppUsage()&lt;/code&gt;方法，硬件排行榜的计算算法：&lt;code&gt;BatteryStatsHelper&lt;/code&gt;类中的&lt;code&gt;processMiscUsage()&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;这个计算方法很有趣，有点象在超市购物：有一张“价格表”，记录每种硬件1秒钟耗多少电。有一张“购物清单”，记录apk使用了哪几种硬件，每种硬件用了多长时间。假设某个应用累计使用了60秒的cpu，cpu1秒钟耗1mAh，那这个应用就消耗了60mAh的电，实际的算法比这个例子复杂很多。从这里可以看出，Android自带的耗电量统计的准确性，受两个大方面的因素影响：&lt;/p&gt;

&lt;p&gt;一是那张“价格表”，由&lt;code&gt;PowerProfile&lt;/code&gt;类提供，它用于获取各个组件的电流数值，而&lt;code&gt;power_profile.xml&lt;/code&gt;是一个可配置的功耗数据文件。手机的硬件是各不相同的，所以每一款手机都会有一张自己的“价格表”。这张表的准确性由手机厂商负责，所以，尽量用大厂的机子，并且只使用该厂商提供的Android系统。&lt;/p&gt;

&lt;p&gt;二是那张“购物清单”，这是Android的&lt;code&gt;BatteryStatsService&lt;/code&gt;类提供的。上文说到的&lt;code&gt;BatteryStatsHelper&lt;/code&gt;类使用AIDL调用&lt;code&gt;BatteryStatsService&lt;/code&gt;类的&lt;code&gt;getStatisticsStream&lt;/code&gt;方法获取相关数据。&lt;/p&gt;

&lt;p&gt;从上面几篇文章中可以看出，&lt;strong&gt;各个Android版本的系统源码中耗电量统计的方式虽略有不同，但是大致的统计模型是不变的，而且统计的方式越来越科学可靠。Google官方对耗电量的统计给出的解释都是不能代表真实数据，只能作为参考值，因为受power_profile.xml的干扰太大，如果手机厂商没有严格设置这个文件，那可想而知出来的值可能是不合理的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)普通的应用开发者可以怎么统计应用的耗电量？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于权限的限制，普通的应用开发者并不太容易统计应用的耗电量。前面的推荐文章3中也提到过获取应用耗电量的权限控制，内容如下：Android4.4以前的版本，未对耗电量统计的代码做权限限制，只需要使用java反射等手段，就可以调用相关的内部类和隐藏接口。自Android4.4开始，Android严格限制了权限，普通应用即使在AndroidManifest.xml中申明使用&lt;code&gt;android.permission.BATTERY_STATS&lt;/code&gt;，也获取不到相关的统计数据。&lt;/p&gt;

&lt;p&gt;统计应用耗电量的工具：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.GT的Powerstat (腾讯开发的应用耗电量统计工具)&lt;/strong&gt;&lt;br /&gt;
项目地址：&lt;a href=&#34;http://gt.tencent.com/&#34;&gt;http://gt.tencent.com/&lt;/a&gt;&lt;br /&gt;
Powerstat的功能很强大，但是要求手机是root过的 (所以有个备用的高配电脑，随时能够编译Android源码，再有个备用安卓机，刷着原生的userdebug/debug版固件，这个世界不要太美好啊)&lt;/p&gt;

&lt;p&gt;Powerstat用户手册中有说明：Android 电量测试工具 Powerstat V1.x 版本支持 Android4.1~4.4的系统(4.4及以上系统上需要系统签名，在已获取root权限的情况下，可将apk包置于&lt;code&gt;/system/priv-app/&lt;/code&gt;目录下，作为系统应用运行)。工具的 V1.x2 版本在V1.x 版本的基础上进行开发，细分耗电项，增加定时自动保存功能，适配Android5.0。同样，在 Android4.4 及以上系统也需要root权限才能安装使用。&lt;/p&gt;

&lt;p&gt;Powerstat的应用耗电量计算方法基本上和系统的应用耗电量计算方法是一样的，它是通过各种方式包括反射的方法来获取应用在一段时间内的数据(例如占用的CPU时间、流进流出的数据量等)，然后利用系统的统计类&lt;code&gt;BatteryStatsHelper&lt;/code&gt;做些修改来计算应用的耗电量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.Battery Historian (Google官方出品)&lt;/strong&gt;&lt;br /&gt;
项目源码：&lt;a href=&#34;https://github.com/google/battery-historian&#34;&gt;https://github.com/google/battery-historian&lt;/a&gt;&lt;br /&gt;
Battery Historian是Google提供的针对Android 5.0及以上系统使用的分析电量相关信息的工具。&lt;/p&gt;

&lt;p&gt;Battery Historian is a tool to inspect battery related information and events on an Android device running Android 5.0 Lollipop (API level 21) and later, while the device was not plugged in. It allows application developers to visualize system and application level events on a timeline with panning and zooming functionality, easily see various aggregated statistics since the device was last fully charged, and select an application and inspect the metrics that impact battery specific to the chosen application. It also allows an A/B comparison of two bugreports, highlighting differences in key battery related metrics.&lt;/p&gt;

&lt;p&gt;目前BatteryHistorian工具有两个版本：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 Battery Historian 1.x&lt;/strong&gt;&lt;br /&gt;
第一个版本是python语言写的，只有一个Python脚本文件 historian.py，这个文件可以从第一版本的最后一次提交记录中下载(&lt;a href=&#34;https://github.com/google/battery-historian/tree/b711e0a8345147f449fd017e21913a8a6b8bd638&#34;&gt;https://github.com/google/battery-historian/tree/b711e0a8345147f449fd017e21913a8a6b8bd638&lt;/a&gt;) ，第一版本的使用步骤如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell dumpsys batterystats &amp;gt; xxx.txt  //得到整个设备的电量消耗信息
$ adb shell dumpsys batterystats &amp;gt; com.package.name &amp;gt; xxx.txt //得到指定app相关的电量消耗信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到了原始的电量消耗数据之后，我们需要通过 historian.py 脚本把数据信息转换成可读性更好的html文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python historian.py xxx.txt &amp;gt; xxx.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这个转换过后的html文件，可以看到类似TraceView生成的列表数据，其中的数据信息量很大&lt;/p&gt;

&lt;p&gt;旧版本的详细使用流程以及分析过程可以参考&lt;a href=&#34;https://developer.android.com/studio/profile/battery-historian.html&#34;&gt;Batterystats &amp;amp; Battery Historian Walkthrough&lt;/a&gt; 和 &lt;a href=&#34;https://developer.android.com/studio/profile/battery-historian-charts.html&#34;&gt;Battery Historian Charts&lt;/a&gt;，其中有些术语可能不太好理解，这里有个简略的&lt;a href=&#34;http://www.cnblogs.com/sjjg/p/5451519.html&#34;&gt;中文的解释版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下图很重要，它对不同类别的电量消耗进行了解释&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery_categories.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 Battery Historian 2.x&lt;/strong&gt;&lt;br /&gt;
第二个版本是go语言写的，代码很多，功能也更加完善，但是环境配置也更加复杂！&lt;/p&gt;

&lt;p&gt;首先，我们需要将Battery Historian工具在本地跑起来，要跑起来可以选择使用docker，也可以选择编译源码。
(1)如果是使用Mac或Linux平台的话，推荐直接通过docker运行Battery Historian来完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker -- run -p &amp;lt;port&amp;gt;:9999 gcr.io/android-battery-historian:2.1 --port 9999
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后在浏览器中输入 &lt;a href=&#34;http://localhost:&#34;&gt;http://localhost:&lt;/a&gt;&lt;port&gt; 就可以查看，然后上传bugreport文件进行分析了。&lt;/p&gt;

&lt;p&gt;(2)如果是使用Windows平台的话，也可以使用docker，但是机子要在BIOS中开启虚拟化，这里我选择源码编译方式，主要流程有：&lt;br /&gt;
1.首先下载配置Java环境 (要配置PATH)&lt;br /&gt;
2.接着下载配置Git环境 (要配置PATH)&lt;br /&gt;
3.接着下载配置Python 2.7环境 (要配置PATH)&lt;br /&gt;
4.接着下载配置Go环境 (要配置PATH和GOPATH以及GOBIN)&lt;br /&gt;
5.前面的配置其实很快就能完成，接下来就是下载Battery Historian的源码来进行编译了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -d -u github.com/google/battery-historian/…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载完成之后，代码会下载到配置的GOPATH中，可以去检查下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/google/battery-historian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换到那个目录，然后执行setup.go开始编译源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go run setup.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到下面的问题的话别担心，按照提示将对应url的文件下载下来放在要求的目录即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/go-compiler-error.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面的步骤都完成之后就可以启动Battery Historian了，默认端口是9999&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run cmd/battery-historian/battery-historian.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;待控制台输出&lt;code&gt;listening on port:9999&lt;/code&gt;的时候，可以打开浏览器输入 &lt;a href=&#34;http://localhost:9999&#34;&gt;http://localhost:9999&lt;/a&gt; 就可以看到&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery-historian-web.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其次，这个版本的输入是bugreport文件，根据系统版本不同它的获取方式略有差别：
如果是Android 7.0及以上版本的话可以通过 &lt;code&gt;adb bugreport bugreport.zip&lt;/code&gt; 来获取bugreport
如果是Android 6.0及以下版本的话可以通过 &lt;code&gt;adb bugreport &amp;gt; bugreport.txt&lt;/code&gt; 来获取bugreport&lt;/p&gt;

&lt;p&gt;获取到bugreport文件之后，我们就可以将其上传到Battery Historian上进行分析，下面是它的输出结果(注意如果是在开发网的话需要开启临时访问外网才行)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery-historian-chart.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在页面的下方我们可以查看这段时间内系统的状态system stats，也可以选择某个应用查看应用的状态app stats&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery-historian-appstats.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中我们可以看到&lt;code&gt;Device estimated power use&lt;/code&gt;中显示了估算的应用耗电量值为 &lt;code&gt;0.18%&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Battery Historian还有个比较功能，在首页选择 Switch to Bugreport Comparisor，然后就可以上传两个不同的bugreport文件，submit之后就可以看到它们的对比结果了，这个功能用来分析同一个应用的两个不同版本前后的耗电量非常有用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/battery_historian_compare.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，一般开始统计数据之前需要使用下面的命令将以前的累积数据清空&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb shell dumpsys batterystats --reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, Android does not record timestamps for application-specific userspace wakelock transitions even though aggregate statistics are maintained on a running basis. If you want Historian to display detailed information about each individual wakelock on the timeline, you should enable full wakelock reporting using the following command before starting your experiment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb shell dumpsys batterystats --enable full-wake-history
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于bugreport相关的知识推荐阅读&lt;a href=&#34;http://blog.csdn.net/createchance/article/details/51954142&#34;&gt;Android adb bugreport工具分析和使用&lt;/a&gt;这篇文章，作者简单地从源码角度分析了&lt;code&gt;adb bugreport&lt;/code&gt;命令的运行原理，结论是bugreport其实是启动了dumpstate服务来输出数据，其中数据来源包括：
1.系统属性&lt;br /&gt;
2./proc和/sys节点文件&lt;br /&gt;
3.执行shell命令获得相关输出&lt;br /&gt;
4.logcat输出&lt;br /&gt;
5.Android Framework Services信息基本使用dumpsys命令通过binder调用服务中的dump函数获得信息&lt;/p&gt;

&lt;p&gt;下面是其他的几篇关于battery-historian使用的文章可供参考
(1)&lt;a href=&#34;http://blog.csdn.net/itfootball/article/details/44084159&#34;&gt;Android性能专项测试之battery-historian使用&lt;/a&gt;
(2)&lt;a href=&#34;http://blog.csdn.net/itfootball/article/details/49004699&#34;&gt;Android性能专项测试之Batterystats&lt;/a&gt;
(3)&lt;a href=&#34;http://www.07net01.com/linux/2016/01/1207924.html&#34;&gt;Battery Historian 2.0 for windows环境搭建&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.关于电量方面的Android性能优化&lt;/strong&gt;
电量方面的性能优化可以参考
&lt;a href=&#34;http://hukai.me/android-performance-battery/&#34;&gt;性能优化典范中的Android性能优化之电量篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(1)为了减少电量的消耗，在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求
(2)使用Job Scheduler，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起执行&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Builtin Lint Detectors (1)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/12/01/builtin-lint-detectors-1/</link>
      <pubDate>Thu, 01 Dec 2016 10:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/12/01/builtin-lint-detectors-1/</guid>
      <description>&lt;p&gt;Lint工具中自带的与Android开发相关的lint检查项。&lt;/p&gt;

&lt;p&gt;本文主要介绍的是Lint工具中自带的与Android开发相关的lint检查项，通过查看lint检查项的描述及其代码实现，我发现这里面存在不少应用开发编码的Best Practice，有些是平常编码中非常常见的错误(这类问题建议看下对应的参考资料)，有些却有点隐晦(这类问题我们会仔细研究下)，这些lint检查项对于我们在平常编码过程中都会有不少启发。&lt;/p&gt;

&lt;p&gt;这里先提一下如何在Java和XML代码中屏蔽掉某个lint检查项，这是在某个检查项开启但是某个特殊位置想忽略这个检查错误的一种方式。至于如何将检查项开启/关闭或者配置某个检查项忽略某些文件或文件夹等内容请参见之前的几篇Lint文档。&lt;/p&gt;

&lt;p&gt;在Java代码中屏蔽掉某个lint检查可以使用&lt;code&gt;@SuppressLint&lt;/code&gt;这个注解，例如&lt;code&gt;@SuppressLint(&amp;quot;UseSparseArrays&amp;quot;)&lt;/code&gt;&lt;br /&gt;
在XML代码中屏蔽掉某个lint检查可以使用&lt;code&gt;tools:ignore&lt;/code&gt;属性声明，例如&lt;code&gt;tools:ignore=&amp;quot;ContentDescription&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是一些lint检查项的具体细节，我们一个个来介绍它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) Image without &lt;code&gt;contentDescription&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;AccessibilityDetector&lt;/code&gt;&lt;br /&gt;
说明：&lt;code&gt;ImageView&lt;/code&gt;和&lt;code&gt;ImageButton&lt;/code&gt;需要有&lt;code&gt;contentDescription&lt;/code&gt;属性来指定它的文字描述，除非它们声明了&lt;code&gt;tools:ignore=&amp;quot;ContentDescription&amp;quot;&lt;/code&gt;。此外，如果设置了&lt;code&gt;contentDescription&lt;/code&gt;属性就不需要再设置&lt;code&gt;hint&lt;/code&gt;属性了，它会将&lt;code&gt;hint&lt;/code&gt;属性覆盖掉不显示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2) Missing &lt;code&gt;labelFor&lt;/code&gt; attribute&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;LabelForDetector&lt;/code&gt;&lt;br /&gt;
说明：&lt;code&gt;EditText&lt;/code&gt;、&lt;code&gt;AutoCompleteTextView&lt;/code&gt;以及&lt;code&gt;MultiAutoCompleteTextView&lt;/code&gt;这三个特别的View，它们一般都是等待用户在里面输入内容，所以往往需要有其他的View例如&lt;code&gt;TextView&lt;/code&gt;通过&lt;code&gt;labelFor&lt;/code&gt;属性指向它们，这样的话&lt;code&gt;Textview&lt;/code&gt;的内容也就表明前面三个View是在等待用户输入什么内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) FrameLayout can be replaced with &lt;code&gt;&amp;lt;merge&amp;gt;&lt;/code&gt; tag&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;MergeRootFrameLayoutDetector&lt;/code&gt;&lt;br /&gt;
说明：检查&lt;code&gt;FrameLayout&lt;/code&gt;能否使用&lt;code&gt;merge&lt;/code&gt;标签进行布局优化，在某些情况下，如果&lt;code&gt;Framelayout&lt;/code&gt;是根布局，并且没有背景和padding的设置，那么它就有可能可以通过&lt;code&gt;merge&lt;/code&gt;标签对布局进行优化，但是到底是否可以还是需要开发者自行决定。&lt;br /&gt;
参考：&lt;a href=&#34;http://www.cnblogs.com/dukc/p/5136310.html&#34;&gt;Android中的merge标签&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4) Handler reference leaks&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;HandlerDetector&lt;/code&gt;&lt;br /&gt;
说明：这是很常见的Handler导致内存泄露的情景。如果Handler被定义为内部类的话，它可能会阻止它的外部类被GC掉。如果这个Handler是在非主线程的&lt;code&gt;Looper&lt;/code&gt;或者&lt;code&gt;MessageQueue&lt;/code&gt;中使用的话不会有问题；但是如果是在主线程中使用的话，那么就需要进行修复，方法是：将Handler定义为静态内部类(static inner class)，在实例化Handler的时候将外部类的弱引用(WeakReference)传递给Handler，并且在Handler内部将所有对外部类的引用都改为弱引用的形式。&lt;br /&gt;
参考：&lt;a href=&#34;http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/&#34;&gt;Android Handler引起的内存泄露问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(5) HashMap can be replaced with &lt;code&gt;SparseArray&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;JavaPerformanceDetector&lt;/code&gt;&lt;br /&gt;
说明：如果Map的key是Integer类型，推荐使用&lt;code&gt;SparseArray&lt;/code&gt;，而不是HashMap。特别地，如果Map的value的类型是int的话，推荐使用&lt;code&gt;SparseIntArray&lt;/code&gt;，因为它会避免int和Integer之间的封箱拆箱操作。同理，如果Map的value类型是long的话，推荐使用&lt;code&gt;SparseLongArray&lt;/code&gt;。HashMap内部采用的是数组+链表的结构存储数据，但是SparseArray内部采用的是双数组的结构存储数据，而且key是按照int的大小顺序来存放的，所以查找、删除操作都会先进行二分查找，这就导致了在数据量很大的情况下，SparseArray的性能反而不如HashMap。其次，Android还提供了另一个ArrayMap的类，它类似SparseArray的存储结构，只是key可以不是int类型。这两个数据结构一般用于数据量在千级以下，否则性能差于HashMap。&lt;br /&gt;
参考：&lt;a href=&#34;http://blog.csdn.net/u010687392/article/details/47809295&#34;&gt;Android SparseArray和ArrayMap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(6) Memory allocation within drawing code&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;JavaPerformanceDetector&lt;/code&gt;&lt;br /&gt;
说明：在Android中，draw和layout的过程的调用非常频繁，我们应该避免在这两个过程中创建对象，因为创建对象就要分配内存，如果内存不够的话就会GC，GC太长的话可能会导致界面出现卡顿现象。解决方案一般是将对象创建的操作提前，然后在draw的过程中重复使用，比如对于&lt;code&gt;Bitmap.create&lt;/code&gt;这类方法的调用就需要这么处理。这一点在众多性能优化的文章中反复提到，draw方法的调用时间必须要尽可能的短。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(7) Should use &lt;code&gt;valueOf&lt;/code&gt; instead of &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;JavaPerformanceDetector&lt;/code&gt;&lt;br /&gt;
说明：对于封装类，例如&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;等，我们最好不要直接调用封装类的构造器方法，例如&lt;code&gt;new Integer(42)&lt;/code&gt;，推荐使用封装类的&lt;code&gt;valueOf&lt;/code&gt;这个工厂方法，例如&lt;code&gt;Integer.valueOf(42)&lt;/code&gt;。&lt;br /&gt;
为什么要这样做呢？我们看下Integer的&lt;code&gt;valueOf&lt;/code&gt;方法的实现，它先会判断参数&lt;code&gt;i&lt;/code&gt;的范围，如果它是在&lt;code&gt;IntegerCache&lt;/code&gt;的缓存的int范围之内(一般默认情况下是[-128,127])的话就直接使用缓存的Integer，如果不是的话就还是使用&lt;code&gt;new Integer&lt;/code&gt;来创建对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Integer的内部类IntegerCache的实现
private static class IntegerCache {
    static final int low = -128;
    static final int high;//默认是127
    static final Integer cache[];//通过new Integer创建了从low到high的Integer
    //...忽略静态初始块代码
}

public static Integer valueOf(int i) {
    assert IntegerCache.high &amp;gt;= 127;
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;(8) Inefficient layout weight&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;InefficientWeightDetector&lt;/code&gt;&lt;br /&gt;
说明：如果在一个LinearLayout中只定义了一个包含weight属性值的组件时，推荐直接指定这个组件的width或者height是&lt;code&gt;0dp&lt;/code&gt;，这两种方式的效果是相同的，这个组件会占据父容器中的剩余空间(一般来说，剩余空间=父容器的总空间-没有设置&lt;code&gt;weight&lt;/code&gt;属性值的子组件的空间之和)。它们的区别在于，如果设置了width或者height的属性值，那么就省掉了计算这个组件自己的大小的过程。这里我们需要注意效果等价的前提条件是在一个LinearLayout中只定义了一个包含weight属性值的组件，此外如果LinearLayout的orientation是horizontal的话，推荐将组件的&lt;code&gt;layout_width&lt;/code&gt;设置为&lt;code&gt;0dp&lt;/code&gt;，而如果LinearLayout的orientation是vertical的话，推荐将组件的&lt;code&gt;layout_height&lt;/code&gt;设置为&lt;code&gt;0dp&lt;/code&gt;。如下面的例子所示，推荐将&lt;code&gt;android:layout_weight=&amp;quot;1&amp;quot;&lt;/code&gt;改为&lt;code&gt;android:layout_width=&amp;quot;0dp&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&amp;quot;wrap_content&amp;quot;  //推荐改成 0dp
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:layout_weight=&amp;quot;1&amp;quot;
        android:text=&amp;quot;@string/app_name&amp;quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://www.jianshu.com/p/17da46223da9&#34;&gt;从源码角度彻底分析layout_weight使用&lt;/a&gt;  &lt;a href=&#34;http://blog.csdn.net/fumier/article/details/48024407&#34;&gt;彻底搞明白layout_weight&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(9) Suspicious 0dp dimension&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;InefficientWeightDetector&lt;/code&gt;&lt;br /&gt;
说明：当水平方向的LinearLayout中的子组件的大小只是依据它们的weight属性值来确定的时候，我们通常会使用&lt;code&gt;0dp&lt;/code&gt;作为组件的width，因为这样可以省掉子组件的measure调用次数，这也就是前面的第(8)条。但是，如果我们没有给这个组件设置&lt;code&gt;weight&lt;/code&gt;属性的话那么这个组件就会因为width为0而不可见；或者如果我们将LinearLayout的orientation设置为vertical的话，虽然这个组件的height不为0，但是因为width为0导致这个组件也会变得不可见。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(10) Nested layout weights&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;InefficientWeightDetector&lt;/code&gt;&lt;br /&gt;
说明：如果组件设置了&lt;code&gt;weight&lt;/code&gt;属性的话，这个组件将会被measure两次。当一个weight属性值非零的组件中被包含在另一个weight属性值非零的组件的时候(也就是weight属性嵌套了)，这些组件被measure的次数将呈指数增长，如下所示，这种情况需要尽可能避免发生。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    //...&amp;gt;

    &amp;lt;TextView
        //...
        android:layout_weight=&amp;quot;1&amp;quot;/&amp;gt;

    &amp;lt;LinearLayout
        //...
        android:layout_weight=&amp;quot;3&amp;quot;&amp;gt;

        &amp;lt;TextView
            //...
            android:layout_weight=&amp;quot;1&amp;quot; /&amp;gt;
        &amp;lt;TextView
            //...
            android:layout_weight=&amp;quot;2&amp;quot; /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;(11) Missing &lt;code&gt;baselineAligned&lt;/code&gt; attribute&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;InefficientWeightDetector&lt;/code&gt;&lt;br /&gt;
说明：当一个LinearLayout是水平方向布局且它的子组件都是Layout，并且至少有一个Layout有weight属性值时候，推荐将这个LinearLayout的&lt;code&gt;android:baselineAligned&lt;/code&gt;属性值设置为&lt;code&gt;false&lt;/code&gt;，这样的话将加快布局大小的计算速度。&lt;br /&gt;
参考：&lt;a href=&#34;http://www.cnblogs.com/JohnTsai/p/4074643.html&#34;&gt;Android中LinearLayout的baselineAligned属性的作用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(12) Missing explicit orientation&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;InefficientWeightDetector&lt;/code&gt;&lt;br /&gt;
说明：LinearLayout默认的orientation是horizontal(水平方向)，但是很容易被误解为是vertical(垂直方向)，所以当LinearLayout中有很多个子组件并且其中至少有个组件设置了&lt;code&gt;layout_width&lt;/code&gt;是&lt;code&gt;match_parent&lt;/code&gt;或者&lt;code&gt;fill_parent&lt;/code&gt;的时候，lint就会提示要求显式设置orientation。
或者没有子组件但是定义了&lt;code&gt;id&lt;/code&gt;属性值的时候，lint检查器就会提醒建议显式声明LinearLayout的orientation属性值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(13) Layout has too many views&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;TooManyViewsDetector&lt;/code&gt;&lt;br /&gt;
说明：在一个单独的layout中不应该有太多的view，因为view太多了会影响性能，可以考虑使用Compound Drawable(例如TextView有上下左右共4个Compound Drawable)等技术来减少layout中的view的数目。默认的最大的view的数目是80，但是我们可以通过&lt;code&gt;ANDROID_LINT_MAX_VIEW_COUNT&lt;/code&gt;这个环境变量来修改它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(14) Layout hierarchy is too deep&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;TooManyViewsDetector&lt;/code&gt;&lt;br /&gt;
说明：布局嵌套太深同样非常影响性能，推荐使用flatter layout，例如RelativeLayout、GridLayout等。默认的最大深度是10，但是我们可以通过&lt;code&gt;ANDROID_LINT_MAX_DEPTH&lt;/code&gt;这个环境变量来修改它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(15) Missing recycle() calls&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;CleanupDetector&lt;/code&gt;&lt;br /&gt;
说明：很多资源例如&lt;code&gt;TypedArrays&lt;/code&gt;、&lt;code&gt;VelocityTracker&lt;/code&gt;等在使用完之后都需要调用&lt;code&gt;recycle()&lt;/code&gt;方法将资源释放掉，其他的例如&lt;code&gt;Cursor&lt;/code&gt;对象则需要在使用完之后调用&lt;code&gt;close()&lt;/code&gt;方法来释放资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(16) Missing commit() calls&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;CleanupDetector&lt;/code&gt;&lt;br /&gt;
说明：&lt;code&gt;FragmentTransaction&lt;/code&gt;在创建并使用了之后一般都要调用&lt;code&gt;commit&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(17) Missing commit() on SharedPreference editor&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;CleanupDetector&lt;/code&gt;&lt;br /&gt;
说明：在&lt;code&gt;SharedPreference&lt;/code&gt;调用了&lt;code&gt;edit()&lt;/code&gt;方法之后，我们都需要在editor上调用&lt;code&gt;commit()&lt;/code&gt;或者&lt;code&gt;apply()&lt;/code&gt;方法来保存结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(18) Node can be replaced by a TextView with compound drawables&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;UseCompoundDrawableDetector&lt;/code&gt;&lt;br /&gt;
说明：如果一个LinearLayout中包含一个ImageView和一个Textview的话可以用一个单独的Textview(Compound Drawable)代替它，并使用&lt;code&gt;drawableLeft&lt;/code&gt;、&lt;code&gt;drawableTop&lt;/code&gt;等属性来设置图片和文本的对齐方式。此外，如果需要设置两个组件之间的间隔(margin)，可以使用&lt;code&gt;drawablePadding&lt;/code&gt;属性。从源码实现上来看，如果LinearLayout有设置&lt;code&gt;background&lt;/code&gt;或者ImageView有设置&lt;code&gt;scaleType&lt;/code&gt;的话就不会提示这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(19) Overdraw: Painting regions more than once&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;OverdrawDetector&lt;/code&gt;&lt;br /&gt;
说明：如果你给一个root view设置了一个background，那么你应该自定义一个theme并设置theme的background是null，否则theme的background会先绘制上去，然后自定义的background再绘制上去并完全覆盖它，这就造成了过度绘制的问题。需要注意的是，这个检查器依赖于layout和activity之间的映射关系，这个关系的确定需要检查Java代码(所以&lt;code&gt;OverdrawDetector&lt;/code&gt;既实现了&lt;code&gt;XmlScanner&lt;/code&gt;又实现了&lt;code&gt;JavaPsiScanner&lt;/code&gt;)。目前这个检查器使用的是一个不完全正确的模式匹配算法，所以它的检查结果可能有误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(20) Obsolete layout params&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;ObsoleteLayoutParamsDetector&lt;/code&gt;&lt;br /&gt;
说明：这个检查器检查layout/view的layout参数，有些layout参数只在某些layout中存在，对于其他layout没有效果，比如&lt;code&gt;layout_weight&lt;/code&gt;属性只会在LinearLayout中使用才有效，如果在其他的layout中使用的话会造成运行时多余的属性值处理而影响性能，所以最好是删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(21) Static Field Leaks&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;LeakDetector&lt;/code&gt;&lt;br /&gt;
说明：这个检查器检查是否存在类中定义的静态变量而造成的内存泄露问题。从源码实现来看，主要检查的是Java类中是否存在static修饰的&lt;code&gt;Context&lt;/code&gt;、&lt;code&gt;View&lt;/code&gt;、&lt;code&gt;Fragment&lt;/code&gt;等类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(22) Tagged object leaks&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;ViewTagDetector&lt;/code&gt;&lt;br /&gt;
说明：在Android 4.0(API 14)之前，&lt;code&gt;View.setTag(int, object)&lt;/code&gt;方法的实现是将objects存储在静态的map中，而且values是强引用的，所以，如果object中包含对某个context的引用的话，就可能造成对应的context的内存泄露。如果传入的是一个view，view对于创建它的context持有引用，同理，view holder通常也包含一个view，cursors也经常是和view关联的，它们都有可能会出现这种内存泄露的情况。注意这个问题只是有可能在4.0版本之前出现，之后这个内存泄露问题已经解决了，所以不检查。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(23) Unconditional Logging Calls&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;LogDetector&lt;/code&gt;&lt;br /&gt;
说明：&lt;code&gt;BuildConfig&lt;/code&gt;类(它是从Tools 17开始有的)提供了一个变量&lt;code&gt;DEBUG&lt;/code&gt;，用来表示这个代码是在release模式还是debug模式下。如果是在release模式下，通常我们需要将所有的日志输出部分的代码去掉，庆幸的是，编译器会自动地将所有代码中用&lt;code&gt;if(false)&lt;/code&gt;包围的语句块删除掉，所以推荐打log的时候加上对&lt;code&gt;BuildConfig.DEBUG&lt;/code&gt;的判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(24) Mismatched Log Tags&lt;/strong&gt;&lt;br /&gt;
实现：&lt;code&gt;LogDetector&lt;/code&gt;&lt;br /&gt;
说明：这个检查项是检查打log时判断是否可以打印的tag与实际打印的log的tag是否是统一的，也就是&lt;code&gt;Log.isLoggable(tag)&lt;/code&gt;和&lt;code&gt;Log.v(tag, ...)&lt;/code&gt;这两个语句中的tag必须是一致的。&lt;/p&gt;

&lt;p&gt;持续添加中&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lint Tool Analysis (3)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/19/lint-tool-analysis-3/</link>
      <pubDate>Sat, 19 Nov 2016 10:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/19/lint-tool-analysis-3/</guid>
      <description>

&lt;p&gt;Lint工具的源码分析(3)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本系列的几篇源码分析文档意义不大，如果你正好也在研究lint源码，或者你想知道前面自定义lint规则中提出的那几个问题，抑或你只是想大致了解下lint的源码都有些什么内容的话，这些文章可能有还些作用，否则看了和没看差不多的，因为这几篇文章只是我在读源码的过程中记录下来的一些零碎的片段，方便以后看的时候能够迅速上手。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面我们提了很多lint工具中&lt;code&gt;detector.api&lt;/code&gt;和&lt;code&gt;client.api&lt;/code&gt;包下的类，但是还没介绍到lint检查器到底是如何对文件进行检查的，这也就是本节需要介绍的知识点。&lt;/p&gt;

&lt;h3 id=&#34;3-lint检查器的前提知识&#34;&gt;3. Lint检查器的前提知识&lt;/h3&gt;

&lt;p&gt;首先我们需要了解的是，lint工具在实现lint检查时使用了Visitor设计模式，推荐阅读&lt;a href=&#34;http://en.wikipedia.org/wiki/Visitor_pattern&#34;&gt;这篇文章&lt;/a&gt;看下一般如何来实现这个设计模式。我们每个lint检查器在使用之前都要进行注册，注册的时候它也指明了它的工作范围以及它感兴趣的文件、方法甚至语句等。当lint工具开始扫描项目文件进行lint检查时，如果发现某个检查器感兴趣的内容就会交给对应的检查器去做相应的检查，如果有错就会报出错误，如果没有就表示代码通过检查，这就是一种visitor模式的体现。&lt;/p&gt;

&lt;p&gt;其次我们需要知道的是关于Java代码的解析，一般来说，对代码的解析都是将其转换成抽象语法树，英文名是Abstract Syntax Tree，它是开发工具中很多功能的内部实现原理，例如删除无用的声明语句，变量重命名等。推荐阅读&lt;a href=&#34;http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/&#34;&gt;Abstract Syntax Tree&lt;/a&gt;这篇文章来了解AST，其中也介绍到了Visitor设计模式，并简单道出了lint检查的核心原理。&lt;/p&gt;

&lt;p&gt;最后，关于lint工具的实现还有不少有意思的槽点，下面的几段英文内容摘录自&lt;a href=&#34;http://code.google.com/p/android/issues/detail?id=224584&#34;&gt;google code上关于lint工具的一个讨论&lt;/a&gt;，其中lint开发者解释了他们在实现Java文件解析时的技术方案选型原因、目前存在的问题以及将来的开发方向。&lt;/p&gt;

&lt;p&gt;In 2.2, I&amp;rsquo;ve completely rewritten the Java handling in lint. This was necessary in order to support Java 8 (which Nougat now supports). To do this, I replaced the Lombok AST stuff (which didn&amp;rsquo;t even properly support Java 7) with &amp;ldquo;PSI&amp;rdquo; (which are the same APIs as IntelliJ is using internally, except in lint&amp;rsquo;s case, it&amp;rsquo;s backed by a bridge to ECJ). This has a bunch of advantages: the PSI API is much cleaner, it contains type resolution right built in (instead of the ugly parallel ResolvedNode hierarchy I built up to augment Lombok which didn&amp;rsquo;t support type resolution). So for example, when you&amp;rsquo;re handed a method call node, you can call .resolve() on it and it will return the method the call invokes etc etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[大致内容]&lt;/strong&gt; 在Android Studio 2.2版本中，为了支持Java 8(Android Nougat支持Java 8)，开发者完全重写了lint工具中对Java代码的解析。以前使用的是&lt;code&gt;Lombok AST&lt;/code&gt;(连Java 7都不支持)，现在使用的是&lt;code&gt;PSI&lt;/code&gt;(和Intellij内部对Java代码解析使用的是同一套API，但是lint除外，它使用的是&lt;code&gt;ECJ [Eclipse Compiler for Java]&lt;/code&gt;)。&lt;br /&gt;
PSI API有很多好处，它更加简洁，并且内置了类型解析功能(Lombok不知道类型解析)。所以，开发者将原有的lint检查项基本上全部使用PSI API重写了一遍，下面是重写的&lt;a href=&#34;https://android.googlesource.com/platform/tools/base/+/8cdccd1bdf595b9b5e9a040a380d5a3372807fb2&#34;&gt;提交记录&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;However, I didn&amp;rsquo;t actually delete the old Lombok code path, since some people my have custom rules using Lombok. So, if lint comes across a project that is using custom lint rules, it has to process the file TWICE: first using the PSI bridge, and then all over again with Lombok. This obviously slows downs things.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[大致内容]&lt;/strong&gt; 但是，考虑到还是有人会使用Lombok API来开发自定义的lint规则，所以开发者并没有删除旧的Lombok相关代码。这也导致如果项目中使用了旧的API自定义的lint规则的话，lint会对这个文件检查两次，从而使得lint检查的速度变慢。&lt;/p&gt;

&lt;p&gt;I have a commented out warning in the lint driver which emits a warning when this is the case (basically explaining that lint came across a custom lint rule which is using the old APIs, which still works, but slows things down and may not work in the future.)&lt;/p&gt;

&lt;p&gt;However, I disabled that because I may still do another big change to the APIs &amp;ndash; and I don&amp;rsquo;t want to force everyone to jump through hoops of porting their lint checks to the new 2.2 APIs, only to have them change them again shortly.&lt;/p&gt;

&lt;p&gt;The API change I&amp;rsquo;m referring to is UAST; a &amp;ldquo;universal AST&amp;rdquo; that JetBrains is working on. It&amp;rsquo;s pretty similar to PSI (so certainly porting to the current PSI apis will make a much smaller migration to UAST than straight from Lombok), but the idea is that it&amp;rsquo;s a bit more language agnostic, so for example a single lint AST check can work not just with Java but also transparently with Kotlin, etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[大致内容]&lt;/strong&gt; 虽然开发者目前已经将Lombok API升级到PSI API，但是他们正在计划着做另一个重大的变化，也就是升级到&lt;code&gt;UAST&lt;/code&gt; API，这个是JetBrains目前正在做的。它和PSI API类似，但是思想上更加先进，更加与语言无关，例如一个简单的lint检查可能不止可以作用在Java代码上，也能作用在Kotlin代码上。&lt;/p&gt;

&lt;p&gt;假设现在我们想要将原来的Lombok API形式的lint检查升级到PSI API形式，我们该如何做呢？&lt;br /&gt;
详情可以参考&lt;code&gt;JavaPsiScanner&lt;/code&gt;类的注释内容，其中详细介绍了如何将API轻松迁移，但是轻松只是相对于那些熟悉PSI API的开发者，对于不熟悉它的开发者来说，这种迁移还是比较困难的。当我们自定义lint检查器的时候需要注意 &lt;strong&gt;lint-api的版本问题&lt;/strong&gt;，不同版本的Java检查器需要实现的接口有差异。&lt;br /&gt;
(1) &lt;code&gt;compile &#39;com.android.tools.lint:lint-api:24.5.0&#39;&lt;/code&gt;&lt;br /&gt;
使用&lt;code&gt;JavaScanner&lt;/code&gt; =&amp;gt; older Lombok AST API&lt;br /&gt;
(2) &lt;code&gt;compile &#39;com.android.tools.lint:lint-api:25.2.0&#39;&lt;/code&gt;&lt;br /&gt;
需要迁移到&lt;code&gt;JavaPsiScanner&lt;/code&gt; =&amp;gt; IntelliJ IDEA&amp;rsquo;s &amp;ldquo;PSI&amp;rdquo; API&lt;/p&gt;

&lt;h3 id=&#34;4-java代码的lint检查器&#34;&gt;4. Java代码的Lint检查器&lt;/h3&gt;

&lt;p&gt;(1) &lt;code&gt;JavaParser&lt;/code&gt;&lt;br /&gt;
解析Java文件的抽象类，实际实现类是&lt;code&gt;LombokPsiParser&lt;/code&gt;，将来可能会被修改为其他的Parser。&lt;/p&gt;

&lt;p&gt;(2) &lt;code&gt;JavaPsiScanner&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;注意：在最新的25.2.0版本的lint-api中JavaScanner已经被注明为deprecated了，推荐使用JavaPsiScanner。&lt;/strong&gt;&lt;br /&gt;
下面是&lt;code&gt;JavaPsiScanner&lt;/code&gt;接口的源码，任何对Java源代码文件进行lint检查的Detector都需要实现这个接口，主要是定义了几个&lt;code&gt;visit&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface JavaPsiScanner  {
    /**
     * Create a parse tree visitor to process the parse tree. All
     * {@link JavaScanner} detectors must provide a visitor, unless they
     * either return true from {@link #appliesToResourceRefs()} or return
     * non null from {@link #getApplicableMethodNames()}.
     * &amp;lt;p&amp;gt;
     * If you return specific AST node types from
     * {@link #getApplicablePsiTypes()}, then the visitor will &amp;lt;b&amp;gt;only&amp;lt;/b&amp;gt;
     * be called for the specific requested node types. This is more
     * efficient, since it allows many detectors that apply to only a small
     * part of the AST (such as method call nodes) to share iteration of the
     * majority of the parse tree.
     * &amp;lt;p&amp;gt;
     * If you return null from {@link #getApplicablePsiTypes()}, then your
     * visitor will be called from the top and all node types visited.
     * &amp;lt;p&amp;gt;
     * Note that a new visitor is created for each separate compilation
     * unit, so you can store per file state in the visitor.
     * &amp;lt;p&amp;gt;
     * &amp;lt;b&amp;gt;
     * NOTE: Your visitor should &amp;lt;b&amp;gt;NOT&amp;lt;/b&amp;gt; extend JavaRecursiveElementVisitor.
     * Your visitor should only visit the current node type; the infrastructure
     * will do the recursion. (Lint&#39;s unit test infrastructure will check and
     * enforce this restriction.)
     * &amp;lt;/b&amp;gt;
     *
     * @param context the {@link Context} for the file being analyzed
     * @return a visitor, or null.
     */
    @Nullable
    JavaElementVisitor createPsiVisitor(@NonNull JavaContext context);

    /**
     * Return the types of AST nodes that the visitor returned from
     * {@link #createJavaVisitor(JavaContext)} should visit. See the
     * documentation for {@link #createJavaVisitor(JavaContext)} for details
     * on how the shared visitor is used.
     * &amp;lt;p&amp;gt;
     * If you return null from this method, then the visitor will process
     * the full tree instead.
     * &amp;lt;p&amp;gt;
     * Note that for the shared visitor, the return codes from the visit
     * methods are ignored: returning true will &amp;lt;b&amp;gt;not&amp;lt;/b&amp;gt; prune iteration
     * of the subtree, since there may be other node types interested in the
     * children. If you need to ensure that your visitor only processes a
     * part of the tree, use a full visitor instead. See the
     * OverdrawDetector implementation for an example of this.
     *
     * @return the list of applicable node types (AST node classes), or null
     */
    @Nullable
    List&amp;lt;Class&amp;lt;? extends PsiElement&amp;gt;&amp;gt; getApplicablePsiTypes();

    /**
     * Return the list of method names this detector is interested in, or
     * null. If this method returns non-null, then any AST nodes that match
     * a method call in the list will be passed to the
     * {@link #visitMethod(JavaContext, JavaElementVisitor, PsiMethodCallExpression, PsiMethod)}
     * method for processing. The visitor created by
     * {@link #createPsiVisitor(JavaContext)} is also passed to that
     * method, although it can be null.
     * &amp;lt;p&amp;gt;
     * This makes it easy to write detectors that focus on some fixed calls.
     * For example, the StringFormatDetector uses this mechanism to look for
     * &amp;quot;format&amp;quot; calls, and when found it looks around (using the AST&#39;s
     * {@link PsiElement#getParent()} method) to see if it&#39;s called on
     * a String class instance, and if so do its normal processing. Note
     * that since it doesn&#39;t need to do any other AST processing, that
     * detector does not actually supply a visitor.
     *
     * @return a set of applicable method names, or null.
     */
    @Nullable
    List&amp;lt;String&amp;gt; getApplicableMethodNames();

    /**
     * Method invoked for any method calls found that matches any names
     * returned by {@link #getApplicableMethodNames()}. This also passes
     * back the visitor that was created by
     * {@link #createJavaVisitor(JavaContext)}, but a visitor is not
     * required. It is intended for detectors that need to do additional AST
     * processing, but also want the convenience of not having to look for
     * method names on their own.
     *
     * @param context the context of the lint request
     * @param visitor the visitor created from
     *            {@link #createPsiVisitor(JavaContext)}, or null
     * @param call the {@link PsiMethodCallExpression} node for the invoked method
     * @param method the {@link PsiMethod} being called
     */
    void visitMethod(
            @NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor,
            @NonNull PsiMethodCallExpression call,
            @NonNull PsiMethod method);

    /**
     * Return the list of constructor types this detector is interested in, or
     * null. If this method returns non-null, then any AST nodes that match
     * a constructor call in the list will be passed to the
     * {@link #visitConstructor(JavaContext, JavaElementVisitor, PsiNewExpression, PsiMethod)}
     * method for processing. The visitor created by
     * {@link #createJavaVisitor(JavaContext)} is also passed to that
     * method, although it can be null.
     * &amp;lt;p&amp;gt;
     * This makes it easy to write detectors that focus on some fixed constructors.
     *
     * @return a set of applicable fully qualified types, or null.
     */
    @Nullable
    List&amp;lt;String&amp;gt; getApplicableConstructorTypes();

    /**
     * Method invoked for any constructor calls found that matches any names
     * returned by {@link #getApplicableConstructorTypes()}. This also passes
     * back the visitor that was created by
     * {@link #createPsiVisitor(JavaContext)}, but a visitor is not
     * required. It is intended for detectors that need to do additional AST
     * processing, but also want the convenience of not having to look for
     * method names on their own.
     *
     * @param context the context of the lint request
     * @param visitor the visitor created from
     *            {@link #createPsiVisitor(JavaContext)}, or null
     * @param node the {@link PsiNewExpression} node for the invoked method
     * @param constructor the called constructor method
     */
    void visitConstructor(
            @NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor,
            @NonNull PsiNewExpression node,
            @NonNull PsiMethod constructor);

    /**
     * Return the list of reference names types this detector is interested in, or null. If this
     * method returns non-null, then any AST elements that match a reference in the list will be
     * passed to the {@link #visitReference(JavaContext, JavaElementVisitor,
     * PsiJavaCodeReferenceElement, PsiElement)} method for processing. The visitor created by
     * {@link #createJavaVisitor(JavaContext)} is also passed to that method, although it can be
     * null. &amp;lt;p&amp;gt; This makes it easy to write detectors that focus on some fixed references.
     *
     * @return a set of applicable reference names, or null.
     */
    @Nullable
    List&amp;lt;String&amp;gt; getApplicableReferenceNames();

    /**
     * Method invoked for any references found that matches any names returned by {@link
     * #getApplicableReferenceNames()}. This also passes back the visitor that was created by
     * {@link #createPsiVisitor(JavaContext)}, but a visitor is not required. It is intended for
     * detectors that need to do additional AST processing, but also want the convenience of not
     * having to look for method names on their own.
     *
     * @param context    the context of the lint request
     * @param visitor    the visitor created from {@link #createPsiVisitor(JavaContext)}, or
     *                   null
     * @param reference  the {@link PsiJavaCodeReferenceElement} element
     * @param referenced the referenced element
     */
    void visitReference(
            @NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor,
            @NonNull PsiJavaCodeReferenceElement reference,
            @NonNull PsiElement referenced);

    /**
     * Returns whether this detector cares about Android resource references
     * (such as {@code R.layout.main} or {@code R.string.app_name}). If it
     * does, then the visitor will look for these patterns, and if found, it
     * will invoke {@link #visitResourceReference} passing the resource type
     * and resource name. It also passes the visitor, if any, that was
     * created by {@link #createJavaVisitor(JavaContext)}, such that a
     * detector can do more than just look for resources.
     *
     * @return true if this detector wants to be notified of R resource
     *         identifiers found in the code.
     */
    boolean appliesToResourceRefs();

    /**
     * Called for any resource references (such as {@code R.layout.main}
     * found in Java code, provided this detector returned {@code true} from
     * {@link #appliesToResourceRefs()}.
     *
     * @param context the lint scanning context
     * @param visitor the visitor created from
     *            {@link #createPsiVisitor(JavaContext)}, or null
     * @param node the variable reference for the resource
     * @param type the resource type, such as &amp;quot;layout&amp;quot; or &amp;quot;string&amp;quot;
     * @param name the resource name, such as &amp;quot;main&amp;quot; from
     *            {@code R.layout.main}
     * @param isFramework whether the resource is a framework resource
     *            (android.R) or a local project resource (R)
     */
    void visitResourceReference(
            @NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor,
            @NonNull PsiElement node,
            @NonNull ResourceType type,
            @NonNull String name,
            boolean isFramework);

    /**
     * Returns a list of fully qualified names for super classes that this
     * detector cares about. If not null, this detector will &amp;lt;b&amp;gt;only&amp;lt;/b&amp;gt; be called
     * if the current class is a subclass of one of the specified superclasses.
     *
     * @return a list of fully qualified names
     */
    @Nullable
    List&amp;lt;String&amp;gt; applicableSuperClasses();

    /**
     * Called for each class that extends one of the super classes specified with
     * {@link #applicableSuperClasses()}.
     * &amp;lt;p&amp;gt;
     * Note: This method will not be called for {@link PsiTypeParameter} classes. These
     * aren&#39;t really classes in the sense most lint detectors think of them, so these
     * are excluded to avoid having lint checks that don&#39;t defensively code for these
     * accidentally report errors on type parameters. If you really need to check these,
     * use {@link #getApplicablePsiTypes} with {@code PsiTypeParameter.class} instead.
     *
     * @param context the lint scanning context
     * @param declaration the class declaration node, or null for anonymous classes
     */
    void checkClass(@NonNull JavaContext context, @NonNull PsiClass declaration);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) 下面以&lt;code&gt;LogDetector&lt;/code&gt;为例，介绍下一个Java代码的Lint检查器的大致结构：&lt;br /&gt;
① 首先声明&lt;code&gt;LogDetector&lt;/code&gt;继承自&lt;code&gt;Detector&lt;/code&gt;并实现了&lt;code&gt;JavaPsiScanner&lt;/code&gt;接口，&lt;code&gt;Detector&lt;/code&gt;类是检查器的适配器类，&lt;code&gt;JavaPsiScanner&lt;/code&gt;接口是对Java代码文件进行检查的接口；&lt;br /&gt;
② 接着定义一个&lt;code&gt;Implementation&lt;/code&gt;实例，声明这个检查器的实现类是&lt;code&gt;LogDetector.class&lt;/code&gt;，它的检查范围是&lt;code&gt;Scope.JAVA_FILE_SCOPE&lt;/code&gt;，也就是Java代码文件；&lt;br /&gt;
③ 然后定义这个检查器将会检查代码中是否存在的&lt;code&gt;Issue&lt;/code&gt;，每个问题有名称(&lt;code&gt;LogConditional&lt;/code&gt;)、描述、类别(&lt;code&gt;Category.PERFORMANCE&lt;/code&gt;)、等级(&lt;code&gt;5&lt;/code&gt;)、严重程度(&lt;code&gt;Severity.WARNING&lt;/code&gt;)、检查器的实现类以及是否默认开启等信息；&lt;br /&gt;
④ 接着在方法&lt;code&gt;getApplicableMethodNames&lt;/code&gt;中声明这个检查器关心的方法，因为这个检查器是检查应用中的log是否符合规范，所以比较关心&lt;code&gt;d/e/i/v/w&lt;/code&gt;等常见的log打印方法；&lt;br /&gt;
⑤ 最后就是在方法&lt;code&gt;visitMethod&lt;/code&gt;中对上面声明的并且在lint检查时遇到的那些方法进行检查，看它们是否符合规范，如果不符合规范的话就会report出错误信息。源代码文件中声明其他的变量和私有方法都是为了完成检查过程定义的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Detector for finding inefficiencies and errors in logging calls.
 */
public class LogDetector extends Detector implements JavaPsiScanner {
    private static final Implementation IMPLEMENTATION = new Implementation(
          LogDetector.class, Scope.JAVA_FILE_SCOPE);

    /** Log call missing surrounding if */
    public static final Issue CONDITIONAL = Issue.create(
            &amp;quot;LogConditional&amp;quot;, //$NON-NLS-1$
            &amp;quot;Unconditional Logging Calls&amp;quot;,
            &amp;quot;The BuildConfig class (available in Tools 17) provides a constant, \&amp;quot;DEBUG\&amp;quot;, &amp;quot; +
            &amp;quot;which indicates whether the code is being built in release mode or in debug &amp;quot; +
            &amp;quot;mode. In release mode, you typically want to strip out all the logging calls. &amp;quot; +
            &amp;quot;Since the compiler will automatically remove all code which is inside a &amp;quot; +
            &amp;quot;\&amp;quot;if (false)\&amp;quot; check, surrounding your logging calls with a check for &amp;quot; +
            &amp;quot;BuildConfig.DEBUG is a good idea.\n&amp;quot; +
            &amp;quot;\n&amp;quot; +
            &amp;quot;If you *really* intend for the logging to be present in release mode, you can &amp;quot; +
            &amp;quot;suppress this warning with a @SuppressLint annotation for the intentional &amp;quot; +
            &amp;quot;logging calls.&amp;quot;,

            Category.PERFORMANCE,
            5,
            Severity.WARNING,
            IMPLEMENTATION).setEnabledByDefault(false);

    /** Mismatched tags between isLogging and log calls within it */
    public static final Issue WRONG_TAG = Issue.create(
            &amp;quot;LogTagMismatch&amp;quot;, //$NON-NLS-1$
            &amp;quot;Mismatched Log Tags&amp;quot;,
            &amp;quot;When guarding a `Log.v(tag, ...)` call with `Log.isLoggable(tag)`, the &amp;quot; +
            &amp;quot;tag passed to both calls should be the same. Similarly, the level passed &amp;quot; +
            &amp;quot;in to `Log.isLoggable` should typically match the type of `Log` call, e.g. &amp;quot; +
            &amp;quot;if checking level `Log.DEBUG`, the corresponding `Log` call should be `Log.d`, &amp;quot; +
            &amp;quot;not `Log.i`.&amp;quot;,

            Category.CORRECTNESS,
            5,
            Severity.ERROR,
            IMPLEMENTATION);

    /** Log tag is too long */
    public static final Issue LONG_TAG = Issue.create(
            &amp;quot;LongLogTag&amp;quot;, //$NON-NLS-1$
            &amp;quot;Too Long Log Tags&amp;quot;,
            &amp;quot;Log tags are only allowed to be at most 23 tag characters long.&amp;quot;,

            Category.CORRECTNESS,
            5,
            Severity.ERROR,
            IMPLEMENTATION);

    @SuppressWarnings(&amp;quot;SpellCheckingInspection&amp;quot;)
    private static final String IS_LOGGABLE = &amp;quot;isLoggable&amp;quot;;       //$NON-NLS-1$
    public static final String LOG_CLS = &amp;quot;android.util.Log&amp;quot;;     //$NON-NLS-1$
    private static final String PRINTLN = &amp;quot;println&amp;quot;;              //$NON-NLS-1$

    // ---- Implements Detector.JavaScanner ----

    @Override
    public List&amp;lt;String&amp;gt; getApplicableMethodNames() {
        return Arrays.asList(
                &amp;quot;d&amp;quot;,           //$NON-NLS-1$
                &amp;quot;e&amp;quot;,           //$NON-NLS-1$
                &amp;quot;i&amp;quot;,           //$NON-NLS-1$
                &amp;quot;v&amp;quot;,           //$NON-NLS-1$
                &amp;quot;w&amp;quot;,           //$NON-NLS-1$
                PRINTLN,
                IS_LOGGABLE);
    }

    @Override
    public void visitMethod(@NonNull JavaContext context, @Nullable JavaElementVisitor visitor,
            @NonNull PsiMethodCallExpression node, @NonNull PsiMethod method) {
        JavaEvaluator evaluator = context.getEvaluator();
        if (!evaluator.isMemberInClass(method, LOG_CLS)) {
            return;
        }

        String name = method.getName();
        boolean withinConditional = IS_LOGGABLE.equals(name) ||
                checkWithinConditional(context, node.getParent(), node);

        // See if it&#39;s surrounded by an if statement (and it&#39;s one of the non-error, spammy
        // log methods (info, verbose, etc))
        if ((&amp;quot;i&amp;quot;.equals(name) || &amp;quot;d&amp;quot;.equals(name) || &amp;quot;v&amp;quot;.equals(name) || PRINTLN.equals(name))
                &amp;amp;&amp;amp; !withinConditional
                &amp;amp;&amp;amp; performsWork(context, node)
                &amp;amp;&amp;amp; context.isEnabled(CONDITIONAL)) {
            String message = String.format(&amp;quot;The log call Log.%1$s(...) should be &amp;quot; +
                            &amp;quot;conditional: surround with `if (Log.isLoggable(...))` or &amp;quot; +
                            &amp;quot;`if (BuildConfig.DEBUG) { ... }`&amp;quot;,
                    node.getMethodExpression().getReferenceName());
            context.report(CONDITIONAL, node, context.getLocation(node), message);
        }

        // Check tag length
        if (context.isEnabled(LONG_TAG)) {
            int tagArgumentIndex = PRINTLN.equals(name) ? 1 : 0;
            PsiParameterList parameterList = method.getParameterList();
            PsiExpressionList argumentList = node.getArgumentList();
            if (evaluator.parameterHasType(method, tagArgumentIndex, TYPE_STRING)
                    &amp;amp;&amp;amp; parameterList.getParametersCount() == argumentList.getExpressions().length) {
                PsiExpression argument = argumentList.getExpressions()[tagArgumentIndex];
                String tag = ConstantEvaluator.evaluateString(context, argument, true);
                if (tag != null &amp;amp;&amp;amp; tag.length() &amp;gt; 23) {
                    String message = String.format(
                            &amp;quot;The logging tag can be at most 23 characters, was %1$d (%2$s)&amp;quot;,
                            tag.length(), tag);
                    context.report(LONG_TAG, node, context.getLocation(node), message);
                }
            }
        }
    }

    /** Returns true if the given logging call performs &amp;quot;work&amp;quot; to compute the message */
    private static boolean performsWork(
            @NonNull JavaContext context,
            @NonNull PsiMethodCallExpression node) {
        //...
    }

    private static boolean checkWithinConditional(
            @NonNull JavaContext context, @Nullable PsiElement curr, @NonNull PsiMethodCallExpression logCall) {
        //...
    }

    /** Checks that the tag passed to Log.s and Log.isLoggable match */
    private static void checkTagConsistent(JavaContext context, PsiMethodCallExpression logCall,
            PsiMethodCallExpression isLoggableCall) {
        //...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是一个简单的Java检查器的实现，但是足以让我们理解lint检查是如何进行的，以及辅助我们去了解其他的检查器的实现，甚至是针对其他类型的文件比如XML文件的检查器，它们的实现过程也大致类似。那如果我们的检查器既需要检查Java文件，又需要检查XML文件怎么办呢？其实也就是多实现一个接口就行了，很多自带的检查器都是实现了&lt;code&gt;XmlScanner&lt;/code&gt;和&lt;code&gt;JavaPsiScanner&lt;/code&gt;两个接口的。&lt;/p&gt;

&lt;p&gt;下一节我们会总结下lint工具中自带的一些和Android有关的检查器的功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lint Tool Analysis (2)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/18/lint-tool-analysis-2/</link>
      <pubDate>Fri, 18 Nov 2016 10:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/18/lint-tool-analysis-2/</guid>
      <description>

&lt;p&gt;Lint工具的源码分析(2)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本系列的几篇源码分析文档意义不大，如果你正好也在研究lint源码，或者你想知道前面自定义lint规则中提出的那几个问题，抑或你只是想大致了解下lint的源码都有些什么内容的话，这些文章可能有还些作用，否则看了和没看差不多的，因为这几篇文章只是我在读源码的过程中记录下来的一些零碎的片段，方便以后看的时候能够迅速上手。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;继续上一篇的解析，本篇我们来详细分析下&lt;code&gt;client.api&lt;/code&gt;包中的重要类。&lt;/p&gt;

&lt;h3 id=&#34;2-client-api包中的重要类&#34;&gt;2. client.api包中的重要类&lt;/h3&gt;

&lt;p&gt;(1) &lt;code&gt;LintClient&lt;/code&gt;类是指调用lint检查的来源(客户端)，可能是在Android Studio中或者在gradle中，也可能是在终端通过命令行的形式来调用。&lt;code&gt;LintClient&lt;/code&gt;只是一个抽象类，主要实现类有&lt;code&gt;IntellijLintClient&lt;/code&gt;，顾名思义它是指在Intellij(Android Studio)中执行lint，它还有两个子类，分别是批量进行lint检查的&lt;code&gt;BatchLintClient&lt;/code&gt;和针对当前编辑器中单个文件执行lint检查的&lt;code&gt;EditorLintClient&lt;/code&gt;；另一个实现是&lt;code&gt;LintClientWrapper&lt;/code&gt;，这个类定义在&lt;code&gt;LintDriver&lt;/code&gt;中，它并没有具体去实现那些方法，而是采用代理模式的形式进行了一层封装，被封装的&lt;code&gt;LintClient&lt;/code&gt;可能是&lt;code&gt;IntellijLintClient&lt;/code&gt;或者&lt;code&gt;BatchLintClient&lt;/code&gt;或者&lt;code&gt;EditorLintClient&lt;/code&gt;等。&lt;br /&gt;
&lt;strong&gt;通俗来讲，LintClient是指去调用lint检查的来源(客户端)，它会提供执行lint检查的相关环境信息。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LintClient&lt;/code&gt;中定义了一个值为&lt;code&gt;com.android.tools.lint.bindir&lt;/code&gt;的常量，它是作为键值用来指向lint命令所在的目录，获取这个目录的方法是&lt;code&gt;getLintBinDir&lt;/code&gt;，它先会去系统属性中查找(用&lt;code&gt;java -jar xxx -Dcom.android.tools.lint.bindir=value&lt;/code&gt;的形式设置的)，如果没找到的话会再去系统环境变量中查找，有了这个路径的话可以利用相对路径从而方便去获取其他资源，参见其中的&lt;code&gt;getSdkHome&lt;/code&gt;和&lt;code&gt;findResource&lt;/code&gt;方法。当我们在终端输入&lt;code&gt;lint&lt;/code&gt;命令的时候，lint脚本会自动帮我们设置&lt;code&gt;com.android.tools.lint.bindir&lt;/code&gt;的值，这个我们后面分析lint脚本源码的时候可以看到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Information about the tool embedding the lint analyzer. IDEs and other tools
 * implementing lint support will extend this to integrate logging, displaying errors,
 * etc.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
public abstract class LintClient {
    private static final String PROP_BIN_DIR  = &amp;quot;com.android.tools.lint.bindir&amp;quot;;
    ...
    /**
     * Returns the File corresponding to the system property or the environment variable
     * for {@link #PROP_BIN_DIR}.
     * This property is typically set by the SDK/tools/lint[.bat] wrapper.
     * It denotes the path of the wrapper on disk.
     *
     * @return A new File corresponding to {@link LintClient#PROP_BIN_DIR} or null.
     */
    @Nullable
    private static File getLintBinDir() {
        // First check the Java properties (e.g. set using &amp;quot;java -jar ... -Dname=value&amp;quot;)
        String path = System.getProperty(PROP_BIN_DIR);
        if (path == null || path.isEmpty()) {
            // If not found, check environment variables.
            path = System.getenv(PROP_BIN_DIR);
        }
        if (path != null &amp;amp;&amp;amp; !path.isEmpty()) {
            File file = new File(path);
            if (file.exists()) {
                return file;
            }
        }
        return null;
    }
    ...
    /**
     * Returns the File pointing to the user&#39;s SDK install area. This is generally
     * the root directory containing the lint tool (but also platforms/ etc).
     *
     * @return a file pointing to the user&#39;s install area
     */
    @Nullable
    public File getSdkHome() {
        File binDir = getLintBinDir();
        if (binDir != null) {
            assert binDir.getName().equals(&amp;quot;tools&amp;quot;);

            File root = binDir.getParentFile();
            if (root != null &amp;amp;&amp;amp; root.isDirectory()) {
                return root;
            }
        }

        String home = System.getenv(&amp;quot;ANDROID_HOME&amp;quot;); //$NON-NLS-1$
        if (home != null) {
            return new File(home);
        }

        return null;
    }

    /**
     * Locates an SDK resource (relative to the SDK root directory).
     * &amp;lt;p&amp;gt;
     * TODO: Consider switching to a {@link URL} return type instead.
     *
     * @param relativePath A relative path (using {@link File#separator} to
     *            separate path components) to the given resource
     * @return a {@link File} pointing to the resource, or null if it does not
     *         exist
     */
    @Nullable
    public File findResource(@NonNull String relativePath) {
        File top = getSdkHome();
        if (top == null) {
            throw new IllegalArgumentException(&amp;quot;Lint must be invoked with the System property &amp;quot;
                   + PROP_BIN_DIR + &amp;quot; pointing to the ANDROID_SDK tools directory&amp;quot;);
        }

        File file = new File(top, relativePath);
        if (file.exists()) {
            return file;
        } else {
            return null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LintClient&lt;/code&gt;中定义了5个抽象方法，其中&lt;code&gt;repoort&lt;/code&gt;和&lt;code&gt;log&lt;/code&gt;方法分别用于在lint过程中向调用者(客户端)反馈发现的问题和打印日志信息，这两个方法经常在检查器&lt;code&gt;Detector&lt;/code&gt;中通过&lt;code&gt;Context&lt;/code&gt;类对象间接被调用。&lt;code&gt;getXmlParser&lt;/code&gt;和&lt;code&gt;getJavaParser&lt;/code&gt;方法分别用来返回解析XML文件和解析Java文件的处理类，&lt;code&gt;readFile&lt;/code&gt;方法则是用来读取指定的文件内容的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Report the given issue. This method will only be called if the configuration
 * provided by {@link #getConfiguration(Project,LintDriver)} has reported the corresponding
 * issue as enabled and has not filtered out the issue with its
 * {@link Configuration#ignore(Context,Issue,Location,String)} method.
 * &amp;lt;p&amp;gt;
 * @param context the context used by the detector when the issue was found
 * @param issue the issue that was found
 * @param severity the severity of the issue
 * @param location the location of the issue
 * @param message the associated user message
 * @param format the format of the description and location descriptions
 */
public abstract void report(
        @NonNull Context context,
        @NonNull Issue issue,
        @NonNull Severity severity,
        @NonNull Location location,
        @NonNull String message,
        @NonNull TextFormat format);

/**
 * Send an exception or error message to the log
 *
 * @param severity the severity of the warning
 * @param exception the exception, possibly null
 * @param format the error message using {@link String#format} syntax, possibly null
 *    (though in that case the exception should not be null)
 * @param args any arguments for the format string
 */
public abstract void log(
        @NonNull Severity severity,
        @Nullable Throwable exception,
        @Nullable String format,
        @Nullable Object... args);

/**
 * Returns a {@link XmlParser} to use to parse XML
 *
 * @return a new {@link XmlParser}, or null if this client does not support
 *         XML analysis
 */
@Nullable
public abstract XmlParser getXmlParser();

/**
 * Returns a {@link JavaParser} to use to parse Java
 *
 * @param project the project to parse, if known (this can be used to look up
 *                the class path for type attribution etc, and it can also be used
 *                to more efficiently process a set of files, for example to
 *                perform type attribution for multiple units in a single pass)
 * @return a new {@link JavaParser}, or null if this client does not
 *         support Java analysis
 */
@Nullable
public abstract JavaParser getJavaParser(@Nullable Project project);

/**
 * Reads the given text file and returns the content as a string
 *
 * @param file the file to read
 * @return the string to return, never null (will be empty if there is an
 *         I/O error)
 */
@NonNull
public abstract String readFile(@NonNull File file);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LintClient&lt;/code&gt;中还定义了很多内容，比如下面的&lt;code&gt;ClassPathInfo&lt;/code&gt;内部类，它用来封装一个Project的各个文件夹，例如源码文件夹，class文件夹，库文件集合等等，以及一个&lt;code&gt;getClassPath&lt;/code&gt;的方法去获取&lt;code&gt;ClassPathInfo&lt;/code&gt;数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Information about class paths (sources, class files and libraries)
 * usually associated with a project.
 */
protected static class ClassPathInfo {
    private final List&amp;lt;File&amp;gt; mClassFolders;
    private final List&amp;lt;File&amp;gt; mSourceFolders;
    private final List&amp;lt;File&amp;gt; mLibraries;
    private final List&amp;lt;File&amp;gt; mNonProvidedLibraries;
    private final List&amp;lt;File&amp;gt; mTestFolders;

    public ClassPathInfo(
            @NonNull List&amp;lt;File&amp;gt; sourceFolders,
            @NonNull List&amp;lt;File&amp;gt; classFolders,
            @NonNull List&amp;lt;File&amp;gt; libraries,
            @NonNull List&amp;lt;File&amp;gt; nonProvidedLibraries,
            @NonNull List&amp;lt;File&amp;gt; testFolders) {
        mSourceFolders = sourceFolders;
        mClassFolders = classFolders;
        mLibraries = libraries;
        mNonProvidedLibraries = nonProvidedLibraries;
        mTestFolders = testFolders;
    }

    @NonNull
    public List&amp;lt;File&amp;gt; getSourceFolders() {
        return mSourceFolders;
    }

    @NonNull
    public List&amp;lt;File&amp;gt; getClassFolders() {
        return mClassFolders;
    }

    @NonNull
    public List&amp;lt;File&amp;gt; getLibraries(boolean includeProvided) {
        return includeProvided ? mLibraries : mNonProvidedLibraries;
    }

    public List&amp;lt;File&amp;gt; getTestSourceFolders() {
        return mTestFolders;
    }
}

/**
 * Considers the given project as an Eclipse project and returns class path
 * information for the project - the source folder(s), the output folder and
 * any libraries.
 * &amp;lt;p&amp;gt;
 * Callers will not cache calls to this method, so if it&#39;s expensive to compute
 * the classpath info, this method should perform its own caching.
 *
 * @param project the project to look up class path info for
 * @return a class path info object, never null
 */
@NonNull
protected ClassPathInfo getClassPath(@NonNull Project project) {
    ClassPathInfo info;
    if (mProjectInfo == null) {
        mProjectInfo = Maps.newHashMap();
        info = null;
    } else {
        info = mProjectInfo.get(project);
    }

    if (info == null) {
        List&amp;lt;File&amp;gt; sources = new ArrayList&amp;lt;File&amp;gt;(2);
        List&amp;lt;File&amp;gt; classes = new ArrayList&amp;lt;File&amp;gt;(1);
        List&amp;lt;File&amp;gt; libraries = new ArrayList&amp;lt;File&amp;gt;();
        // No test folders in Eclipse:
        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=224708
        List&amp;lt;File&amp;gt; tests = Collections.emptyList();

        //将project视为eclipse的project，那么项目根目录下有个.classpath文件，解析这个文件来获取classpath信息
        File projectDir = project.getDir();
        File classpathFile = new File(projectDir, &amp;quot;.classpath&amp;quot;); //$NON-NLS-1$
        if (classpathFile.exists()) {
            String classpathXml = readFile(classpathFile);
            try {
                Document document = XmlUtils.parseDocument(classpathXml, false);
                NodeList tags = document.getElementsByTagName(&amp;quot;classpathentry&amp;quot;); //$NON-NLS-1$
                for (int i = 0, n = tags.getLength(); i &amp;lt; n; i++) {
                    Element element = (Element) tags.item(i);
                    String kind = element.getAttribute(&amp;quot;kind&amp;quot;); //$NON-NLS-1$
                    List&amp;lt;File&amp;gt; addTo = null;
                    if (kind.equals(&amp;quot;src&amp;quot;)) {            //$NON-NLS-1$
                        addTo = sources;
                    } else if (kind.equals(&amp;quot;output&amp;quot;)) {  //$NON-NLS-1$
                        addTo = classes;
                    } else if (kind.equals(&amp;quot;lib&amp;quot;)) {     //$NON-NLS-1$
                        addTo = libraries;
                    }
                    if (addTo != null) {
                        String path = element.getAttribute(&amp;quot;path&amp;quot;); //$NON-NLS-1$
                        File folder = new File(projectDir, path);
                        if (folder.exists()) {
                            addTo.add(folder);
                        }
                    }
                }
            } catch (Exception e) {
                log(null, null);
            }
        }

        // Add in libraries that aren&#39;t specified in the .classpath file
        File libs = new File(project.getDir(), LIBS_FOLDER);//添加 libs 目录下的jar文件
        if (libs.isDirectory()) {
            File[] jars = libs.listFiles();
            if (jars != null) {
                for (File jar : jars) {
                    if (endsWith(jar.getPath(), DOT_JAR)
                            &amp;amp;&amp;amp; !libraries.contains(jar)) {
                        libraries.add(jar);
                    }
                }
            }
        }

        if (classes.isEmpty()) {
            File folder = new File(projectDir, CLASS_FOLDER);//添加 bin/classes 文件夹
            if (folder.exists()) {
                classes.add(folder);
            } else {//检查是否是maven项目，如果是的话编译得到的class文件是在 target/classes 目录下
                // Maven checks
                folder = new File(projectDir,
                        &amp;quot;target&amp;quot; + File.separator + &amp;quot;classes&amp;quot;); //$NON-NLS-1$ //$NON-NLS-2$
                if (folder.exists()) {
                    classes.add(folder);

                    // If it&#39;s maven, also correct the source path, &amp;quot;src&amp;quot; works but
                    // it&#39;s in a more specific subfolder
                    if (sources.isEmpty()) {//如果真的是maven项目的话，那么src/main/java目录是一个源码目录
                        File src = new File(projectDir,
                                &amp;quot;src&amp;quot; + File.separator     //$NON-NLS-1$
                                + &amp;quot;main&amp;quot; + File.separator  //$NON-NLS-1$
                                + &amp;quot;java&amp;quot;);                 //$NON-NLS-1$
                        if (src.exists()) {
                            sources.add(src);
                        } else {
                            src = new File(projectDir, SRC_FOLDER);
                            if (src.exists()) {
                                sources.add(src);
                            }
                        }

                        //有些class文件是自动生成的，存放在 target/generated-sources/r 目录下
                        File gen = new File(projectDir,
                                &amp;quot;target&amp;quot; + File.separator                  //$NON-NLS-1$
                                + &amp;quot;generated-sources&amp;quot; + File.separator     //$NON-NLS-1$
                                + &amp;quot;r&amp;quot;);                                    //$NON-NLS-1$
                        if (gen.exists()) {
                            sources.add(gen);
                        }
                    }
                }
            }
        }

        // Fallback, in case there is no Eclipse project metadata here
        if (sources.isEmpty()) {
            File src = new File(projectDir, SRC_FOLDER);
            if (src.exists()) {
                sources.add(src);
            }
            File gen = new File(projectDir, GEN_FOLDER);
            if (gen.exists()) {
                sources.add(gen);
            }
        }

        info = new ClassPathInfo(sources, classes, libraries, libraries, tests);
        mProjectInfo.put(project, info);
    }

    return info;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了&lt;code&gt;ClassPathInfo&lt;/code&gt;之外，还有很多其他的数据也会在&lt;code&gt;LintClient&lt;/code&gt;中处理，例如本机的Android SDK的信息以及项目中使用的&lt;code&gt;buildtool&lt;/code&gt;、&lt;code&gt;compileSdk&lt;/code&gt;等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected AndroidSdkHandler mSdk;//获取本机的 Android SDK 的相关信息

/**
 * Returns the SDK installation (used to look up platforms etc)
 *
 * @return the SDK if known
 */
@Nullable
public AndroidSdkHandler getSdk() {
    if (mSdk == null) {
        File sdkHome = getSdkHome();
        if (sdkHome != null) {
            mSdk = AndroidSdkHandler.getInstance(sdkHome);
        }
    }

    return mSdk;
}

protected IAndroidTarget[] mTargets;//获取 Android SDK 中已有的 Platform targets

/**
 * Returns all the {@link IAndroidTarget} versions installed in the user&#39;s SDK install
 * area.
 *
 * @return all the installed targets
 */
@NonNull
public IAndroidTarget[] getTargets() {//获取 Android SDK 中已有的 Platform targets
    if (mTargets == null) {
        AndroidSdkHandler sdkHandler = getSdk();
        if (sdkHandler != null) {
            ProgressIndicator logger = getRepositoryLogger();
            Collection&amp;lt;IAndroidTarget&amp;gt; targets = sdkHandler.getAndroidTargetManager(logger)
                    .getTargets(logger);
            mTargets = targets.toArray(new IAndroidTarget[targets.size()]);
        } else {
            mTargets = new IAndroidTarget[0];
        }
    }

    return mTargets;
}

/**
 * Returns the compile target to use for the given project
 *
 * @param project the project in question
 *
 * @return the compile target to use to build the given project
 */
@Nullable
public IAndroidTarget getCompileTarget(@NonNull Project project) {//获取项目中使用的 compileSdkVersion
    int buildSdk = project.getBuildSdk();
    IAndroidTarget[] targets = getTargets();
    for (int i = targets.length - 1; i &amp;gt;= 0; i--) {
        IAndroidTarget target = targets[i];
        if (target.isPlatform() &amp;amp;&amp;amp; target.getVersion().getApiLevel() == buildSdk) {
            return target;
        }
    }

    return null;
}
/**
 * Returns the specific version of the build tools being used for the given project, if known
 *
 * @param project the project in question
 *
 * @return the build tools version in use by the project, or null if not known
 */
@Nullable
public BuildToolInfo getBuildTools(@NonNull Project project) {//获取 build tools 的信息
    AndroidSdkHandler sdk = getSdk();
    // Build systems like Eclipse and ant just use the latest available
    // build tools, regardless of project metadata. In Gradle, this
    // method is overridden to use the actual build tools specified in the
    // project.
    if (sdk != null) {
        IAndroidTarget compileTarget = getCompileTarget(project);
        if (compileTarget != null) {
            return compileTarget.getBuildToolInfo();
        }
        return sdk.getLatestBuildTool(getRepositoryLogger(), false);
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最有意思的是，&lt;strong&gt;lint规则的查找过程也是在&lt;code&gt;LintClient&lt;/code&gt;中定义的&lt;/strong&gt;，下面的代码片段中包含两个重要的查找自定义lint规则的方法。从下面的代码片段中我们终于可以知道为什么放在&lt;code&gt;~/.android/lint&lt;/code&gt;目录下的自定义lint规则的jar包能够被识别，指定&lt;code&gt;ANDROID_LINT_JARS&lt;/code&gt;环境变量也能够识别，或者将&lt;code&gt;lint.jar&lt;/code&gt;放在aar中也能够被识别！&lt;br /&gt;
- &lt;strong&gt;&lt;code&gt;findGlobalRuleJars&lt;/code&gt;方法会在&lt;code&gt;~/.android/lint/&lt;/code&gt;目录下找jar包，或者由&lt;code&gt;$ANDROID_LINT_JARS&lt;/code&gt;环境变量指定的jar包，这些自定义的lint规则都是作用于全局的，也就是对于本机的所有Android工程都生效。&lt;/strong&gt;&lt;br /&gt;
- &lt;strong&gt;&lt;code&gt;findRuleJars&lt;/code&gt;方法是针对指定的project去查找自定义的lint规则，从源码来看，针对project自定义lint规则时只适用于基于Gradle的项目，包括普通的项目和库项目(library project)。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Finds any custom lint rule jars that should be included for analysis,
 * regardless of project.
 * &amp;lt;p&amp;gt;
 * The default implementation locates custom lint jars in ~/.android/lint/ and
 * in $ANDROID_LINT_JARS
 *
 * @return a list of rule jars (possibly empty).
 */
@SuppressWarnings(&amp;quot;MethodMayBeStatic&amp;quot;) // Intentionally instance method so it can be overridden
@NonNull
public List&amp;lt;File&amp;gt; findGlobalRuleJars() {
    // Look for additional detectors registered by the user, via
    // (1) an environment variable (useful for build servers etc), and
    // (2) via jar files in the .android/lint directory
    List&amp;lt;File&amp;gt; files = null;
    try {
        String androidHome = AndroidLocation.getFolder();//在 .android/lint 目录下找
        File lint = new File(androidHome + File.separator + &amp;quot;lint&amp;quot;); //$NON-NLS-1$
        if (lint.exists()) {
            File[] list = lint.listFiles();
            if (list != null) {
                for (File jarFile : list) {
                    if (endsWith(jarFile.getName(), DOT_JAR)) {
                        if (files == null) {
                            files = new ArrayList&amp;lt;File&amp;gt;();
                        }
                        files.add(jarFile);
                    }
                }
            }
        }
    } catch (AndroidLocation.AndroidLocationException e) {
        // Ignore -- no android dir, so no rules to load.
    }

    //在环境变量 ANDROID_LINT_JARS 目录下找
    String lintClassPath = System.getenv(&amp;quot;ANDROID_LINT_JARS&amp;quot;); //$NON-NLS-1$
    if (lintClassPath != null &amp;amp;&amp;amp; !lintClassPath.isEmpty()) {
        String[] paths = lintClassPath.split(File.pathSeparator);
        for (String path : paths) {
            File jarFile = new File(path);
            if (jarFile.exists()) {
                if (files == null) {
                    files = new ArrayList&amp;lt;File&amp;gt;();
                } else if (files.contains(jarFile)) {
                    continue;
                }
                files.add(jarFile);
            }
        }
    }

    return files != null ? files : Collections.&amp;lt;File&amp;gt;emptyList();
}

/**
 * Finds any custom lint rule jars that should be included for analysis
 * in the given project
 *
 * @param project the project to look up rule jars from
 * @return a list of rule jars (possibly empty).
 */
@SuppressWarnings(&amp;quot;MethodMayBeStatic&amp;quot;) // Intentionally instance method so it can be overridden
@NonNull
public List&amp;lt;File&amp;gt; findRuleJars(@NonNull Project project) {
    if (project.isGradleProject()) {
        if (project.isLibrary()) {//如果是gradle library项目，查找其中的 lint.jar 文件
            AndroidLibrary model = project.getGradleLibraryModel();
            if (model != null) {
                File lintJar = model.getLintJar();
                if (lintJar.exists()) {
                    return Collections.singletonList(lintJar);
                }
            }
        } else if (project.getSubset() != null) {
          //如果该项目有很多个子项目，那就检查当前variant下的依赖中的library project中是否包含了lint.jar
            // Probably just analyzing a single file: we still want to look for custom
            // rules applicable to the file
            List&amp;lt;File&amp;gt; rules = null;
            final Variant variant = project.getCurrentVariant();
            if (variant != null) {
                Collection&amp;lt;AndroidLibrary&amp;gt; libraries = variant.getMainArtifact()
                    .getDependencies().getLibraries();
                for (AndroidLibrary library : libraries) {
                    File lintJar = library.getLintJar();
                    if (lintJar.exists()) {
                        if (rules == null) {
                            rules = Lists.newArrayListWithExpectedSize(4);
                        }
                        rules.add(lintJar);
                    }
                }
                if (rules != null) {
                    return rules;
                }
            }
        } else if (project.getDir().getPath().endsWith(DOT_AAR)) {
            //这种情况是project就是一个aar，查找其中的lint.jar文件
            File lintJar = new File(project.getDir(), &amp;quot;lint.jar&amp;quot;); //$NON-NLS-1$
            if (lintJar.exists()) {
                return Collections.singletonList(lintJar);
            }
        }
    }

    return Collections.emptyList();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;code&gt;IssueRegistry&lt;/code&gt;类用来管理需要检查的问题列表，其中还定义了三个特殊的问题：&lt;code&gt;PARSER_ERROR&lt;/code&gt;表示lint解析文件时出错了；&lt;code&gt;LINT_ERROR&lt;/code&gt;表示lint检查过程中出现错误，但不是用户代码的错误；&lt;code&gt;CANCELLED&lt;/code&gt;表示用户取消了lint检查。除此之外，该类中还有一个重要方法&lt;code&gt;createDetectors&lt;/code&gt;，用来根据指定的Configuration和Scope来创建检查器列表。&lt;br /&gt;
&lt;strong&gt;通俗来讲，IssueRegistry就是lint要检查的问题集合。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Registry which provides a list of checks to be performed on an Android project
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public abstract class IssueRegistry {
    private static volatile List&amp;lt;Category&amp;gt; sCategories;//问题的类别列表
    private static volatile Map&amp;lt;String, Issue&amp;gt; sIdToIssue;//问题及其对应的issue
    private static Map&amp;lt;EnumSet&amp;lt;Scope&amp;gt;, List&amp;lt;Issue&amp;gt;&amp;gt; sScopeIssues = Maps.newHashMap();//某个特定的scope内的问题列表

    /**
     * Issue reported by lint (not a specific detector) when it cannot even
     * parse an XML file prior to analysis
     */
    @NonNull
    public static final Issue PARSER_ERROR = Issue.create(
            &amp;quot;ParserError&amp;quot;, //$NON-NLS-1$
            &amp;quot;Parser Errors&amp;quot;,
            &amp;quot;Lint will ignore any files that contain fatal parsing errors. These may contain &amp;quot; +
            &amp;quot;other errors, or contain code which affects issues in other files.&amp;quot;,
            Category.CORRECTNESS,
            10,
            Severity.ERROR,
            DUMMY_IMPLEMENTATION);

    /**
     * Issue reported by lint for various other issues which prevents lint from
     * running normally when it&#39;s not necessarily an error in the user&#39;s code base.
     */
    @NonNull
    public static final Issue LINT_ERROR = Issue.create(
        &amp;quot;LintError&amp;quot;, //$NON-NLS-1$
        &amp;quot;Lint Failure&amp;quot;,
        &amp;quot;This issue type represents a problem running lint itself. Examples include &amp;quot; +
        &amp;quot;failure to find bytecode for source files (which means certain detectors &amp;quot; +
        &amp;quot;could not be run), parsing errors in lint configuration files, etc.&amp;quot; +
        &amp;quot;\n&amp;quot; +
        &amp;quot;These errors are not errors in your own code, but they are shown to make &amp;quot; +
        &amp;quot;it clear that some checks were not completed.&amp;quot;,
        Category.LINT,
        10,
        Severity.ERROR,
        DUMMY_IMPLEMENTATION);

    /**
     * Creates a list of detectors applicable to the given scope, and with the
     * given configuration.
     *
     * @param client the client to report errors to
     * @param configuration the configuration to look up which issues are
     *            enabled etc from
     * @param scope the scope for the analysis, to filter out detectors that
     *            require wider analysis than is currently being performed
     * @param scopeToDetectors an optional map which (if not null) will be
     *            filled by this method to contain mappings from each scope to
     *            the applicable detectors for that scope
     * @return a list of new detector instances
     */
    @NonNull
    final List&amp;lt;? extends Detector&amp;gt; createDetectors(
            @NonNull LintClient client,
            @NonNull Configuration configuration,
            @NonNull EnumSet&amp;lt;Scope&amp;gt; scope,
            @Nullable Map&amp;lt;Scope, List&amp;lt;Detector&amp;gt;&amp;gt; scopeToDetectors) {

        List&amp;lt;Issue&amp;gt; issues = getIssuesForScope(scope);//获取该scope内的问题列表
        if (issues.isEmpty()) {
            return Collections.emptyList();
        }

        //检查器列表detectorClasses和检查器到范围的映射关系detectorToScope
        Set&amp;lt;Class&amp;lt;? extends Detector&amp;gt;&amp;gt; detectorClasses = new HashSet&amp;lt;Class&amp;lt;? extends Detector&amp;gt;&amp;gt;();
        Map&amp;lt;Class&amp;lt;? extends Detector&amp;gt;, EnumSet&amp;lt;Scope&amp;gt;&amp;gt; detectorToScope =
                new HashMap&amp;lt;Class&amp;lt;? extends Detector&amp;gt;, EnumSet&amp;lt;Scope&amp;gt;&amp;gt;();

        for (Issue issue : issues) {//遍历问题列表，取出它们的Detector以及scope集合
            Implementation implementation = issue.getImplementation();
            Class&amp;lt;? extends Detector&amp;gt; detectorClass = implementation.getDetectorClass();
            EnumSet&amp;lt;Scope&amp;gt; issueScope = implementation.getScope();
            if (!detectorClasses.contains(detectorClass)) {
                // Determine if the issue is enabled
                if (!configuration.isEnabled(issue)) {//看configuration中是否开启了这个问题
                    continue;
                }

                assert implementation.isAdequate(scope); // Ensured by getIssuesForScope above
                detectorClass = client.replaceDetector(detectorClass);
                assert detectorClass != null : issue.getId();
                detectorClasses.add(detectorClass);
            }

            if (scopeToDetectors != null) {
                EnumSet&amp;lt;Scope&amp;gt; s = detectorToScope.get(detectorClass);
                if (s == null) {
                    detectorToScope.put(detectorClass, issueScope);
                } else if (!s.containsAll(issueScope)) {
                    EnumSet&amp;lt;Scope&amp;gt; union = EnumSet.copyOf(s);
                    union.addAll(issueScope);
                    detectorToScope.put(detectorClass, union);
                }
            }
        }

        //将detectorToScope转换成scopeToDetectors
        List&amp;lt;Detector&amp;gt; detectors = new ArrayList&amp;lt;Detector&amp;gt;(detectorClasses.size());
        for (Class&amp;lt;? extends Detector&amp;gt; clz : detectorClasses) {
            try {
                Detector detector = clz.newInstance();
                detectors.add(detector);

                if (scopeToDetectors != null) {
                    EnumSet&amp;lt;Scope&amp;gt; union = detectorToScope.get(clz);
                    for (Scope s : union) {
                        List&amp;lt;Detector&amp;gt; list = scopeToDetectors.get(s);
                        if (list == null) {
                            list = new ArrayList&amp;lt;Detector&amp;gt;();
                            scopeToDetectors.put(s, list);
                        }
                        list.add(detector);
                    }

                }
            } catch (Throwable t) {
                client.log(t, &amp;quot;Can&#39;t initialize detector %1$s&amp;quot;, clz.getName()); //$NON-NLS-1$
            }
        }

        return detectors;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IssueRegistry&lt;/code&gt;类是一个抽象类，它只有一个抽象方法&lt;code&gt;getIssues&lt;/code&gt;，返回需要检查的问题集合就行，所以特别容易实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract List&amp;lt;Issue&amp;gt; getIssues();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IssueRegistry&lt;/code&gt;类有几个特别重要的实现子类，例如&lt;code&gt;BuiltinIssueRegistry&lt;/code&gt;是系统内置的lint检查器集合，目前共有263个issue；&lt;code&gt;CompositeIssueRegistry&lt;/code&gt;是一个将很多&lt;code&gt;IssueRegistry&lt;/code&gt;中的issue整合到一起的IssueRegistry；还有一个很重要的用于加载jar文件中的&lt;code&gt;IssueRegistry&lt;/code&gt;的类&lt;code&gt;JarFileIssueRegistry&lt;/code&gt;，前面我们自定义的lint规则的jar包就是由它来解析并加载的。&lt;br /&gt;
&lt;strong&gt;在自定义lint规则生成jar包时我们提到过要在&lt;code&gt;build.gradle&lt;/code&gt;文件中给jar文件添加&lt;code&gt;Lint-Registry&lt;/code&gt;的属性值，因为这里会进行检查，如果没有配置的话就不算是合法的lint包。此外，这个类使用了缓存机制来保存已经加载过的jar文件，所以也就导致了我们在自定义lint中出现的更改jar包但是Android Studio并没有更新lint规则的bug！&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * &amp;lt;p&amp;gt; An {@link IssueRegistry} for a custom lint rule jar file. The rule jar should provide a
 * manifest entry with the key {@code Lint-Registry} and the value of the fully qualified name of an
 * implementation of {@link IssueRegistry} (with a default constructor). &amp;lt;/p&amp;gt;
 *
 * &amp;lt;p&amp;gt; NOTE: The custom issue registry should not extend this file; it should be a plain
 * IssueRegistry! This file is used internally to wrap the given issue registry.&amp;lt;/p&amp;gt;
 */
class JarFileIssueRegistry extends IssueRegistry {
    /**
     * Manifest constant for declaring an issue provider. Example: Lint-Registry:
     * foo.bar.CustomIssueRegistry
     */
    private static final String MF_LINT_REGISTRY_OLD = &amp;quot;Lint-Registry&amp;quot;; //$NON-NLS-1$
    private static final String MF_LINT_REGISTRY = &amp;quot;Lint-Registry-v2&amp;quot;; //$NON-NLS-1$

    private static Map&amp;lt;File, SoftReference&amp;lt;JarFileIssueRegistry&amp;gt;&amp;gt; sCache;
    private final List&amp;lt;Issue&amp;gt; myIssues;
    private boolean mHasLegacyDetectors;

    /** True if one or more java detectors were found that use the old Lombok-based API */
    public boolean hasLegacyDetectors() {
        return mHasLegacyDetectors;
    }

    @NonNull
    static JarFileIssueRegistry get(@NonNull LintClient client, @NonNull File jarFile)
            throws IOException, ClassNotFoundException, IllegalAccessException,
            InstantiationException {
        if (sCache == null) {
           sCache = new HashMap&amp;lt;File, SoftReference&amp;lt;JarFileIssueRegistry&amp;gt;&amp;gt;();
        } else {
            SoftReference&amp;lt;JarFileIssueRegistry&amp;gt; reference = sCache.get(jarFile);
            if (reference != null) {
                JarFileIssueRegistry registry = reference.get();
                if (registry != null) {
                    return registry;
                }
            }
        }

        // Ensure that the scope-to-detector map doesn&#39;t return stale results
        IssueRegistry.reset();

        JarFileIssueRegistry registry = new JarFileIssueRegistry(client, jarFile);
        sCache.put(jarFile, new SoftReference&amp;lt;JarFileIssueRegistry&amp;gt;(registry));
        return registry;
    }

    private JarFileIssueRegistry(@NonNull LintClient client, @NonNull File file)
            throws IOException, ClassNotFoundException, IllegalAccessException,
                    InstantiationException {
        myIssues = Lists.newArrayList();
        JarFile jarFile = null;
        try {
            //noinspection IOResourceOpenedButNotSafelyClosed
            jarFile = new JarFile(file);
            Manifest manifest = jarFile.getManifest();
            Attributes attrs = manifest.getMainAttributes();
            Object object = attrs.get(new Attributes.Name(MF_LINT_REGISTRY));
            boolean isLegacy = false;
            //检查jar包的MANIFEST.MF文件中是否配置了Lint-Registry-v2或者Lint-Registry属性值
            if (object == null) {
                object = attrs.get(new Attributes.Name(MF_LINT_REGISTRY_OLD));
                //noinspection VariableNotUsedInsideIf
                if (object != null) {
                    // It&#39;s an old rule. We don&#39;t yet conclude that
                    //   mHasLegacyDetectors=true
                    // because the lint checks may not be Java related.
                    isLegacy = true;
                }
            }
            //如果配置了的话，对应的值就是继承自IssueRegistry的类，我们需要去加载它
            if (object instanceof String) {
                String className = (String) object;
                // Make a class loader for this jar
                URL url = SdkUtils.fileToUrl(file);
                ClassLoader loader = client.createUrlClassLoader(new URL[]{url},
                        JarFileIssueRegistry.class.getClassLoader());
                Class&amp;lt;?&amp;gt; registryClass = Class.forName(className, true, loader);
                IssueRegistry registry = (IssueRegistry) registryClass.newInstance();
                myIssues.addAll(registry.getIssues());

                if (isLegacy) {
                    // If it&#39;s an old registry, look through the issues to see if it
                    // provides Java scanning and if so create the old style visitors
                    for (Issue issue : myIssues) {
                        EnumSet&amp;lt;Scope&amp;gt; scope = issue.getImplementation().getScope();
                        if (scope.contains(Scope.JAVA_FILE) || scope.contains(Scope.JAVA_LIBRARIES)
                                || scope.contains(Scope.ALL_JAVA_FILES)) {
                            mHasLegacyDetectors = true;
                            break;
                        }
                    }
                }

                //利用这个ClassLoader去加载jar包中的class
                if (loader instanceof URLClassLoader) {
                    loadAndCloseURLClassLoader(client, file, (URLClassLoader)loader);
                }
            } else {
                client.log(Severity.ERROR, null,
                    &amp;quot;Custom lint rule jar %1$s does not contain a valid registry manifest key &amp;quot; +
                    &amp;quot;(%2$s).\n&amp;quot; +
                    &amp;quot;Either the custom jar is invalid, or it uses an outdated API not supported &amp;quot; +
                    &amp;quot;this lint client&amp;quot;, file.getPath(), MF_LINT_REGISTRY);
            }
        } finally {
            if (jarFile != null) {
                jarFile.close();
            }
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) &lt;code&gt;LintDriver&lt;/code&gt;类是一个核心类，其中汇集了对Android工程或文件进行Lint检查所需的主要元素，包含了上面的&lt;code&gt;LintClient&lt;/code&gt;和&lt;code&gt;IssueRegistry&lt;/code&gt;等重要类，还有表示一次lint检查的请求&lt;code&gt;LintClient&lt;/code&gt;以及监听lint检查过程的&lt;code&gt;LintListener&lt;/code&gt;集合等数据。&lt;br /&gt;
&lt;strong&gt;通俗来讲，LintDriver包含了一次lint检查时的所有信息，由它来进行lint检查的过程。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Analyzes Android projects and files
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public class LintDriver {
    /**
     * Max number of passes to run through the lint runner if requested by
     * {@link #requestRepeat}
     */
    private static final int MAX_PHASES = 3;
    private static final String SUPPRESS_LINT_VMSIG = &#39;/&#39; + SUPPRESS_LINT + &#39;;&#39;;
    /** Prefix used by the comment suppress mechanism in Studio/IntelliJ */
    private static final String STUDIO_ID_PREFIX = &amp;quot;AndroidLint&amp;quot;;

    private final LintClient mClient;//检查器调用端，可能是android studio或者gradle或者cli
    private LintRequest mRequest;
    private IssueRegistry mRegistry;//问题注册中心
    private volatile boolean mCanceled;
    private EnumSet&amp;lt;Scope&amp;gt; mScope;
    private List&amp;lt;? extends Detector&amp;gt; mApplicableDetectors;
    private Map&amp;lt;Scope, List&amp;lt;Detector&amp;gt;&amp;gt; mScopeDetectors;
    private List&amp;lt;LintListener&amp;gt; mListeners;
    private int mPhase;
    private List&amp;lt;Detector&amp;gt; mRepeatingDetectors;
    private EnumSet&amp;lt;Scope&amp;gt; mRepeatScope;
    private Project[] mCurrentProjects;
    private Project mCurrentProject;
    private boolean mAbbreviating = true;
    private boolean mParserErrors;
    private Map&amp;lt;Object,Object&amp;gt; mProperties;
    /** Whether we need to look for legacy (old Lombok-based Java API) detectors */
    private boolean mRunCompatChecks = true;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面我们在&lt;code&gt;LintClient&lt;/code&gt;中看到了lint工具是如何查找自定义的lint规则，但是并没有看到这些规则是如何注册到&lt;code&gt;IssueRegistry&lt;/code&gt;上去的，而这个艰巨的任务实际上是在&lt;code&gt;LintDriver&lt;/code&gt;中完成的，主要流程都在方法&lt;code&gt;registerCustomDetectors&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Set&amp;lt;Issue&amp;gt; myCustomIssues;//自定义的lint规则集合

/**
* Returns true if the given issue is an issue that was loaded as a custom rule
* (e.g. a 3rd-party library provided the detector, it&#39;s not built in)
*
* @param issue the issue to be looked up
* @return true if this is a custom (non-builtin) check
*/
public boolean isCustomIssue(@NonNull Issue issue) {//判断某个issue是否是自定义的issue
   return myCustomIssues != null &amp;amp;&amp;amp; myCustomIssues.contains(issue);
}

//注册自定义的检查器，检查器来源于参数中指定的projects中
private void registerCustomDetectors(Collection&amp;lt;Project&amp;gt; projects) {
   // Look at the various projects, and if any of them provide a custom
   // lint jar, &amp;quot;add&amp;quot; them (this will replace the issue registry with
   // a CompositeIssueRegistry containing the original issue registry
   // plus JarFileIssueRegistry instances for each lint jar
   Set&amp;lt;File&amp;gt; jarFiles = Sets.newHashSet();
   for (Project project : projects) {//遍历所有的project以及它们的library project，找出其中所有的lint.jar文件
       jarFiles.addAll(mClient.findRuleJars(project));
       for (Project library : project.getAllLibraries()) {
           jarFiles.addAll(mClient.findRuleJars(library));
       }
   }

   jarFiles.addAll(mClient.findGlobalRuleJars());//查找全局的自定义的lint规则的jar包

   if (!jarFiles.isEmpty()) {
       List&amp;lt;IssueRegistry&amp;gt; registries = Lists.newArrayListWithExpectedSize(jarFiles.size());
       registries.add(mRegistry);
       for (File jarFile : jarFiles) {
           try {
               JarFileIssueRegistry registry = JarFileIssueRegistry.get(mClient, jarFile);
               if (registry.hasLegacyDetectors()) {
                   mRunCompatChecks = true;
               }
               if (myCustomIssues == null) {
                   myCustomIssues = Sets.newHashSet();
               }
               myCustomIssues.addAll(registry.getIssues());
               registries.add(registry);
           } catch (Throwable e) {
               mClient.log(e, &amp;quot;Could not load custom rule jar file %1$s&amp;quot;, jarFile);
           }
       }
       if (registries.size() &amp;gt; 1) { // the first item is mRegistry itself
           mRegistry = new CompositeIssueRegistry(registries);
       }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LintDriver&lt;/code&gt;还有一个重要的方法就是&lt;code&gt;analyze&lt;/code&gt;，lint检查就是从这里正式开始的。其中的&lt;code&gt;mRequest&lt;/code&gt;是&lt;code&gt;LintRequest&lt;/code&gt;对象，类似HTTPRequest一样，表示一次lint检查的请求，它包含了这次lint检查的一些基本信息。其中还调用了&lt;code&gt;registerCustomDetectors&lt;/code&gt;方法，这个方法就是用来注册那些自定义的lint规则的。此外，其中会遍历所有的project，然后调用&lt;code&gt;runExtraPhases&lt;/code&gt;方法就该project进行lint检查。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Runs the driver to analyze the requested files */
private void analyze() {
    mCanceled = false;
    mScope = mRequest.getScope();
    assert mScope == null || !mScope.contains(Scope.ALL_RESOURCE_FILES) ||
            mScope.contains(Scope.RESOURCE_FILE);

    Collection&amp;lt;Project&amp;gt; projects;
    try {
        projects = mRequest.getProjects();
        if (projects == null) {
            projects = computeProjects(mRequest.getFiles());
        }
    } catch (CircularDependencyException e) {
        mCurrentProject = e.getProject();
        if (mCurrentProject != null) {
            Location location = e.getLocation();
            File file = location != null ? location.getFile() : mCurrentProject.getDir();
            Context context = new Context(this, mCurrentProject, null, file);
            context.report(IssueRegistry.LINT_ERROR, e.getLocation(), e.getMessage());
            mCurrentProject = null;
        }
        return;
    }
    if (projects.isEmpty()) {
        mClient.log(null, &amp;quot;No projects found for %1$s&amp;quot;, mRequest.getFiles().toString());
        return;
    }
    if (mCanceled) {
        return;
    }
    registerCustomDetectors(projects);//注册自定义的lint检查器
    if (mScope == null) {//如果范围为空，那么就根据projects来推断范围
        mScope = Scope.infer(projects);
    }
    fireEvent(EventType.STARTING, null);//fireEvent用于触发相应的事件，通知LintListener
    for (Project project : projects) {
        mPhase = 1;
        Project main = mRequest.getMainProject(project);
        // The set of available detectors varies between projects
        computeDetectors(project);
        if (mApplicableDetectors.isEmpty()) {
            // No detectors enabled in this project: skip it
            continue;
        }
        checkProject(project, main);
        if (mCanceled) {
            break;
        }
        runExtraPhases(project, main);
    }
    fireEvent(mCanceled ? EventType.CANCELED : EventType.COMPLETED, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;runExtraPhases&lt;/code&gt;方法中会调用&lt;code&gt;checkProject&lt;/code&gt;方法去对指定的project进行lint检查，其中调用了另一个核心方法&lt;code&gt;runFileDetectors&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void checkProject(@NonNull Project project, @NonNull Project main) {
    File projectDir = project.getDir();

    Context projectContext = new Context(this, project, null, projectDir);
    fireEvent(EventType.SCANNING_PROJECT, projectContext);

    List&amp;lt;Project&amp;gt; allLibraries = project.getAllLibraries();
    Set&amp;lt;Project&amp;gt; allProjects = new HashSet&amp;lt;Project&amp;gt;(allLibraries.size() + 1);
    allProjects.add(project);
    allProjects.addAll(allLibraries);
    mCurrentProjects = allProjects.toArray(new Project[allProjects.size()]);

    mCurrentProject = project;
    for (Detector check : mApplicableDetectors) {
        check.beforeCheckProject(projectContext);
        if (mCanceled) {
            return;
        }
    }

    assert mCurrentProject == project;
    runFileDetectors(project, main);
    if (!Scope.checkSingleFile(mScope)) {
        List&amp;lt;Project&amp;gt; libraries = project.getAllLibraries();
        for (Project library : libraries) {
            Context libraryContext = new Context(this, library, project, projectDir);
            fireEvent(EventType.SCANNING_LIBRARY_PROJECT, libraryContext);
            mCurrentProject = library;

            for (Detector check : mApplicableDetectors) {
                check.beforeCheckLibraryProject(libraryContext);
                if (mCanceled) {
                    return;
                }
            }
            assert mCurrentProject == library;
            runFileDetectors(library, main);
            if (mCanceled) {
                return;
            }

            assert mCurrentProject == library;
            for (Detector check : mApplicableDetectors) {
                check.afterCheckLibraryProject(libraryContext);
                if (mCanceled) {
                    return;
                }
            }
        }
    }

    mCurrentProject = project;
    for (Detector check : mApplicableDetectors) {
        check.afterCheckProject(projectContext);
        if (mCanceled) {
            return;
        }
    }

    if (mCanceled) {
        mClient.report(
            projectContext,
            // Must provide an issue since API guarantees that the issue parameter
            IssueRegistry.CANCELLED,
            Severity.INFORMATIONAL,
            Location.create(project.getDir()),
            &amp;quot;Lint canceled by user&amp;quot;, TextFormat.RAW);
    }
    mCurrentProjects = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法&lt;code&gt;runFileDetectors&lt;/code&gt;的作用就是对文件进行lint检查，上一篇我们提到过lint检查的顺序，从下面的代码我们也可以看出检查的顺序依次是&lt;code&gt;Manifest文件 =&amp;gt; Resource文件 =&amp;gt; Java源码文件 =&amp;gt; Java Class文件 =&amp;gt; Gradle文件 =&amp;gt; Generic文件 =&amp;gt; Proguard文件 =&amp;gt; Property文件&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void runFileDetectors(@NonNull Project project, @Nullable Project main) {
    // Look up manifest information (but not for library projects)
    if (project.isAndroidProject()) {
      //如果是Android项目的话，使用XmlParser去读取Manifest.xml文件的信息
        for (File manifestFile : project.getManifestFiles()) {
            XmlParser parser = mClient.getXmlParser();
            if (parser != null) {
                XmlContext context = new XmlContext(this, project, main, manifestFile, null, parser);
                context.document = parser.parseXml(context);
                if (context.document != null) {
                    try {
                        project.readManifest(context.document);

                        //执行lint检查时会先获取Scope.MANIFEST下的所有detector
                        //然后创建ResourceVisitor去对文件进行lint检查
                        if ((!project.isLibrary() || (main != null
                                &amp;amp;&amp;amp; main.isMergingManifests()))
                                &amp;amp;&amp;amp; mScope.contains(Scope.MANIFEST)) {
                            List&amp;lt;Detector&amp;gt; detectors = mScopeDetectors.get(Scope.MANIFEST);
                            if (detectors != null) {
                                ResourceVisitor v = new ResourceVisitor(parser, detectors, null);
                                fireEvent(EventType.SCANNING_FILE, context);
                                v.visitFile(context, manifestFile);
                            }
                        }
                    } finally {
                      if (context.document != null) { // else: freed by XmlVisitor above
                          parser.dispose(context, context.document);
                      }
                    }
                }
            }
        }

        //检查资源文件
        // Process both Scope.RESOURCE_FILE and Scope.ALL_RESOURCE_FILES detectors together
        // in a single pass through the resource directories.
        if (mScope.contains(Scope.ALL_RESOURCE_FILES)
                || mScope.contains(Scope.RESOURCE_FILE)
                || mScope.contains(Scope.RESOURCE_FOLDER)
                || mScope.contains(Scope.BINARY_RESOURCE_FILE)) {
            List&amp;lt;Detector&amp;gt; dirChecks = mScopeDetectors.get(Scope.RESOURCE_FOLDER);
            List&amp;lt;Detector&amp;gt; binaryChecks = mScopeDetectors.get(Scope.BINARY_RESOURCE_FILE);
            List&amp;lt;Detector&amp;gt; checks = union(mScopeDetectors.get(Scope.RESOURCE_FILE),
                    mScopeDetectors.get(Scope.ALL_RESOURCE_FILES));
            boolean haveXmlChecks = checks != null &amp;amp;&amp;amp; !checks.isEmpty();
            List&amp;lt;ResourceXmlDetector&amp;gt; xmlDetectors;
            if (haveXmlChecks) {
                xmlDetectors = new ArrayList&amp;lt;ResourceXmlDetector&amp;gt;(checks.size());
                for (Detector detector : checks) {
                    if (detector instanceof ResourceXmlDetector) {
                        xmlDetectors.add((ResourceXmlDetector) detector);
                    }
                }
                haveXmlChecks = !xmlDetectors.isEmpty();
            } else {
                xmlDetectors = Collections.emptyList();
            }
            if (haveXmlChecks
                    || dirChecks != null &amp;amp;&amp;amp; !dirChecks.isEmpty()
                    || binaryChecks != null &amp;amp;&amp;amp; !binaryChecks.isEmpty()) {
                List&amp;lt;File&amp;gt; files = project.getSubset();
                if (files != null) {
                    checkIndividualResources(project, main, xmlDetectors, dirChecks,
                            binaryChecks, files);
                } else {
                    List&amp;lt;File&amp;gt; resourceFolders = project.getResourceFolders();
                    if (!resourceFolders.isEmpty()) {
                        for (File res : resourceFolders) {
                            checkResFolder(project, main, res, xmlDetectors, dirChecks,
                                    binaryChecks);
                        }
                    }
                }
            }
        }

        if (mCanceled) {
            return;
        }
    }

    //检查java文件
    if (mScope.contains(Scope.JAVA_FILE) || mScope.contains(Scope.ALL_JAVA_FILES)) {
        List&amp;lt;Detector&amp;gt; checks = union(mScopeDetectors.get(Scope.JAVA_FILE),
                mScopeDetectors.get(Scope.ALL_JAVA_FILES));
        if (checks != null &amp;amp;&amp;amp; !checks.isEmpty()) {
            List&amp;lt;File&amp;gt; files = project.getSubset();
            if (files != null) {
                checkIndividualJavaFiles(project, main, checks, files);
            } else {
                List&amp;lt;File&amp;gt; sourceFolders = project.getJavaSourceFolders();
                if (mScope.contains(Scope.TEST_SOURCES)) {
                    List&amp;lt;File&amp;gt; testFolders = project.getTestSourceFolders();
                    if (!testFolders.isEmpty()) {
                        List&amp;lt;File&amp;gt; combined = Lists.newArrayListWithExpectedSize(
                                sourceFolders.size() + testFolders.size());
                        combined.addAll(sourceFolders);
                        combined.addAll(testFolders);
                        sourceFolders = combined;
                    }
                }

                checkJava(project, main, sourceFolders, checks);

            }
        }
    }

    if (mCanceled) {
        return;
    }

    //检查class文件
    if (mScope.contains(Scope.CLASS_FILE)
            || mScope.contains(Scope.ALL_CLASS_FILES)
            || mScope.contains(Scope.JAVA_LIBRARIES)) {
        checkClasses(project, main);
    }

    if (mCanceled) {
        return;
    }

    //检查gradle文件
    if (mScope.contains(Scope.GRADLE_FILE)) {
        checkBuildScripts(project, main);
    }

    if (mCanceled) {
        return;
    }

    //检查其他的Generic文件
    if (mScope.contains(Scope.OTHER)) {
        List&amp;lt;Detector&amp;gt; checks = mScopeDetectors.get(Scope.OTHER);
        if (checks != null) {
            OtherFileVisitor visitor = new OtherFileVisitor(checks);
            visitor.scan(this, project, main);
        }
    }

    if (mCanceled) {
        return;
    }

    //检查proguard文件
    if (project == main &amp;amp;&amp;amp; mScope.contains(Scope.PROGUARD_FILE) &amp;amp;&amp;amp;
            project.isAndroidProject()) {
        checkProGuard(project, main);
    }

    //检查property文件
    if (project == main &amp;amp;&amp;amp; mScope.contains(Scope.PROPERTY_FILE)) {
        checkProperties(project, main);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们看下Java文件是如何进行lint检查的，我们在下一篇将会详细介绍这部分代码的实现细节。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void checkIndividualJavaFiles(//检查单个的Java文件
        @NonNull Project project,
        @Nullable Project main,
        @NonNull List&amp;lt;Detector&amp;gt; checks,
        @NonNull List&amp;lt;File&amp;gt; files) {

    JavaParser javaParser = mClient.getJavaParser(project);
    if (javaParser == null) {
        mClient.log(null, &amp;quot;No java parser provided to lint: not running Java checks&amp;quot;);
        return;
    }

    List&amp;lt;JavaContext&amp;gt; contexts = Lists.newArrayListWithExpectedSize(files.size());
    for (File file : files) {
        if (file.isFile() &amp;amp;&amp;amp; file.getPath().endsWith(DOT_JAVA)) {
            contexts.add(new JavaContext(this, project, main, file, javaParser));
        }
    }

    if (contexts.isEmpty()) {
        return;
    }

    visitJavaFiles(checks, javaParser, contexts);
}

//访问java文件，进行lint检查
private void visitJavaFiles(@NonNull List&amp;lt;Detector&amp;gt; checks, JavaParser javaParser,
        List&amp;lt;JavaContext&amp;gt; contexts) {
    // Temporary: we still have some builtin checks that aren&#39;t migrated to
    // PSI. Until that&#39;s complete, remove them from the list here
    //List&amp;lt;Detector&amp;gt; scanners = checks;
    //当前新版的Java检查器都是实现了JavaPsiScanner接口，由它可以创建JavaPsiVisitor
    List&amp;lt;Detector&amp;gt; scanners = Lists.newArrayListWithCapacity(checks.size());
    for (Detector detector : checks) {
        if (detector instanceof Detector.JavaPsiScanner) {
            scanners.add(detector);
        }
    }

    JavaPsiVisitor visitor = new JavaPsiVisitor(javaParser, scanners);
    visitor.prepare(contexts);
    for (JavaContext context : contexts) {
        fireEvent(EventType.SCANNING_FILE, context);
        visitor.visitFile(context);
        if (mCanceled) {
            return;
        }
    }

    visitor.dispose();

    //下面是为了兼容以前版本的Java检查器而做的检查，它会创建JavaScanner以及JavaVisitor去对文件进行检查
    // Only if the user is using some custom lint rules that haven&#39;t been updated
    // yet noinspection ConstantConditions
    if (mRunCompatChecks) {
        // Filter the checks to only those that implement JavaScanner
        List&amp;lt;Detector&amp;gt; filtered = Lists.newArrayListWithCapacity(checks.size());
        for (Detector detector : checks) {
            if (detector instanceof Detector.JavaScanner) {
                filtered.add(detector);
            }
        }

        if (!filtered.isEmpty()) {
            List&amp;lt;String&amp;gt; detectorNames = Lists.newArrayListWithCapacity(filtered.size());
            for (Detector detector : filtered) {
                detectorNames.add(detector.getClass().getName());
            }
            Collections.sort(detectorNames);
            JavaVisitor oldVisitor = new JavaVisitor(javaParser, filtered);

            oldVisitor.prepare(contexts);
            for (JavaContext context : contexts) {
                fireEvent(EventType.SCANNING_FILE, context);
                oldVisitor.visitFile(context);
                if (mCanceled) {
                    return;
                }
            }
            oldVisitor.dispose();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lint Tool Analysis (1)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/17/lint-tool-analysis-1/</link>
      <pubDate>Thu, 17 Nov 2016 10:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/17/lint-tool-analysis-1/</guid>
      <description>

&lt;p&gt;Lint工具的源码分析(1)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本系列的几篇源码分析文档意义不大，如果你正好也在研究lint源码，或者你想知道前面自定义lint规则中提出的那几个问题，抑或你只是想大致了解下lint的源码都有些什么内容的话，这些文章可能有还些作用，否则看了和没看差不多的，因为这几篇文章只是我在读源码的过程中记录下来的一些零碎的片段，方便以后看的时候能够迅速上手。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在前面的&lt;a href=&#34;https://hujiaweibujidao.github.io/blog/2016/11/10/custom-lint-in-action/&#34;&gt;Custom Lint in Action&lt;/a&gt;中我们了解到将自定义的lint规则打包成jar，然后放在&lt;code&gt;~/.android/lint/&lt;/code&gt;目录下的话，我们就能够应用这些规则对工程进行静态代码扫描了。但是，这是为什么呢？为什么是打包成jar？为什么是放在那个目录下？为什么放在那里就能够被识别且被应用了呢？要揭晓这些问题的答案，我们就必须要去阅读lint工具的源码一探究竟啦！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lint检查归根结底是对某些文件可能存在的某些问题利用静态扫描源文件的方式去检查看是否真的存在那些问题的过程。&lt;/strong&gt;&lt;br /&gt;
针对这个需求，我们需要控制哪些文件需要被检查(Scope)、哪些问题需要进行检查(IssueRegistry)、该问题应如何进行检查(Detector)以及源代码文件如何进行静态扫描(Scanner)等内容进行封装，其实lint工具的源码就是这么设计和封装的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lint&lt;/code&gt;工具源码主要分成两部分：&lt;code&gt;lint-api&lt;/code&gt;和&lt;code&gt;lint-checks&lt;/code&gt;，前者主要是lint的核心API，后者是利用API定义的检查器。其中&lt;code&gt;lint-api&lt;/code&gt;又分为&lt;code&gt;detector.api&lt;/code&gt;和&lt;code&gt;client.api&lt;/code&gt;这两个包，其中&lt;code&gt;detector.api&lt;/code&gt;这个包主要是和lint检查器相关的类，&lt;code&gt;client.api&lt;/code&gt;这个包主要是和调用lint检查有关的类。由于内容实在太多，故分成多篇分别来解析下，本篇主要解析的是&lt;code&gt;detector.api&lt;/code&gt;包中的重要类。&lt;/p&gt;

&lt;h3 id=&#34;1-detector-api包中的重要类&#34;&gt;1. detector.api包中的重要类&lt;/h3&gt;

&lt;p&gt;(1) &lt;code&gt;Scope&lt;/code&gt;枚举类表示lint检查时需要检查的文件范围，例如&lt;code&gt;RESOURCE_FILE，JAVA_FILE，CLASS_FILE，GRADLE_FILE&lt;/code&gt;等，各项含义与下面的代码片段类似。该类中的&lt;code&gt;infer&lt;/code&gt;方法是用来推断选定的项目有哪些文件范围需要检查(根据文件名判断)，&lt;code&gt;checkSingleFile&lt;/code&gt;方法是用来判断是检查单个文件还是检查整个项目所有的该类型文件。&lt;br /&gt;
&lt;strong&gt;通俗来讲，Scope指的就是哪个文件或者哪些文件需要被检查。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * The scope of a detector is the set of files a detector must consider when
 * performing its analysis. This can be used to determine when issues are
 * potentially obsolete, whether a detector should re-run on a file save, etc.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public enum Scope {
    /**
     * The analysis only considers a single XML resource file at a time.
     * &amp;lt;p&amp;gt;
     * Issues which are only affected by a single resource file can be checked
     * for incrementally when a file is edited.
     */
    RESOURCE_FILE,//检查单个资源文件，可以增量式检查

    /**
     * The analysis only considers a single binary (typically a bitmap) resource file at a time.
     * &amp;lt;p&amp;gt;
     * Issues which are only affected by a single resource file can be checked
     * for incrementally when a file is edited.
     */
    BINARY_RESOURCE_FILE,//检查二进制形式的资源文件，例如bitmap

    /**
     * The analysis considers the resource folders (which also includes asset folders)
     */
    RESOURCE_FOLDER,//检查资源目录，包括asset目录

    /**
     * The analysis considers &amp;lt;b&amp;gt;all&amp;lt;/b&amp;gt; the resource file. This scope must not
     * be used in conjunction with {@link #RESOURCE_FILE}; an issue scope is
     * either considering just a single resource file or all the resources, not
     * both.
     */
    ALL_RESOURCE_FILES,//检查所有的资源文件，这个和RESOURCE_FILE是互斥的，两者只能设置为其中一个
    ...//其他类型的scope
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;code&gt;Context&lt;/code&gt;类表示lint检查时的上下文环境，包括需要进行分析的项目和文件的信息以及lint规则的配置信息，例如&lt;code&gt;Project，File，LintDriver，Configuration&lt;/code&gt;等，详情请参考下面的代码及其注释理解。其子类包括&lt;code&gt;JavaContext，ClassContext，XmlContext，ResourceContext&lt;/code&gt;，顾名思义，JavaContext就是用来检查Java文件的Context。&lt;br /&gt;
&lt;strong&gt;通俗来讲，Context指的就是lint检查时的上下文信息。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Context passed to the detectors during an analysis run. It provides
 * information about the file being analyzed, it allows shared properties (so
 * the detectors can share results), etc.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
public class Context {
    /**
     * The file being checked. Note that this may not always be to a concrete
     * file. For example, in the {@link Detector#beforeCheckProject(Context)}
     * method, the context file is the directory of the project.
     */
    public final File file;//被检查的文件

    /** The driver running through the checks */
    protected final LintDriver mDriver;//运行所有检查的driver

    /** The project containing the file being checked */
    @NonNull
    private final Project mProject;//包含需要检查的文件的项目

    /**
     * The &amp;quot;main&amp;quot; project. For normal projects, this is the same as {@link #mProject},
     * but for library projects, it&#39;s the root project that includes (possibly indirectly)
     * the various library projects and their library projects.
     * &amp;lt;p&amp;gt;
     * Note that this is a property on the {@link Context}, not the
     * {@link Project}, since a library project can be included from multiple
     * different top level projects, so there isn&#39;t &amp;lt;b&amp;gt;one&amp;lt;/b&amp;gt; main project,
     * just one per main project being analyzed with its library projects.
     */
    private final Project mMainProject;//主项目，在普通项目中它和库项目相同，但是对于库项目来说，主项目是包含多个不同库项目的根项目

    /** The current configuration controlling which checks are enabled etc */
    private final Configuration mConfiguration;//检查器的配置信息，例如哪些检查器开启或关闭了

    /** The contents of the file */
    private String mContents;//文件的内容

    /** Map of properties to share results between detectors */
    private Map&amp;lt;String, Object&amp;gt; mProperties;//用于在检查器之间共享数据的键值对

    /** Whether this file contains any suppress markers (null means not yet determined) */
    private Boolean mContainsCommentSuppress;//文件是否包含suppress lint相关的注释，null表示还不确定
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2.1) &lt;code&gt;Project&lt;/code&gt;类表示一个项目包含的内容，例如项目的路径，名称，android版本信息，sdk信息，buildtool信息，gradle版本，以及其他的各种类型的文件以及文件集合等信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * A project contains information about an Android project being scanned for
 * Lint errors.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public class Project {
    protected final LintClient mClient;//下一篇会详细分析这个 LintClient
    protected final File mDir;
    protected final File mReferenceDir;
    protected Configuration mConfiguration;
    protected String mPackage;
    protected int mBuildSdk = -1;
    protected IAndroidTarget mTarget;

    protected AndroidVersion mManifestMinSdk = AndroidVersion.DEFAULT;
    protected AndroidVersion mManifestTargetSdk = AndroidVersion.DEFAULT;

    protected boolean mLibrary;
    protected String mName;
    protected String mProguardPath;
    protected boolean mMergeManifests;

    /** The SDK info, if any */
    protected SdkInfo mSdkInfo;

    /**
     * If non null, specifies a non-empty list of specific files under this
     * project which should be checked.
     */
    protected List&amp;lt;File&amp;gt; mFiles;
    protected List&amp;lt;File&amp;gt; mProguardFiles;
    protected List&amp;lt;File&amp;gt; mGradleFiles;
    protected List&amp;lt;File&amp;gt; mManifestFiles;
    protected List&amp;lt;File&amp;gt; mJavaSourceFolders;
    protected List&amp;lt;File&amp;gt; mJavaClassFolders;
    protected List&amp;lt;File&amp;gt; mNonProvidedJavaLibraries;
    protected List&amp;lt;File&amp;gt; mJavaLibraries;
    protected List&amp;lt;File&amp;gt; mTestSourceFolders;
    protected List&amp;lt;File&amp;gt; mResourceFolders;
    protected List&amp;lt;File&amp;gt; mAssetFolders;
    protected List&amp;lt;Project&amp;gt; mDirectLibraries;
    protected List&amp;lt;Project&amp;gt; mAllLibraries;
    protected boolean mReportIssues = true;
    protected Boolean mGradleProject;
    protected Boolean mSupportLib;
    protected Boolean mAppCompat;
    protected GradleVersion mGradleVersion;
    private Map&amp;lt;String, String&amp;gt; mSuperClassMap;
    private ResourceVisibilityLookup mResourceVisibility;
    private BuildToolInfo mBuildTools;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2.2) &lt;code&gt;Configuration&lt;/code&gt;类是一个抽象类，主要用来判断或者配置某个lint检查规则是否开启、是否忽略等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Lint configuration for an Android project such as which specific rules to include,
 * which specific rules to exclude, and which specific errors to ignore.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public abstract class Configuration {
    /**
     * Checks whether this issue should be ignored because the user has already
     * suppressed the error? Note that this refers to individual issues being
     * suppressed/ignored, not a whole detector being disabled via something
     * like {@link #isEnabled(Issue)}.
     *
     * @param context the context used by the detector when the issue was found
     * @param issue the issue that was found
     * @param location the location of the issue
     * @param message the associated user message
     * @return true if this issue should be suppressed
     */
    public boolean isIgnored(
            @NonNull Context context,
            @NonNull Issue issue,
            @Nullable Location location,
            @NonNull String message) {
        return false;//有些issue是开启了，但是用户可能以某种方式suppress了这种错误
    }

    /**
     * Returns false if the given issue has been disabled. This is just
     * a convenience method for {@code getSeverity(issue) != Severity.IGNORE}.
     *
     * @param issue the issue to check
     * @return false if the issue has been disabled
     */
    public boolean isEnabled(@NonNull Issue issue) {
        return getSeverity(issue) != Severity.IGNORE;//只要严重程度不是IGNORE的话那就是开启了
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Configuration&lt;/code&gt;有个默认的实现&lt;code&gt;DefaultConfiguration&lt;/code&gt;，在&lt;code&gt;client.api&lt;/code&gt;包中，它的主要作用是读写项目根目录下的&lt;code&gt;lint.xml&lt;/code&gt;配置文件，下面是lint.xml文件的一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;lint&amp;gt;
    &amp;lt;!-- Disable the given check in this project --&amp;gt;
    &amp;lt;issue id=&amp;quot;IconMissingDensityFolder&amp;quot; severity=&amp;quot;ignore&amp;quot; /&amp;gt;

    &amp;lt;!-- Ignore the ObsoleteLayoutParam issue in the specified files --&amp;gt;
    &amp;lt;issue id=&amp;quot;ObsoleteLayoutParam&amp;quot;&amp;gt;
        &amp;lt;ignore regexp=&amp;quot;res/.*/activation.xml&amp;quot; /&amp;gt;
    &amp;lt;/issue&amp;gt;

    &amp;lt;!-- Ignore the UselessLeaf issue in the specified file --&amp;gt;
    &amp;lt;issue id=&amp;quot;UselessLeaf&amp;quot;&amp;gt;
        &amp;lt;ignore path=&amp;quot;res/layout/main.xml&amp;quot; /&amp;gt;
    &amp;lt;/issue&amp;gt;

    &amp;lt;!-- Change the severity of hardcoded strings to &amp;quot;error&amp;quot; --&amp;gt;
    &amp;lt;issue id=&amp;quot;HardcodedText&amp;quot; severity=&amp;quot;error&amp;quot; /&amp;gt;
&amp;lt;/lint&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码片段中包含了读取lint配置文件的实现过程，可以结合注释以及上面的lint.xml文件的例子来看，处理流程相对还比较清晰。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//默认的Configuration的实现
/**
 * Default implementation of a {@link Configuration} which reads and writes
 * configuration data into {@code lint.xml} in the project directory.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public class DefaultConfiguration extends Configuration {
    private final LintClient mClient;
    /** Default name of the configuration file */
    public static final String CONFIG_FILE_NAME = &amp;quot;lint.xml&amp;quot;; //$NON-NLS-1$

    // Lint XML File =&amp;gt; 定义lint.xml文件中的元素标签
    @NonNull
    private static final String TAG_ISSUE = &amp;quot;issue&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String ATTR_ID = &amp;quot;id&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String ATTR_SEVERITY = &amp;quot;severity&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String ATTR_PATH = &amp;quot;path&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String ATTR_REGEXP = &amp;quot;regexp&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String TAG_IGNORE = &amp;quot;ignore&amp;quot;; //$NON-NLS-1$
    @NonNull
    private static final String VALUE_ALL = &amp;quot;all&amp;quot;; //$NON-NLS-1$

    private final Configuration mParent;
    private final Project mProject;
    private final File mConfigFile;
    private boolean mBulkEditing;

    /** Map from id to list of project-relative paths for suppressed warnings */
    private Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; mSuppressed;//指定issue有哪些不检查的路径列表

    /** Map from id to regular expressions. */
    @Nullable
    private Map&amp;lt;String, List&amp;lt;Pattern&amp;gt;&amp;gt; mRegexps;

    /**
     * Map from id to custom {@link Severity} override
     */
    private Map&amp;lt;String, Severity&amp;gt; mSeverity;//指定issue对应的严重程度
    ...
    //从lint配置文件中读取lint规则的配置信息
    private void readConfig() {
        mSuppressed = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
        mSeverity = new HashMap&amp;lt;String, Severity&amp;gt;();

        if (!mConfigFile.exists()) {
            return;
        }

        try {
            Document document = XmlUtils.parseUtfXmlFile(mConfigFile, false);
            NodeList issues = document.getElementsByTagName(TAG_ISSUE);
            Splitter splitter = Splitter.on(&#39;,&#39;).trimResults().omitEmptyStrings();
            for (int i = 0, count = issues.getLength(); i &amp;lt; count; i++) {//遍历issue
                Node node = issues.item(i);
                Element element = (Element) node;
                String idList = element.getAttribute(ATTR_ID);//读取id属性值
                if (idList.isEmpty()) {
                    formatError(&amp;quot;Invalid lint config file: Missing required issue id attribute&amp;quot;);
                    continue;
                }
                Iterable&amp;lt;String&amp;gt; ids = splitter.split(idList);//id属性值中可能存在多个id，先将其分开来

                //下面这部分是处理severity属性值的配置
                NamedNodeMap attributes = node.getAttributes();
                for (int j = 0, n = attributes.getLength(); j &amp;lt; n; j++) {
                    Node attribute = attributes.item(j);
                    String name = attribute.getNodeName();
                    String value = attribute.getNodeValue();
                    if (ATTR_ID.equals(name)) {
                        // already handled
                    } else if (ATTR_SEVERITY.equals(name)) {
                        for (Severity severity : Severity.values()) {
                            if (value.equalsIgnoreCase(severity.name())) {
                                for (String id : ids) {
                                    mSeverity.put(id, severity);
                                }
                                break;
                            }
                        }
                    } else {
                        formatError(&amp;quot;Unexpected attribute \&amp;quot;%1$s\&amp;quot;&amp;quot;, name);
                    }
                }

                //下面这部分是处理该issue的ignore路径的配置，配置ignore有两种方式，一种是path，另一种是regexp (正则匹配)
                // Look up ignored errors
                NodeList childNodes = element.getChildNodes();
                if (childNodes.getLength() &amp;gt; 0) {
                    for (int j = 0, n = childNodes.getLength(); j &amp;lt; n; j++) {
                        Node child = childNodes.item(j);
                        if (child.getNodeType() == Node.ELEMENT_NODE) {
                            Element ignore = (Element) child;
                            String path = ignore.getAttribute(ATTR_PATH);
                            if (path.isEmpty()) {//regexp的形式
                                String regexp = ignore.getAttribute(ATTR_REGEXP);
                                if (regexp.isEmpty()) {
                                    formatError(&amp;quot;Missing required attribute %1$s or %2$s under %3$s&amp;quot;,
                                        ATTR_PATH, ATTR_REGEXP, idList);
                                } else {
                                    addRegexp(idList, ids, n, regexp, false);
                                }
                            } else {//path的形式
                                // Normalize path format to File.separator. Also
                                // handle the file format containing / or \.
                                if (File.separatorChar == &#39;/&#39;) {
                                    path = path.replace(&#39;\\&#39;, &#39;/&#39;);
                                } else {
                                    path = path.replace(&#39;/&#39;, File.separatorChar);
                                }

                                if (path.indexOf(&#39;*&#39;) != -1) {
                                    String regexp = globToRegexp(path);
                                    addRegexp(idList, ids, n, regexp, false);
                                } else {
                                    for (String id : ids) {
                                        List&amp;lt;String&amp;gt; paths = mSuppressed.get(id);
                                        if (paths == null) {
                                            paths = new ArrayList&amp;lt;String&amp;gt;(n / 2 + 1);
                                            mSuppressed.put(id, paths);
                                        }
                                        paths.add(path);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (SAXParseException e) {
            formatError(e.getMessage());
        } catch (Exception e) {
            mClient.log(e, null);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2.3) &lt;code&gt;LintDriver&lt;/code&gt;类很大很复杂，而且是在&lt;code&gt;client.api&lt;/code&gt;包中，我们将在下一节介绍。&lt;/p&gt;

&lt;p&gt;(3) &lt;code&gt;Detector&lt;/code&gt;类表示lint检查器，也就是用来发现文件中是否存在某个问题的检查器，自定义lint规则就是自定义相应的Detector。针对不同类型文件的检查器会按照预先定义的顺序依次进行检查，检查的顺序依次是&lt;code&gt;Manifest文件 =&amp;gt; Resource文件 =&amp;gt; Java源码文件 =&amp;gt; Java Class文件 =&amp;gt; Gradle文件 =&amp;gt; Generic文件 =&amp;gt; Proguard文件 =&amp;gt; Property文件&lt;/code&gt;。Detector类中定义了很多检查器通用的一些方法，比如下面代码片段中的&lt;code&gt;visitMethod&lt;/code&gt;、&lt;code&gt;visitConstructor&lt;/code&gt;等等。&lt;br /&gt;
&lt;strong&gt;通俗来讲，Detector指的就是一个个的lint检查器。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Detector {
    ...
    @SuppressWarnings({&amp;quot;UnusedParameters&amp;quot;, &amp;quot;unused&amp;quot;, &amp;quot;javadoc&amp;quot;})
    public void visitMethod(@NonNull JavaContext context, @Nullable JavaElementVisitor visitor,
            @NonNull PsiMethodCallExpression call, @NonNull PsiMethod method) {
    }//访问一个普通的方法

    @SuppressWarnings({&amp;quot;UnusedParameters&amp;quot;, &amp;quot;unused&amp;quot;, &amp;quot;javadoc&amp;quot;})
    public void visitConstructor(
            @NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor,
            @NonNull PsiNewExpression node,
            @NonNull PsiMethod constructor) {
    }//访问一个构造函数

    @SuppressWarnings({&amp;quot;UnusedParameters&amp;quot;, &amp;quot;unused&amp;quot;, &amp;quot;javadoc&amp;quot;})
    public void visitResourceReference(@NonNull JavaContext context,
            @Nullable JavaElementVisitor visitor, @NonNull PsiElement node,
            @NonNull ResourceType type, @NonNull String name, boolean isFramework) {
    }//访问一个资源引用
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，&lt;code&gt;Detector&lt;/code&gt;类中还定义了很多不同类型文件的扫描器(Scanner)接口，例如&lt;code&gt;JavaPsiScanner，ClassScanner，ResourceFolderScanner，XmlScanner，GradleScanner，BinaryResourceScanner，OtherFileScanner&lt;/code&gt;，后面我们会详细介绍其中的&lt;code&gt;JavaPsiScanner&lt;/code&gt;。有意思的是，这些Scanner接口中定义的所有方法都在Detector类中都对应有相同签名的方法，也就是&lt;code&gt;Detector&lt;/code&gt;是所有的&lt;code&gt;Scanner&lt;/code&gt;的适配器，所以检查器一般会继承&lt;code&gt;Detector&lt;/code&gt;类并实现某个&lt;code&gt;Scanner&lt;/code&gt;接口。下面是&lt;code&gt;XmlScanner&lt;/code&gt;和&lt;code&gt;GradleScanner&lt;/code&gt;两个接口的定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Specialized interface for detectors that scan XML files */
public interface XmlScanner {
    /**
     * Visit the given document. The detector is responsible for its own iteration
     * through the document.
     * @param context information about the document being analyzed
     * @param document the document to examine
     */
    void visitDocument(@NonNull XmlContext context, @NonNull Document document);

    /**
     * Visit the given element.
     * @param context information about the document being analyzed
     * @param element the element to examine
     */
    void visitElement(@NonNull XmlContext context, @NonNull Element element);

    /**
     * Visit the given element after its children have been analyzed.
     * @param context information about the document being analyzed
     * @param element the element to examine
     */
    void visitElementAfter(@NonNull XmlContext context, @NonNull Element element);

    /**
     * Visit the given attribute.
     * @param context information about the document being analyzed
     * @param attribute the attribute node to examine
     */
    void visitAttribute(@NonNull XmlContext context, @NonNull Attr attribute);

    /**
     * Returns the list of elements that this detector wants to analyze. If non
     * null, this detector will be called (specifically, the
     * {@link #visitElement} method) for each matching element in the document.
     * &amp;lt;p&amp;gt;
     * If this method returns null, and {@link #getApplicableAttributes()} also returns
     * null, then the {@link #visitDocument} method will be called instead.
     *
     * @return a collection of elements, or null, or the special
     *         {@link XmlScanner#ALL} marker to indicate that every single
     *         element should be analyzed.
     */
    @Nullable
    Collection&amp;lt;String&amp;gt; getApplicableElements();

    /**
     * Returns the list of attributes that this detector wants to analyze. If non
     * null, this detector will be called (specifically, the
     * {@link #visitAttribute} method) for each matching attribute in the document.
     * &amp;lt;p&amp;gt;
     * If this method returns null, and {@link #getApplicableElements()} also returns
     * null, then the {@link #visitDocument} method will be called instead.
     *
     * @return a collection of attributes, or null, or the special
     *         {@link XmlScanner#ALL} marker to indicate that every single
     *         attribute should be analyzed.
     */
    @Nullable
    Collection&amp;lt;String&amp;gt; getApplicableAttributes();

    /**
     * Special marker collection returned by {@link #getApplicableElements()} or
     * {@link #getApplicableAttributes()} to indicate that the check should be
     * invoked on all elements or all attributes
     */
    @NonNull
    List&amp;lt;String&amp;gt; ALL = new ArrayList&amp;lt;String&amp;gt;(0); // NOT Collections.EMPTY!
    // We want to distinguish this from just an *empty* list returned by the caller!
}

/** Specialized interface for detectors that scan Gradle files */
public interface GradleScanner {
    void visitBuildScript(@NonNull Context context, Map&amp;lt;String, Object&amp;gt; sharedData);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4) &lt;code&gt;Issue&lt;/code&gt;类表示应用中可能存在的问题，它一般关联着一个表示问题严重程度的&lt;code&gt;Severity&lt;/code&gt;类，表示问题类别的&lt;code&gt;Category&lt;/code&gt;类以及用来发现和检查这个问题的&lt;code&gt;Detector&lt;/code&gt;(包含在&lt;code&gt;Implementation&lt;/code&gt;类中)。&lt;br /&gt;
&lt;strong&gt;通俗来讲，Issue指的就是检查器去检查文件时发现它可能出现的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An issue is a potential bug in an Android application. An issue is discovered
 * by a {@link Detector}, and has an associated {@link Severity}.
 * &amp;lt;p&amp;gt;
 * Issues and detectors are separate classes because a detector can discover
 * multiple different issues as it&#39;s analyzing code, and we want to be able to
 * different severities for different issues, the ability to suppress one but
 * not other issues from the same detector, and so on.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
public final class Issue implements Comparable&amp;lt;Issue&amp;gt; {
    private final String mId;//问题id，名称标识
    private final String mBriefDescription;//简单描述
    private final String mExplanation;//详细解释
    private final Category mCategory;//问题类别
    private final int mPriority;//问题等级
    private final Severity mSeverity;//问题严重程度
    private Object mMoreInfoUrls;//问题的更多信息，可能是一个网址的url
    private boolean mEnabledByDefault = true;//是否默认开启
    private Implementation mImplementation;//这个问题的检查器相关信息
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4.1) &lt;code&gt;Severity&lt;/code&gt;类是表示问题严重程度的枚举类，主要分为了&lt;code&gt;FATAL，ERROR，WARNING，INFORMATIONAL，IGNORE&lt;/code&gt;这几种程度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Severity of an issue found by lint
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public enum Severity {
    /**
     * Fatal: Use sparingly because a warning marked as fatal will be
     * considered critical and will abort Export APK etc in ADT
     */
    @NonNull
    FATAL(&amp;quot;Fatal&amp;quot;),//标记为Fatal将被视为非常危险，在导出apk时可能会终止

    /**
     * Errors: The issue is known to be a real error that must be addressed.
     */
    @NonNull
    ERROR(&amp;quot;Error&amp;quot;),//的确是一个问题

    /**
     * Warning: Probably a problem.
     */
    @NonNull
    WARNING(&amp;quot;Warning&amp;quot;),//警告，可能是一个问题

    /**
     * Information only: Might not be a problem, but the check has found
     * something interesting to say about the code.
     */
    @NonNull
    INFORMATIONAL(&amp;quot;Information&amp;quot;),//可能不是一个问题

    /**
     * Ignore: The user doesn&#39;t want to see this issue
     */
    @NonNull
    IGNORE(&amp;quot;Ignore&amp;quot;);//用户不想看到的问题
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4.2) &lt;code&gt;Category&lt;/code&gt;类表示问题的类别，主要有&lt;code&gt;Correctness，Security，Performance，Usability，Accessibility，Internationalization&lt;/code&gt;等，类别下面可以有子类别，每个类别都还有一个优先级。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * A category is a container for related issues.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
public final class Category implements Comparable&amp;lt;Category&amp;gt; {
    private final String mName;//类别名称
    private final int mPriority;//优先级
    private final Category mParent;//父类别
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4.3) &lt;code&gt;Implementation&lt;/code&gt;类表示问题对应的检查器实现，除了绑定一个检查器之外，还绑定了相应的检查范围Scope。需要注意的是&lt;code&gt;mScope&lt;/code&gt;和&lt;code&gt;mAnalysisScopes&lt;/code&gt;的含义是不同的，表示的具体范围也不一定是一样的，有些问题比较复杂，可能需要分析更多的文件范围才能确定是否存在这个问题。例如，检查某个资源是否使用了，不仅需要检查资源XML文件，还要检查Java文件，只有这两个范围都没有使用这个资源才能确定地认为这个资源没有被使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An {@linkplain Implementation} of an {@link Issue} maps to the {@link Detector}
 * class responsible for analyzing the issue, as well as the {@link Scope} required
 * by the detector to perform its analysis.
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;NOTE: This is not a public or final API; if you rely on this be prepared
 * to adjust your code for the next tools release.&amp;lt;/b&amp;gt;
 */
@Beta
public class Implementation {
    private final Class&amp;lt;? extends Detector&amp;gt; mClass;//问题对应的检查器
    private final EnumSet&amp;lt;Scope&amp;gt; mScope;//检查器的检查范围，可能是存在很多的scope中
    private EnumSet&amp;lt;Scope&amp;gt;[] mAnalysisScopes;//检查器分析问题时的范围
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom Lint in Action</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/14/custom-lint-in-action/</link>
      <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/14/custom-lint-in-action/</guid>
      <description>&lt;p&gt;本文记录为Android项目自定义Lint检查规则的实践研究。&lt;/p&gt;

&lt;p&gt;Android Lint是Google提供的静态代码检查工具，使用Lint可以对Android项目源码进行扫描和检查，发现代码潜在的问题，或者辅助开发者统一编码规范。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.lint工具的源码在哪里，都有些什么内容呢？&lt;/strong&gt;&lt;br /&gt;
Lint工具以及现有的检查项的源码在&lt;a href=&#34;https://android.googlesource.com/platform/tools/base/+/master/lint&#34;&gt;android studio源码(aosp的一部分)的tools/base/lint目录&lt;/a&gt;下，其中cli子目录是用来生成lint报告结果的，libs目录下才是核心源码，包括了lint-api、lint-checks、lint-tests三个子目录，分别是lint核心API、自带的lint检查项以及lint测试代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.如何查看目前已经有哪些lint检查项呢？&lt;/strong&gt;&lt;br /&gt;
打开AS的设置，找到Editor下面的Inspections即可看到现有的检查项，它们对应的源码可在上面的lint-checks中查看或者在这里在线查看: &lt;a href=&#34;https://android.googlesource.com/platform/tools/base/+/master/lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks&#34;&gt;lint-checks&lt;/a&gt;，这也是学习如何自定义lint规则最好的学习资料。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/as_lint_issues.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.如何自定义lint规则以及如何应用规则？&lt;/strong&gt;&lt;br /&gt;
关于这部分内容最主要的学习文档就是&lt;a href=&#34;http://tools.android.com/tips/lint-custom-rules&#34;&gt;Google-自定义Lint规则说明文档&lt;/a&gt;，对应的&lt;a href=&#34;https://github.com/googlesamples/android-custom-lint-rules&#34;&gt;google sample项目源码&lt;/a&gt;，思路大致是依赖lint-api创建自己的lint规则，然后将自定义的lint规则打包成jar(保存在build/libs中)，将jar包复制到&lt;code&gt;~/.android/lint&lt;/code&gt;目录下，最后在Android工程源码目录下执行&lt;code&gt;./gradlew lint&lt;/code&gt;即可。这种方案的缺点是它针对的是本机的所有项目，也就是会影响同一台机器其他项目的Lint检查。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/.android/lint; cp ./build/libs/custom-lint.jar ~/.android/lint/
lint --list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了将自定义lint规则的jar包复制到&lt;code&gt;~/.android/lint&lt;/code&gt;目录下这种方式外，我们还可以通过设置环境变量&lt;code&gt;ANDROID_LINT_JARS&lt;/code&gt;来将自定义的lint规则添加到系统全局默认的lint规则集合中，如果你有多个jar可以使用&lt;code&gt;:&lt;/code&gt;来将它们连接起来。下面是一个参考使用方式，虽然我们并没有将自定义的lint规则放在&lt;code&gt;~/.android/lint&lt;/code&gt;目录下，但是照样能够应用这些规则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export ANDROID_LINT_JARS=~/.android/lint_bak/android-custom-lint-rules.jar
lint --list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，除了执行&lt;code&gt;./gradlew lint&lt;/code&gt;命令之外，我们还可以使用AS自带的一个更好的代码检查功能，选择&lt;code&gt;Analyze&lt;/code&gt;菜单下面的&lt;code&gt;Inspect Code...&lt;/code&gt;选项，然后选择某个目录执行lint检查。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/as_inspectcode.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;待执行完成之后可以在AS中看到下面的结果，其中我们自定义的lint规则的结果显示在Android Lint这个Category下面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/as_lintresult.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：测试发现AS这块可能存在bug，如果修改了&lt;code&gt;~/.android/lint&lt;/code&gt;目录下的jar的话，AS并不会重新加载，需要重启AS才行。另外，在&lt;code&gt;~/.android/lint&lt;/code&gt;目录下存放多个jar也是可以的。&lt;/strong&gt;&lt;br /&gt;
[前面那个bug我后来在看lint工具源码中找到了原因，和&lt;code&gt;JarFileIssueRegistry&lt;/code&gt;这个类有关，它内部有个缓存机制]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.Google方案的改进：LinkedIn的aar方案&lt;/strong&gt;&lt;br /&gt;
LinkedIn提供了另一种思路：将jar放到一个aar中，然后Android项目依赖这个aar完成自定义lint检查。利用这种方案我们就可以针对项目进行自定义Lint规则，lint.jar只对当前项目有效。详情参考&lt;a href=&#34;https://engineering.linkedin.com/android/writing-custom-lint-checks-gradle&#34;&gt;LinkedIn-自定义Lint规则并封装成aar的方案&lt;/a&gt;，它对应的lint demo项目源码包含两部分，一部分是&lt;a href=&#34;https://github.com/yangcheng/CustomLint&#34;&gt;自定义lint规则-CustomLint项目&lt;/a&gt;，另一部分是在Android工程中&lt;a href=&#34;https://github.com/yangcheng/LintDemoApp&#34;&gt;使用lint规则-LintDemoApp项目&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;(1)CustomLint项目&lt;br /&gt;
该项目分成了两部分，一部分是lintrules，它依赖lint-api实现自定义的lint规则并打包成jar，存放在build/libs目录下；另一部分是lintlib，它将lintrules得到的jar复制到build/intermediates/lint目录下，并封装成一个aar，保存在build/outputs/aar目录下。&lt;/p&gt;

&lt;p&gt;lintrules工程的&lt;code&gt;build.gradle&lt;/code&gt;的代码片段：添加&lt;code&gt;lintChecks&lt;/code&gt;这个&lt;code&gt;configuration&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//use these configurations to build lint jar
jar {
    manifest {
        //下面这个配置将在lint.jar的META-INF/MANIFEST.MF中添加Lint-Registry: com.meizu.flyme.FlymeLint
        //这一步也很重要，我们将在后面的源码解析中分析到这一步
        attributes &#39;Lint-Registry&#39;: &#39;com.meizu.flyme.FlymeLint&#39;
    }
}

configurations {
    lintChecks
}

dependencies {
    lintChecks files(jar)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lintlib工程的&lt;code&gt;build.gradle&lt;/code&gt;的代码片段：也添加&lt;code&gt;lintChecks&lt;/code&gt;这个&lt;code&gt;configuration&lt;/code&gt;，但是它依赖lintrules工程的&lt;code&gt;lintChecks&lt;/code&gt;这个&lt;code&gt;configuration&lt;/code&gt;，将其生成的jar重命名为&lt;code&gt;lint.jar&lt;/code&gt;然后保存到&lt;code&gt;build/intermediates/lint/&lt;/code&gt;目录下，之后打包到生成的aar中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;configurations {
    lintChecks
}

dependencies {
    lintChecks project(path: &amp;quot;:lintrules&amp;quot;, configuration: &amp;quot;lintChecks&amp;quot;)
}

task copyLintJar(type: Copy){
    from (configurations.lintChecks) {
        rename {
            String fileName -&amp;gt;
                &#39;lint.jar&#39;
        }
    }
    into &#39;build/intermediates/lint/&#39;
}

project.afterEvaluate{
    def compileLintTask = project.tasks.find {it.name == &#39;compileLint&#39;}
    compileLintTask.dependsOn(copyLintJar)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)LintDemoApp项目
该项目是一个示例，利用上面得到的aar封装成一个Android Library项目，然后核心模块app依赖它，这样当执行lint时就会自动将自定义的lint规则添加到lint规则集合中了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.推荐在公司内部实施的Lint检查方案&lt;/strong&gt;&lt;br /&gt;
将自定义的lint规则打包成jar，接着封装成aar，然后上传到公司内部的artifactory，最后集成到各个应用中，利用AS的Lint检查功能对应用进行Lint检查即可。注意，这种方式并不会对生成的apk的大小产生任何影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.自定义lint规则的演示应用&lt;/strong&gt;&lt;br /&gt;
这里我已经创建好了一个为了演示用的应用&lt;a href=&#34;https://github.com/hujiaweibujidao/customlint&#34;&gt;customlint&lt;/a&gt;，其中添加了一个LogDetector的lint规则。&lt;/p&gt;

&lt;p&gt;完整的实现流程记录如下：&lt;br /&gt;
1.新建一个Android项目，添加一个空的Activity即可。&lt;br /&gt;
2.新建一个Java Library项目，添加依赖&lt;code&gt;compile &#39;com.android.tools.lint:lint-api:24.5.0&#39;&lt;/code&gt;，并编写lint规则，然后在build.gradle中配置，最后生成jar。&lt;br /&gt;
&lt;strong&gt;注意：这里最好是先测试一下jar，将jar复制到&lt;code&gt;~/.android/lint&lt;/code&gt;目录下，然后在终端输入&lt;code&gt;lint --list&lt;/code&gt;查看自定义的lint规则是否已经添加上了，测试成功之后再将jar包从那个目录删除。&lt;/strong&gt;&lt;br /&gt;
3.新建一个Android Library项目，删除没有用的test和androidTest相关的依赖和源码目录，然后参考Linkedin的方案添加一些配置，将上一步得到的jar封装到最终生成的aar中，最后将生成的aar上传到bintray或者jitpack(我选择的是后者)。&lt;br /&gt;
4.在Android项目的build.gradle文件中添加对上面的aar的依赖，然后在MainActivity中写两个lint检查时会出错的情况，然后选择Analyze下面的Inspect Code选项，目录设置为app模块的根目录，即可看到lint的检查结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/custom_lint.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：该项目的release 1.0.0版本的lintrules依赖的是24.5.0版本的lint-api，演示的LogDetector来自下面参考资料中的美团的LogDetector。但是目前该项目最新的release 1.0.1版本依赖的是25.2.0版本的lint-api，演示的LogDetector参考自lint工具自带的LogDetector。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OK，感兴趣的话欢迎阅读&lt;a href=&#34;https://github.com/hujiaweibujidao/customlint&#34;&gt;customlint&lt;/a&gt;项目源码，感谢Linkedin和MeiTuan提供的技术文档和实践源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.其他参考资料&lt;/strong&gt;&lt;br /&gt;
1.&lt;a href=&#34;http://tech.meituan.com/android_custom_lint.html&#34;&gt;美团-Android自定义Lint实践&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;https://segmentfault.com/a/1190000004497435&#34;&gt;segmentfault-自定义Lint规则简介&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&#34;http://www.jianshu.com/p/7b3519dc1e5f&#34;&gt;Android Studio配合Lint检测缺失Permission&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&#34;http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/testing/lint_supportlint.html&#34;&gt;Gradle Lint support&lt;/a&gt;&lt;br /&gt;
5.&lt;a href=&#34;http://www.carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html&#34;&gt;浅谈Android自定义Lint规则的实现&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;这篇文章是我写完后才发现的，比我的这篇文章要详细很多，内容更加丰富，灰常推荐阅读。博主除了写了这篇自定义lint规则的文章之外，还写了两篇文章来分析其实现原理。我其实也已经写了几篇文章来解析其源码，但是在仔细读完那位博主的总结之后，发现自己的总结没有那位博主写得好，所以我将自己的总结进行了修改，那位博主没有写的内容我来补充，其他内容还是推荐看那位博主的，当然很多重要的核心内容还是会交叉介绍到的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;One More Thing&amp;hellip;&lt;/strong&gt;&lt;br /&gt;
其实，看完本节你应该会有很多的疑惑，为什么自定义的lint规则打包成jar放在&lt;code&gt;~/.android/lint&lt;/code&gt;目录下就可以使用了呢？为什么设置那个环境变量也行呢？还有，将lint.jar打包到aar中为什么也可以实现自定义lint检查呢？这些问题需要我们去阅读lint工具的源码才能够真正解开谜底，欢迎阅读&lt;a href=&#34;https://hujiaweibujidao.github.io/blog/2016/11/17/lint-tool-analysis-1/&#34;&gt;Lint工具源码解析(1)&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>App Launch Time Measurement</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/10/app-launch-time-measurement/</link>
      <pubDate>Thu, 10 Nov 2016 16:46:33 +0800</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/10/app-launch-time-measurement/</guid>
      <description>

&lt;p&gt;本文记录下分析应用启动时间的总结。&lt;/p&gt;

&lt;p&gt;关于应用启动时间测量的分析已经有不少不错的文章做了总结，下面是比较好的几篇：&lt;br /&gt;
1.&lt;a href=&#34;http://hukai.me/android-performance-patterns-season-6/&#34;&gt;Android性能优化典范-第6季&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1101/3647.html&#34;&gt;测量Activity 的启动时间&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzIwOTQ1MjAwMg==&amp;amp;mid=2247483771&amp;amp;idx=1&amp;amp;sn=fc2a36bddd29a0bb9d6512ba7e9b71ad&amp;amp;chksm=9772eff6a00566e0424e3bccfcf61df5bff709739ece80c6641ca6cf742e9949c27f29bc48f0&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1008ksnBumwlSEhlQl3Qe45O#rd&#34;&gt;Activity到底是什么时候显示到屏幕上的呢&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面的每篇都各有特色，我这篇也只是在他们的分析上记录下自己学习和研究过程的总结。&lt;/p&gt;

&lt;h3 id=&#34;1-查看display-time&#34;&gt;1.查看display time&lt;/h3&gt;

&lt;p&gt;从Android KitKat版本开始，Logcat中会输出从程序启动到Activity显示到屏幕上所花费的时间，这个时间包含了进程启动的时间，比较适合测量程序的启动时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I ActivityManager: Displayed com.meizu.flyme.applaunch/.MainActivity: +379ms
//厂商定制过的OS可能会有些不同，例如FlymeOS中的输出
I ActivityManager: [AppLaunch] Displayed Displayed com.meizu.flyme.applaunch/.MainActivity: +480ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面信息的打印来自&lt;code&gt;ActivityRecord&lt;/code&gt;类的&lt;code&gt;reportLaunchTimeLocked&lt;/code&gt;方法，它的实现如下所示，整个过程和下面的fully drawn time类似，我们在下面会介绍它的详细实现过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/reportLaunchTimeLocked.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;除了看Logcat之外，我们还有其他的方式来查看上面的时间，例如使用&lt;code&gt;am start&lt;/code&gt;的方式查看&lt;code&gt;TotalTime&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell am start -W com.meizu.flyme.applaunch/.MainActivity
Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.meizu.flyme.applaunch/.MainActivity }
Status: ok
Activity: com.meizu.flyme.applaunch/.MainActivity
ThisTime: 479
TotalTime: 479
WaitTime: 499
Complete
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者查看EventLog的方法来查看&lt;code&gt;am_activity_launch_time&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$adb shell logcat -b events
... I am_activity_launch_time: [0,200792421,com.meizu.flyme.applaunch/.MainActivity,478,478]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-查看fully-drawn-time&#34;&gt;2.查看fully drawn time&lt;/h3&gt;

&lt;p&gt;通常应用启动的时候都会以异步加载的方式来加快应用的启动速度，但是上面的display time是不包含异步加载所耗费的时间，所以为了准确衡量应用的启动时间，我们可以在异步加载完毕之后调用&lt;code&gt;Activity.reportFullyDrawn()&lt;/code&gt;方法来告诉系统加载完成，以便获取整个应用启动的耗时。&lt;/p&gt;

&lt;p&gt;查看方式和输出结果类似上面的查看display time的过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Logcat中的输出
I ActivityManager: Fully drawn com.meizu.flyme.applaunch/.MainActivity: +2s319ms
//EventLog中的输出
... I am_activity_fully_drawn_time: [0,200792421,com.meizu.flyme.applaunch/.MainActivity,478,478]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是&lt;code&gt;Activity.reportFullyDrawn()&lt;/code&gt;方法的实现，从注释来看，这个方法主要是用来帮助我们测量应用的启动时间，因为系统最多只能确定应用的window第一次绘制和显示的时间点，不能确定应用真正加载完成处于可以使用状态的时间点，所以需要开发者来显式调用这个方法以通知系统应用已经启动完毕可以使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity&#39;s window
 * is &amp;lt;em&amp;gt;first&amp;lt;/em&amp;gt; drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
public void reportFullyDrawn() {
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManagerNative.getDefault().reportActivityFullyDrawn(mToken);
        } catch (RemoteException e) {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;ActivityManagerNative&lt;/code&gt;的&lt;code&gt;reportActivityFullyDrawn&lt;/code&gt;方法会经过Binder调用到AMS的&lt;code&gt;reportActivityFullyDrawn&lt;/code&gt;方法，最终会调用到&lt;code&gt;ActivityRecord&lt;/code&gt;的&lt;code&gt;reportFullyDrawnLocked&lt;/code&gt;方法，内容与&lt;code&gt;reportLaunchTimeLocked&lt;/code&gt;方法类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void reportFullyDrawnLocked() {
    final long curTime = SystemClock.uptimeMillis();
    if (displayStartTime != 0) {
        reportLaunchTimeLocked(curTime);
    }
    final ActivityStack stack = task.stack;
    if (fullyDrawnStartTime != 0 &amp;amp;&amp;amp; stack != null) {
        final long thisTime = curTime - fullyDrawnStartTime;
        final long totalTime = stack.mFullyDrawnStartTime != 0
                ? (curTime - stack.mFullyDrawnStartTime) : thisTime;
        if (SHOW_ACTIVITY_START_TIME) {
            Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;drawing&amp;quot;, 0);
            EventLog.writeEvent(EventLogTags.AM_ACTIVITY_FULLY_DRAWN_TIME,
                    userId, System.identityHashCode(this), shortComponentName,
                    thisTime, totalTime);//EventLog中的输出
            StringBuilder sb = service.mStringBuilder;
            sb.setLength(0);
            sb.append(&amp;quot;Fully drawn &amp;quot;);
            sb.append(shortComponentName);
            sb.append(&amp;quot;: &amp;quot;);
            TimeUtils.formatDuration(thisTime, sb);
            if (thisTime != totalTime) {
                sb.append(&amp;quot; (total &amp;quot;);
                TimeUtils.formatDuration(totalTime, sb);
                sb.append(&amp;quot;)&amp;quot;);
            }
            Log.i(TAG, sb.toString());//Logcat中的输出
        }
        if (totalTime &amp;gt; 0) {
            //service.mUsageStatsService.noteFullyDrawnTime(realActivity, (int) totalTime);
        }
        stack.mFullyDrawnStartTime = 0;
    }
    fullyDrawnStartTime = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中有个起始时间(&lt;code&gt;fullyDrawnStartTime&lt;/code&gt;)，它是在哪里设置的呢？它是在&lt;code&gt;ActivityStack&lt;/code&gt;的&lt;code&gt;setLaunchTime&lt;/code&gt;方法中设置的。&lt;br /&gt;
&lt;strong&gt;注：下面代码中的&lt;code&gt;Trace.asyncTraceBegin&lt;/code&gt;和&lt;code&gt;Trace.asyncTraceEnd&lt;/code&gt;实际上会调用到系统中&lt;code&gt;atrace&lt;/code&gt;的&lt;code&gt;async_start&lt;/code&gt;和&lt;code&gt;async_stop&lt;/code&gt;(可以通过&lt;code&gt;adb shell atrace -h&lt;/code&gt;查看到这两个命令的选项)。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void setLaunchTime(ActivityRecord r) {
    if (r.displayStartTime == 0) {
        r.fullyDrawnStartTime = r.displayStartTime = SystemClock.uptimeMillis();
        if (mLaunchStartTime == 0) {
            startLaunchTraces(r.packageName);
            mLaunchStartTime = mFullyDrawnStartTime = r.displayStartTime;
        }
    } else if (mLaunchStartTime == 0) {
        startLaunchTraces(r.packageName);
        mLaunchStartTime = mFullyDrawnStartTime = SystemClock.uptimeMillis();
    }
}

private void startLaunchTraces(String packageName) {
    if (mFullyDrawnStartTime != 0)  {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;drawing&amp;quot;, 0);
    }
    Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;launching: &amp;quot; + packageName, 0);
    Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;drawing&amp;quot;, 0);
}

private void stopFullyDrawnTraceIfNeeded() {
    if (mFullyDrawnStartTime != 0 &amp;amp;&amp;amp; mLaunchStartTime == 0) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;quot;drawing&amp;quot;, 0);
        mFullyDrawnStartTime = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那&lt;code&gt;setLaunchTime&lt;/code&gt;方法是何时调用的呢？它是在&lt;code&gt;ActivityStackSupervisor.startSpecificActivityLocked&lt;/code&gt;方法中调用的！&lt;br /&gt;
&lt;code&gt;startSpecificActivityLocked&lt;/code&gt;方法中会判断应用进程是否启动了，如果没有启动就调用&lt;code&gt;startProcessLocked&lt;/code&gt;方法来启动进程，内部会调用&lt;code&gt;Process&lt;/code&gt;类的&lt;code&gt;start&lt;/code&gt;方法来启动新进程；否则调用&lt;code&gt;realStartActivityLocked&lt;/code&gt;方法继续执行，这个方法会调用&lt;code&gt;scheduleLaunchActivity&lt;/code&gt;方法，内部将会调用&lt;code&gt;Activity&lt;/code&gt;的&lt;code&gt;onCreate&lt;/code&gt;方法，开始Activity的生命周期。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {
    // Is this activity&#39;s application already running?
    ProcessRecord app = mService.getProcessRecordLocked(r.processName,
            r.info.applicationInfo.uid, true);

    r.task.stack.setLaunchTime(r);//在这里设置launch start time

    if (app != null &amp;amp;&amp;amp; app.thread != null) {
        try {
            if ((r.info.flags&amp;amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&amp;quot;android&amp;quot;.equals(r.info.packageName)) {
                // Don&#39;t add this if it is a platform component that is marked
                // to run in multiple processes, because this is actually
                // part of the framework so doesn&#39;t make sense to track as a
                // separate apk in the process.
                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats);
            }
            realStartActivityLocked(r, app, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, &amp;quot;Exception when starting activity &amp;quot; + r.intent.getComponent().flattenToShortString(), e);
        }

        // If a dead object exception was thrown -- fall through to restart the application.
    }

    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            &amp;quot;activity&amp;quot;, r.intent.getComponent(), false, false, true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方式是录屏然后测量，和使用高速相机录像然后测量差不多，由于比较麻烦，此处不表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build Android Studio Source Code</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/11/09/build-android-studio-source-code/</link>
      <pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/11/09/build-android-studio-source-code/</guid>
      <description>

&lt;p&gt;本文简单记录下如何编译Android Studio这个开发工具的源码。&lt;/p&gt;

&lt;h3 id=&#34;1-简单说明&#34;&gt;1.简单说明&lt;/h3&gt;

&lt;p&gt;android studio的源码其实是aosp中的一部分，同样是采用repo对git项目进行管理。
android studio的源码涉及到aosp中的sdk.git，ndk.git，external/qemu.git等几个项目。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sdk.git&lt;/code&gt; is the project for all java based tools such as the SDK Manager, DDMS, and the Eclipse plug-ins.
&lt;code&gt;ndk.git&lt;/code&gt; is the project hosting the Android NDK source files.
&lt;code&gt;external/qemu.git&lt;/code&gt; is the project for our qemu-based emulator.&lt;/p&gt;

&lt;p&gt;sdk.git项目是一个核心项目，大部分基于Java开发的工具都在这个项目里面，包含了ddms，hierarchyviewer，lint，traceview等工具，其中的eclipse目录是android device monitor的工具的源码，包含了各种插件，例如ddms，traceview，hierarchyviewer等。&lt;/p&gt;

&lt;p&gt;sdk.git项目根目录下的&lt;a href=&#34;http://androidxref.com/7.0.0_r1/xref/sdk/&#34;&gt;README文档&lt;/a&gt;的主要内容是关于sdk.git这个项目的变化以及使用需知&lt;br /&gt;
其中解答了几个重要的问题，例如如何只构建某个单独的工具？如何修改工具源码来构建一个新的sdk？&lt;br /&gt;
(1)I don&amp;rsquo;t build full SDKs but I want to change tool X&lt;br /&gt;
(2)How do I change some tools sources and build a new SDK using these?&lt;/p&gt;

&lt;p&gt;文档&lt;a href=&#34;http://tools.android.com/build&#34;&gt;http://tools.android.com/build&lt;/a&gt;中给出了编译sdk的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./tools/buildSrc/servers/build_tools.sh `pwd`/out `pwd`/out/dist 1234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到&lt;code&gt;Required ANDROID_HOME environment variable not set.&lt;/code&gt;这个错误只需设置ANDROID_HOME这个环境变量即可&lt;/p&gt;

&lt;h3 id=&#34;2-下载地址&#34;&gt;2.下载地址&lt;/h3&gt;

&lt;p&gt;android studio代码也可以通过repo来下载，分支可以使用master-dev或者某个具体版本对应的分支，下载之后大约占用4GB左右磁盘空间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repo init -u https://android.googlesource.com/platform/manifest -b studio-2.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-编译源码&#34;&gt;3.编译源码&lt;/h3&gt;

&lt;p&gt;3.1 使用ant&lt;br /&gt;
最简单的编译运行方式是在tools/idea目录下执行&lt;code&gt;ant&lt;/code&gt;，最终会在tools/idea/out/中生成可运行的Android Studio应用程序&lt;/p&gt;

&lt;p&gt;3.2 使用Intellij (推荐)&lt;br /&gt;
tools/idea目录下的README.md文档说明了如何编译Android Studio源码&lt;br /&gt;
(1)下载Intellij Community版本并安装&lt;br /&gt;
(2)使用IDEA打开项目的tools/idea目录&lt;br /&gt;
(3)在Project Structure的SDKs中新建名为&lt;code&gt;IDEA jdk&lt;/code&gt;的jdk，路径设置为jdk 6的根目录&lt;br /&gt;
如果是在Linux/Mac上运行的话，还需要将&lt;JDK_HOME&gt;/lib/tools.jar添加到&lt;code&gt;IDEA jdk&lt;/code&gt;中&lt;br /&gt;
(4)在Project Structure的SDKs中新建名为&lt;code&gt;1.8&lt;/code&gt;的jdk，路径设置为jdk 8的根目录&lt;br /&gt;
(5)点击Build下的&lt;code&gt;Make Project&lt;/code&gt;来编译项目源码&lt;br /&gt;
(6)选择&lt;code&gt;IDEA&lt;/code&gt;这个运行配置来运行或者调试代码&lt;/p&gt;

&lt;p&gt;运行起来就可以看到AS第一次安装时选择settings的界面，然后就进入到启动界面了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/as_run.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果遇到&lt;code&gt;java: package com.sun.source.tree does not exist&lt;/code&gt;这个错误的话记得检查是否已经将&lt;code&gt;&amp;lt;JDK_HOME&amp;gt;/lib/tools.jar&lt;/code&gt;添加到IDEA jdk中&lt;/p&gt;

&lt;p&gt;下面是README.md文档的原文，其中第一步执行tools/idea目录下的&lt;code&gt;getPlugins.sh&lt;/code&gt;脚本，它会去下载两个repository，但是&lt;strong&gt;这个步骤在我这里一直没能成功，两个git项目能访问但是网络连接很慢源码下载不下来&lt;/strong&gt;，不过幸运的是这个步骤对后面的操作貌似并没有影响。&lt;br /&gt;
&lt;code&gt;git clone git://git.jetbrains.org/idea/android.git android&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;git clone git://git.jetbrains.org/idea/adt-tools-base.git android/tools-base&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Building and Running from the IDE&lt;/strong&gt;&lt;br /&gt;
To develop IntelliJ IDEA, you can use either IntelliJ IDEA Community Edition or IntelliJ IDEA Ultimate not older than 15.0.   To build and run the code:&lt;br /&gt;
- Run getPlugins.sh / getPlugins.bat from the project root directory to check out additional modules.&lt;br /&gt;
- If this git repository is not on &amp;lsquo;master&amp;rsquo; branch you need to checkout the same branches/tags in android and android/tools-base git repositories.&lt;br /&gt;
- Open the project.&lt;br /&gt;
- If an error notification about a missing required plugin (e.g. Kotlin) is shown enable or install that plugin.&lt;br /&gt;
- Configure a JDK named &amp;ldquo;IDEA jdk&amp;rdquo; (case sensitive), pointing to an installation of JDK 1.6.&lt;br /&gt;
- Unless you&amp;rsquo;re running on a Mac with an Apple JDK, add &lt;JDK_HOME&gt;/lib/tools.jar to the set of &amp;ldquo;IDEA jdk&amp;rdquo; jars.&lt;br /&gt;
- Configure a JDK named &amp;ldquo;1.8&amp;rdquo;, pointing to an installation of JDK 1.8.&lt;br /&gt;
- Add &lt;JDK_18_HOME&gt;/lib/tools.jar to the set of &amp;ldquo;1.8&amp;rdquo; jars.&lt;br /&gt;
- Use Build | Make Project to build the code.&lt;br /&gt;
- To run the code, use the provided shared run configuration &amp;ldquo;IDEA&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;4-其他参考资料&#34;&gt;4.其他参考资料&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://tools.android.com/build/studio&#34;&gt;Build Android Studio&lt;/a&gt;&lt;br /&gt;
(2) hierarchyviewer工具的学习，从使用到源码实现&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/vowei/archive/2012/07/30/2614353.html&#34;&gt;http://www.cnblogs.com/vowei/archive/2012/07/30/2614353.html&lt;/a&gt;
&lt;a href=&#34;http://www.cnblogs.com/vowei/archive/2012/08/03/2618753.html&#34;&gt;http://www.cnblogs.com/vowei/archive/2012/08/03/2618753.html&lt;/a&gt;
&lt;a href=&#34;http://www.cnblogs.com/vowei/archive/2012/08/08/2627614.html&#34;&gt;http://www.cnblogs.com/vowei/archive/2012/08/08/2627614.html&lt;/a&gt;
&lt;a href=&#34;http://www.cnblogs.com/vowei/archive/2012/08/22/2650722.html&#34;&gt;http://www.cnblogs.com/vowei/archive/2012/08/22/2650722.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to get performance data in Android</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/10/16/how-to-get-performance-data-in-android/</link>
      <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/10/16/how-to-get-performance-data-in-android/</guid>
      <description>

&lt;p&gt;本文记录下在Android平台上如何获取那些系统性能相关的数据。&lt;/p&gt;

&lt;h5 id=&#34;1-cpu平均负载&#34;&gt;1. CPU平均负载&lt;/h5&gt;

&lt;p&gt;读取文件节点&lt;code&gt;/proc/loadavg&lt;/code&gt;，分别是1min/5min/15min内CPU的负载情况。&lt;br /&gt;
读取方式的代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final int[] LOAD_AVERAGE_FORMAT = new int[]{
       PROC_SPACE_TERM | PROC_OUT_FLOAT,                 // 0: 1 min
       PROC_SPACE_TERM | PROC_OUT_FLOAT,                 // 1: 5 mins
       PROC_SPACE_TERM | PROC_OUT_FLOAT                  // 2: 15 mins
};

public float mLoad1 = 0;
public float mLoad5 = 0;
public float mLoad15 = 0;
private final float[] mLoadAverageData = new float[3];

private void getLoadAverage() {
   final float[] loadAverages = mLoadAverageData;
   if (Process.readProcFile(FILE_PORC_LOAD, LOAD_AVERAGE_FORMAT, null, null, loadAverages)) {
       float load1 = loadAverages[0];
       float load5 = loadAverages[1];
       float load15 = loadAverages[2];
       if (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) {
           mLoad1 = load1;
           mLoad5 = load5;
           mLoad15 = load15;
       }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-cpu的频率&#34;&gt;2. CPU的频率&lt;/h5&gt;

&lt;p&gt;CPU的核数：统计 &lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt; 目录下名称以&lt;code&gt;cpu&lt;/code&gt;开始的文件夹的数目&lt;br /&gt;
正在工作的核： &lt;code&gt;/sys/devices/system/cpu/online&lt;/code&gt;&lt;br /&gt;
注意：可能是&lt;code&gt;1-4&lt;/code&gt;或者&lt;code&gt;2,3&lt;/code&gt;或者&lt;code&gt;1-3,5-7&lt;/code&gt;等各种组合形式&lt;br /&gt;
正在工作的核的频率，例如cpu0的频率节点： &lt;code&gt;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-内存碎片化程度&#34;&gt;3. 内存碎片化程度&lt;/h5&gt;

&lt;p&gt;文件节点：&lt;code&gt;/sys/kernel/debug/extfrag/unusable_index&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /sys/kernel/debug/extfrag/unusable_index                      
Node 0, zone      DMA 0.000 0.802 0.894 0.971 0.985 0.995 1.000 1.000 1.000 1.000 1.000
Node 0, zone  Movable 0.000 0.000 0.000 0.000 0.002 0.003 0.003 0.003 0.004 0.006 0.006
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;(1)zone的个数不确定，名称也不确定&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;(2)先计算单个zone的平均值，再计算zone的整体平均内存碎片化程度&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;https://chengyihe.wordpress.com/2015/11/28/kernel-mm-syskerneldebugextfragunusable_index/&#34;&gt;https://chengyihe.wordpress.com/2015/11/28/kernel-mm-syskerneldebugextfragunusable_index/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;4-虚拟内存信息&#34;&gt;4. 虚拟内存信息&lt;/h5&gt;

&lt;p&gt;vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写, 是实时系统监控工具。vmstat结果中r,b,in,cs是通过 &lt;code&gt;/proc/stat&lt;/code&gt; 文件计算得到的，si,so,bi,bo是通过 &lt;code&gt;/proc/vmstat&lt;/code&gt; 文件计算得到的。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;/proc/vmstat&lt;/code&gt; 文件中 pgpgin,pgpgout,pswpin,pswpout等值的单位是page，而vmstat命令返回的结果的单位是kb，所以需要进行单位转换，一般情况下，一页的大小是4KB。除此之外，时间间隔是从&lt;code&gt;/proc/uptime&lt;/code&gt;中读取计算出的差值，该文件中保存的是系统从启动到当前时刻的时间，单位是秒。&lt;/p&gt;

&lt;p&gt;关于中断in：vmstat命令的返回的in值指的是CPU在软中断上占用的时间差值，而不是中断数的差值。如果计算后者的话，可以从&lt;code&gt;/proc/stat&lt;/code&gt;的intr中读取从系统启动到当前时刻总共发生的中断数来计算差值。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html&#34;&gt;vmstat命令详解&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-内存信息&#34;&gt;5. 内存信息&lt;/h5&gt;

&lt;p&gt;文件节点：&lt;code&gt;/proc/meminfo&lt;/code&gt;，统计得到total, used, free, cached, buffers, active, inactive, swap total, swap free&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /proc/meminfo
MemTotal:        2808452 kB
MemFree:          535824 kB
MemAvailable:     775404 kB
Buffers:           21840 kB
Cached:           302588 kB
SwapCached:        18792 kB
Active:           668900 kB
Inactive:         313524 kB
Active(anon):     511716 kB
Inactive(anon):   169452 kB
Active(file):     157184 kB
Inactive(file):   144072 kB
Unevictable:        4176 kB
Mlocked:               0 kB
SwapTotal:       1404224 kB
SwapFree:        1153856 kB
Dirty:                 4 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;1.swap cached 不等于 swap used, swap used = swap total - swap free&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;2.Memory Free = MemFree + Cached + Buffers&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;3.Memory Used = Memory Total - Memory Free&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://www.cnblogs.com/zhaoyl/p/3695517.html&#34;&gt;linux内存管理原理&lt;/a&gt; &lt;a href=&#34;http://linuxperf.com/?p=32&#34;&gt;buffers和cached的区别&lt;/a&gt; &lt;a href=&#34;http://linuxperf.com/?p=97&#34;&gt;active和inactive的区别&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;6-cpu被占用的情况&#34;&gt;6. CPU被占用的情况&lt;/h5&gt;

&lt;p&gt;CPU被占用的时间比数据的文件节点：&lt;code&gt;/proc/stat&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /proc/stat
cpu  229649 59778 316872 3688440 3308 6 357 0 0 0
cpu0 111250 7718 210302 3466017 764 6 209 0 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jiffies是内核中的一个全局变量，用来记录自系统启动一来产生的节拍数。在linux中，一个节拍大致可理解为操作系统进程调度的最小时间片，不同linux内核可能值有不同，通常在1ms到10ms之间。&lt;/p&gt;

&lt;p&gt;user (229649) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies），不包含nice值为负的进程&lt;br /&gt;
nice (59778) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）&lt;br /&gt;
system (316872) 从系统启动开始累计到当前时刻，核心系统进程占用的时间（单位：jiffies）&lt;br /&gt;
idle (3688440) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）&lt;br /&gt;
iowait (3308) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies）&lt;br /&gt;
irq (6) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）&lt;br /&gt;
softirq (357) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）&lt;/p&gt;

&lt;p&gt;上面结果中的后面三个数据在Android中不统计，所以&lt;br /&gt;
&lt;code&gt;total = user + nice + system + idle + iowait + irq + softirq&lt;/code&gt;&lt;br /&gt;
百分比的计算方式一般是：&lt;br /&gt;
&lt;code&gt;USER%=(user+nice)/total，SYS%=system/total，IOW%=iowait/total，IRQ%=(irq+softirq)/total&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://www.cnblogs.com/yjf512/p/3383915.html&#34;&gt;cpu被占用的时间比信息详解&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;7-进程-线程的占用信息&#34;&gt;7. 进程/线程的占用信息&lt;/h5&gt;

&lt;p&gt;进程数据文件的节点： &lt;code&gt;/proc/[pid]&lt;/code&gt;&lt;br /&gt;
线程数据文件的节点： &lt;code&gt;/proc/[pid]/task/[tid]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;进程和线程的状态信息从&lt;code&gt;stat&lt;/code&gt;文件中获取，名称从&lt;code&gt;cmdline&lt;/code&gt;文件中获取，cpuset从&lt;code&gt;cpuset&lt;/code&gt;文件中获取等。进程的&lt;code&gt;stat&lt;/code&gt;文件中保存了该进程的&lt;code&gt;user time&lt;/code&gt;和&lt;code&gt;system time&lt;/code&gt;，两者之和可以用来对进程进行排序，一般进程和线程的排序方式都是按照它们占用的CPU时长来排序的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(1)Process.getPids方法既可以用来获取某个目录下的所有进程数组，也可以用来获取某个进程的task目录下的所有线程数组&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;(2)Process.getPss方法可以用来统计进程的pss数据，但是很多进程的pss数据都没法获取到&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://blog.csdn.net/zjl_1026_2001/article/details/2294036&#34;&gt;关于/proc/pid/stat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;进程和线程部分的实现相对有点难度，一方面要统计系统所有的进程和线程的信息，另一方面要对它们进行排序。不过庆幸的是Android系统源码中有一个&lt;a href=&#34;http://androidxref.com/6.0.0_r1/xref/frameworks/base/packages/SystemUI/src/com/android/systemui/LoadAverageService.java&#34;&gt;&lt;code&gt;LoadAverageService&lt;/code&gt;&lt;/a&gt;，这个service也就是开发者选项中&lt;code&gt;显示CPU使用情况&lt;/code&gt;的内部实现，它的代码非常具有参考价值，我们可以在它的基础上进行扩展开发自己的工具。&lt;/p&gt;

&lt;p&gt;上面只是列举了部分常见的重要数据的获取方法，其他数据的获取方式也都差不多，主要是要知道当前平台的相应数据的文件节点，还需要注意的是是否具有文件的读权限。&lt;/p&gt;

&lt;p&gt;下图是我最近开发的悟空监视器，入口在Flyme系统的开发者选项中(公司内部项目，源码不能公开，仅供参考，原理同上)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/wukong.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ChromeADB Project Analysis</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/10/10/chromeadb-project-analysis/</link>
      <pubDate>Mon, 10 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/10/10/chromeadb-project-analysis/</guid>
      <description>

&lt;p&gt;本文记录的是chromeadb项目的源码阅读总结。&lt;/p&gt;

&lt;p&gt;chromeadb项目源码：&lt;a href=&#34;https://github.com/importre/chromeadb&#34;&gt;https://github.com/importre/chromeadb&lt;/a&gt;&lt;br /&gt;
chromeadb工具的本质就是利用adb命令以可视化的方式提供了一些简便操作和数据查看的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/chromeadb.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从该项目的目前提交记录以及&lt;a href=&#34;https://github.com/importre/chromeadb/issues/12&#34;&gt;issue&lt;/a&gt;来看，这个项目已经被放弃了，因为Google的Chrome浏览器未来将不支持Chrome扩展应用。此外，项目源码用的是Angular JS来开发的，我并不是很熟悉，所以主要是阅读下源码理解其大致的实现流程。要体验ChromeADB的MousePad功能还需要安装一个应用&lt;a href=&#34;https://github.com/importre/chromeadb_for_android&#34;&gt;chromeadb_for_android&lt;/a&gt;，这个应用我们也会稍微介绍一下。&lt;/p&gt;

&lt;h3 id=&#34;1-源码结构&#34;&gt;1.源码结构&lt;/h3&gt;

&lt;p&gt;1.1 项目根目录是package.json、Gruntfile.js、bower.json等相关说明和依赖管理文件；&lt;br /&gt;
1.2 test目录下是测试代码；&lt;br /&gt;
1.3 src目录下是核心源码，其中assets目录是资源文件夹，里面都是图片；styles目录是样式文件&lt;code&gt;chromeadb.css&lt;/code&gt;；views目录是各个子界面的模板页面，例如&lt;code&gt;packages.html&lt;/code&gt;、&lt;code&gt;controller.html&lt;/code&gt;等；scripts目录是控制脚本，例如&lt;code&gt;chromeadb.js&lt;/code&gt;、&lt;code&gt;controllers.js&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&#34;2-核心文件及代码分析&#34;&gt;2.核心文件及代码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2.1 index.html&lt;/strong&gt;&lt;br /&gt;
控制应用的主界面布局，界面顶部显示设备连接的操作，中间左侧显示设备列表和设备信息，中间右侧显示packages、processes、memory以及disk等信息，界面底部显示chromeadb的github地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;
    &amp;lt;ul class=&amp;quot;nav nav-pills nav-justified&amp;quot; id=&amp;quot;mytab&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;#packages&amp;quot; data-toggle=&amp;quot;tab&amp;quot;
               ng-click=&amp;quot;loadPackages(devInfo.serial);&amp;quot;&amp;gt;Packages&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;#controller&amp;quot; data-toggle=&amp;quot;tab&amp;quot;
               ng-click=&amp;quot;initMousePad(devInfo.serial);&amp;quot;&amp;gt;Controller&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;#processes&amp;quot; data-toggle=&amp;quot;tab&amp;quot;
               ng-click=&amp;quot;loadProcessList(devInfo.serial);&amp;quot;&amp;gt;Process List&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;#meminfo&amp;quot; data-toggle=&amp;quot;tab&amp;quot;
               ng-click=&amp;quot;loadMemInfo(devInfo.serial);&amp;quot;&amp;gt;App Memory Info&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;#diskspace&amp;quot; data-toggle=&amp;quot;tab&amp;quot;
               ng-click=&amp;quot;loadDiskSpace(devInfo.serial);&amp;quot;&amp;gt;Disk Space&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.2 utils.js&lt;/strong&gt;&lt;br /&gt;
定义一些通用的方法以供其他地方调用，例如services.js中就利用了这些方法来转换数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* exported arrayBufferToString */
/* exported arrayBufferToBinaryString */
/* exported stringToArrayBuffer */
/* exported newZeroArray */
/* exported getChartId */
/* exported integerToArrayBuffer */

function arrayBufferToString(buf, callback) {
  var b = new Blob([new Uint8Array(buf)]);
  var f = new FileReader();
  f.onload = function (e) {
    callback(e.target.result);
  };
  f.readAsText(b);
}

function arrayBufferToBinaryString(buf, callback) {
  var b = new Blob([new Uint8Array(buf)]);
  var f = new FileReader();
  f.onload = function (e) {
    callback(e.target.result);
  };
  f.readAsBinaryString(b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.3 background.js&lt;/strong&gt;&lt;br /&gt;
应用启动时的初始化，应用是从这里开始的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;chrome.app.runtime.onLaunched.addListener(function () {
  chrome.app.window.create(&#39;../index.html&#39;, {
    minWidth: 800,
    minHeight: 600,
    width: 1280,
    height: 800
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.4 chromeadb.js&lt;/strong&gt;&lt;br /&gt;
控制转发中心，点击不同的tab显示不同的html模板文件所在的界面，这里创建了chromeADB这个module。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var adb = angular.module(&#39;chromeADB&#39;, [&#39;ngRoute&#39;, &#39;ngSanitize&#39;]);

adb.config(function ($routeProvider) {//配置url路由控制转发
  $routeProvider
    .when(&#39;/&#39;, {
      redirectTo: &#39;/packages&#39;
    })
    .when(&#39;/packages&#39;, {
      templateUrl: chrome.runtime.getURL(&#39;../views/packages.html&#39;)
    })
    .when(&#39;/controller&#39;, {
      templateUrl: chrome.runtime.getURL(&#39;../views/controller.html&#39;)
    })
    .when(&#39;/processes&#39;, {
      templateUrl: chrome.runtime.getURL(&#39;../views/processes.html&#39;)
    })
    .when(&#39;/meminfo&#39;, {
      templateUrl: chrome.runtime.getURL(&#39;../views/meminfo.html&#39;)
    })
    .when(&#39;/diskspace&#39;, {
      templateUrl: chrome.runtime.getURL(&#39;../views/diskspace.html&#39;)
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.5  chrome.js&lt;/strong&gt;&lt;br /&gt;
主要有三个初始化方法，这里会初始化chrome.socket，后面的SocketService会用到。这里还初始化了初始化ChromeRuntime，这个在上面的路由转发中用到了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//initCmdToResp(); //三个初始化方法
//initChromeSocket(chrome);
//initChromeRuntime(chrome);

function initCmdToResp() {
  cmdToResp = {
    &#39;000ehost:devices-l&#39;: [&#39;OKAY&#39;, &#39;005B&#39;,
        &#39;048233d1d151e3cc device usb:1A120000 product:aosp_mako &#39; +
        &#39;model:AOSP_on_Mako device:mako&#39;],
    &#39;001fhost:transport:048233d1d151e3cc&#39;: [&#39;OKAY&#39;],
    &#39;0016shell:pm list packages&#39;: [&#39;OKAY&#39;,
      &#39;package:com.android.settings\npackage:com.android.musicfx&#39;],
    &#39;0015shell:dumpsys meminfo&#39;: [&#39;OKAY&#39;, &#39;OKAY&#39;,
        &#39;Applications Memory Usage (kB):\n&#39; +
        &#39;Uptime: 95848872 Realtime: 211090246\n\nTotal PSS by process:\n&#39; +
        &#39;71959 kB: com.google.android.googlequicksearchbox (pid 892 / activities)\n&#39; +
        &#39;71580 kB: com.android.chrome (pid 7876 / activities)&#39;]
  };
}

function initChromeSocket(chrome) {//初始化chrome.socket
  if (chrome.socket) {
    return;
  }

  chrome.socket = {
    create: function (type, options, callback) {
      var createInfo = {
        &#39;socketId&#39;: 10
      };

      window.setTimeout(function () {
        callback(createInfo);
      }, timeoutDelay);
    },

    destroy: function (socketId) {
    },

    connect: function (socketId, hostname, port, callback) {
      var result = 1;
      window.setTimeout(function () {
        callback(result);
      }, timeoutDelay);
    },

    read: function (socketId, bufferSize, callback) {
      window.setTimeout(function () {
        var resp = cmdToResp[curCmd];
        if (resp) {
          resp = cmdToResp[curCmd].splice(0, 1)[0];
        }
        if (typeof resp === &#39;undefined&#39;) {
          initCmdToResp();
        }
        stringToArrayBuffer(resp, function (bytes) {
          var readInfo = {
            &#39;resultCode&#39;: resp ? 1 : 0,
            &#39;data&#39;: bytes
          };
          callback(readInfo);
        });
      }, timeoutDelay);
    },

    write: function (socketId, data, callback) {
      curCmd = data;
      var writeInfo = {
        bytesWritten: data.length
      };
      window.setTimeout(function () {
        callback(writeInfo);
      }, timeoutDelay);
    }
  };

  window.arrayBufferToString = function (buf, callback) {
    callback(buf);
  };

  window.stringToArrayBuffer = function (str, callback) {
    callback(str);
  };
}

function initChromeRuntime(chrome) {//初始化ChromeRuntime
  if (!chrome.runtime) {
    return;
  }

  if (!chrome.runtime.getURL) {
    chrome.runtime.getURL = function (url) {
      return url;
    };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.6 parser.js&lt;/strong&gt;&lt;br /&gt;
主要是利用正则表达式来提供一些解析adb命令返回结果的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* exported parseProcessList */
/* exported parseDeviceInfoList */
/* exported parsePackageList */
/* exported makeCommand */
/* exported parseMemInfo */
/* exported parsePackageMemInfo */
/* exported parseDiskSpace */
/* exported parseResolution */

/**
 * Parses the result of $scope.loadPackages().
 *
 * @param data
 * @returns {Array}
 */
function parsePackageList(data) {//解析包列表
  var lines = data.trim().split(&#39;\n&#39;);

  for (var i = 0; i &amp;lt; lines.length; i++) {
    lines[i] = lines[i].replace(/^package:/, &#39;&#39;).trim();
  }

  return lines;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.7 services.js&lt;/strong&gt;&lt;br /&gt;
利用前面初始化好的chrome.socket来建立一个socketService，这个service负责和指定的host和port进行连接并提供数据读写服务的功能，这里的host和port是指adb-server的host和port，所以一般拿手机连接PC的话，这里host和port通常分别就是127.0.0.1和5037。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  function connect(createInfo, host, port) {//建立连接
    var defer = $q.defer();

    if (typeof port !== &#39;number&#39;) {
      port = parseInt(port, 10);
    }

    chrome.socket.connect(createInfo.socketId, host, port, function (result) {
      if (result &amp;gt;= 0) {
        $rootScope.$apply(function () {
          defer.resolve(createInfo);
        });
      } else {
        chrome.socket.destroy(createInfo.socketId);
        defer.reject(createInfo);
      }
    });

    return defer.promise;
  }

  function write(createInfo, str) {//写
    var defer = $q.defer();

    stringToArrayBuffer(str, function (bytes) {
      writeBytes(createInfo, bytes)
        .then(function (createInfo) {
          defer.resolve(createInfo);
        });
    });

    return defer.promise;
  }

  function read(createInfo, size) {//读
    var defer = $q.defer();

    chrome.socket.read(createInfo.socketId, size, function (readInfo) {
      if (readInfo.resultCode &amp;gt; 0) {
        // console.log(readInfo);
        arrayBufferToString(readInfo.data, function (str) {
          $rootScope.$apply(function () {
            var param = {
              createInfo: createInfo,
              data: str
            };
            defer.resolve(param);
          });
        });
      } else {
        defer.reject(readInfo);
      }
    });

    return defer.promise;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.8 controllers.js&lt;/strong&gt;&lt;br /&gt;
核心控制脚本&lt;/p&gt;

&lt;p&gt;2.8.1 loadDevices&lt;br /&gt;
命令：adb devices -l&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb devices -l
List of devices attached
8f9d6dd9   device usb:337641472X product:OnePlus3 model:ONEPLUS_A3000 device:OnePlus3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parseDeviceInfoList方法的作用就是从输出结果中解析出设备的序列号(serial)、usb、product、model、device、state等信息&lt;/p&gt;

&lt;p&gt;2.8.2 loadPackages&lt;br /&gt;
命令：adb shell pm list packages&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb shell pm list packages
package:com.oneplus.calculator
package:net.oneplus.weather
package:com.oneplus.GpioSwitch
package:com.qualcomm.qti.auth.sampleextauthservice
package:com.oneplus.market
package:com.android.providers.telephony
package:com.android.engineeringmode
package:com.android.providers.calendar
package:com.oneplus.opbugreport
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parsePackageList方法的作用就是从输出结果中解析出包的列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function parsePackageList(data) {
  var lines = data.trim().split(&#39;\n&#39;);

  for (var i = 0; i &amp;lt; lines.length; i++) {
    lines[i] = lines[i].replace(/^package:/, &#39;&#39;).trim();
  }

  return lines;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.8.3 其他与package相关的方法&lt;br /&gt;
installPackage：adb shell pm install -r &lt;package&gt;&lt;br /&gt;
uninstallPackage：adb shell pm uninstall &lt;package&gt;&lt;br /&gt;
stopPackage：adb shell am force-stop &lt;package&gt;&lt;br /&gt;
clearData：adb shell pm clear &lt;package&gt;&lt;br /&gt;
removeApkFile：adb shell rm -rf &lt;packagePath&gt;&lt;/p&gt;

&lt;p&gt;从源码来看，chromeadb实现应用安装的方法是先将apk文件保存到手机的&lt;code&gt;/data/local/tmp/&lt;/code&gt;目录，然后执行&lt;code&gt;adb shell pm install -r &amp;lt;packagePath&amp;gt;&lt;/code&gt;方法来安装应用的(这个操作步骤和Android Studio中安装apk的逻辑是一样的)。&lt;/p&gt;

&lt;p&gt;2.8.4 loadProcessList&lt;br /&gt;
命令：adb shell ps&lt;br /&gt;
parseProcessList方法用于从输出结果中解析出进程列表，Android 4.4版本之前和之后的输出结果的格式略有差异，所以需要两个不同的正则表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function parseProcessList(data) {
  // parse oldstyle ps result
  var ore = new RegExp(/^(\w+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+([a-fA-F0-9]+)\s+([a-fA-F0-9]+ \w)\s+(.+)/m);
  // parse 4.4 or above ps result
  var nre = new RegExp(/^(\d+)\s+(\d+)\s+(\d+m?)\s+(\w+\s*&amp;lt;?)\s+(.+)/m);
  var lines = data.trim().split(&#39;\n&#39;);
  var line;

  for (var i = 0; i &amp;lt; lines.length; i++) {
    line = lines[i].trim();
    if (0 === i) {
      line = line.trim().split(/\s+/);
    } else {
      var parsed = ore.exec(line);
      line = !!parsed ? parsed : nre.exec(line);
      line.splice(0, 1);
    }
    lines[i] = line;
  }
  return lines;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.8.5 loadMemInfo&lt;br /&gt;
命令：adb shell dumpsys meminfo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb shell dumpsys meminfo
Applications Memory Usage (kB):
Uptime: 46425131 Realtime: 178910170

Total PSS by process:
   113261 kB: com.oneplus.hydrogen.launcher (pid 2240 / activities)
   108423 kB: system (pid 1340)
   106778 kB: surfaceflinger (pid 487)
    99988 kB: com.android.systemui (pid 1803 / activities)
    94085 kB: org.tensorflow.demo (pid 5773 / activities)
    46489 kB: com.oneplus.card (pid 2572)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parseMemInfo方法用来解析进程的内存占用情况，主要是先找到&lt;code&gt;Total PSS by process&lt;/code&gt;这个标识，然后将后面的pid、processName、pss数据解析出来即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function parseMemInfo(data) {
  // \1: memory (kb)
  // \2: process name
  // \3: pid
  var re = new RegExp(/^(\d+)\s+kB:\s+(\S+)\s\(pid\s+(\d+).*/);
  var lines = data.trim().split(&#39;\n&#39;);
  var line;
  var pss = 0;
  var ret = [];

  for (var i = 0; i &amp;lt; lines.length; i++) {
    line = lines[i].trim();

    if (line.length === 0) {
      continue;
    }

    if (line.indexOf(&#39;Total PSS by process&#39;) &amp;gt;= 0) {
      pss++;
      continue;
    }

    if (pss === 1) {
      line = re.exec(line);
      if (line) {
        ret.push({
          process: line[2],
          pid: line[3],
          kb: line[1] + &#39; KB&#39;,
          mb: parseInt(parseFloat(line[1]) / 1024 + 0.5) + &#39; MB&#39;
        });
      } else {
        break;
      }
    }
  }
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令：adb shell dumpsys meminfo [pid/package]&lt;br /&gt;
带pid/package参数的dumpsys meminfo可以得到该进程的详细内存占用信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb shell dumpsys meminfo 2240
Applications Memory Usage (kB):
Uptime: 47043593 Realtime: 179528632

** MEMINFO in pid 2240 [com.oneplus.hydrogen.launcher] **
                   Pss  Private  Private  Swapped     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Native Heap    14274    14204        0        0    21248    18580     2667
  Dalvik Heap    59432    59408        0        0    67386    60326     7060
 Dalvik Other      801      800        0        0                           
        Stack      440      440        0        0                           
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个数据输出结果由parsePackageMemInfo这个方法来解析，它会去解析Native Heap和Dalvik Heap中&lt;code&gt;Size&lt;/code&gt;、&lt;code&gt;Alloc&lt;/code&gt;和&lt;code&gt;Free&lt;/code&gt;这几列的信息，chromeadb工具会这些数据来绘制曲线图！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function parsePackageMemInfo(data) {
  var lines = data.trim().split(&#39;\n&#39;);
  var line, tempLine, length;
  var ret = [];
  var cnt = 0;
  var found = false;
  var idxOfSize, idxOfAlloc, idxOfFree;

  for (var i = 0; i &amp;lt; lines.length; i++) {
    line = lines[i].trim();
    tempLine = line.split(/\s+/);
    length = tempLine.length;

    if (!found) {
      idxOfSize = tempLine.indexOf(&#39;Size&#39;);
      idxOfAlloc = tempLine.indexOf(&#39;Alloc&#39;);
      idxOfFree = tempLine.indexOf(&#39;Free&#39;);

      if (idxOfSize &amp;gt;= 0 &amp;amp;&amp;amp; idxOfAlloc &amp;gt;= 0 &amp;amp;&amp;amp; idxOfFree &amp;gt;= 0) {
        idxOfSize = length - idxOfSize;
        idxOfAlloc = length - idxOfAlloc;
        idxOfFree = length - idxOfFree;
        found = true;
        continue;
      }
    }

    if (found &amp;amp;&amp;amp; (tempLine[0] === &#39;Native&#39; || tempLine[0] === &#39;Dalvik&#39;)) {
      ret.push({
        area: tempLine[0],
        size: tempLine[length - idxOfSize],
        alloc: tempLine[length - idxOfAlloc],
        free: tempLine[length - idxOfFree]
      });
      cnt++;
    }

    if (cnt &amp;gt;= 2) {
      break;
    }
  }
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;曲线图示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/chromeadb_chart.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.8.6 loadDiskSpace&lt;br /&gt;
命令：adb shell df&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb shell df
Filesystem               Size     Used     Free   Blksize
/                        2.7G     4.7M     2.7G   4096
/dev                     2.8G   124.0K     2.8G   4096
/sys/fs/cgroup           2.8G    12.0K     2.8G   4096
/mnt                     2.8G     0.0K     2.8G   4096
/system                  2.8G     1.9G   906.7M   4096
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析输出结果的parseDiskSpace方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function parseDiskSpace(data) {
  var lines = data.trim().split(&#39;\n&#39;);
  var line, head, body = [];

  for (var i = 0; i &amp;lt; lines.length; i++) {
    line = lines[i].trim().split(/\s+/);
    if (i === 0) {
      head = line;
    } else {
      body.push(line);
    }
  }
  return {head: head, body: body};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.8.7 controller面板下的操作&lt;br /&gt;
sendText：adb shell input text &lt;text&gt;&lt;br /&gt;
onClickButton：adb shell input keyevent &lt;keyCode&gt;&lt;/p&gt;

&lt;p&gt;chromeadb在controller面板中还有一个MousePad功能，但是这个功能需要先在手机上安装chromeadb_for_android应用。&lt;a href=&#34;https://github.com/importre/chromeadb_for_android&#34;&gt;ChromeADB for Android这个应用的源码地址&lt;/a&gt;，这个项目创建于2年前，可能不太好编译，建议直接创建新项目然后拷贝源码过来进行编译。&lt;/p&gt;

&lt;p&gt;应用安装完成之后，刷新Controller面板可以发现MousePad中出现了黑色的面板，在面板中移动鼠标的话可以同时看到在手机界面上对应的移动位置，如下图所示 （应用需要悬浮窗权限，所以需要给该应用开启该权限）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/chromeadb_mousepad_controller.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-chromeadb-for-android应用源码分析&#34;&gt;3.chromeadb_for_android应用源码分析&lt;/h3&gt;

&lt;p&gt;从chromeadb的源码来看，chromeadb会启动这个应用中的ChromeAdbService，然后实现各种移动和点击操作，所以ChromeAdbService是该应用的核心。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ChromeAdbService extends Service implements TailerListener {

    private File mEventFile = new File(&amp;quot;/sdcard/chromeadb.event&amp;quot;);//监听这个事件文件
    private ImageView mCursorImage;//指针imageview
    private String mPrevLine;//上次读取的文件中那一行字符串
    private Tailer mTailer;//用于监听指定事件文件的Tailer(跟踪者)
    private WindowManager mWindowManager;
    private WindowManager.LayoutParams mLayoutParam;

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        startTailer();
        addMouseCursor();
        setCursorPosToCenter();
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        stopTailer();
        removeMouseCursor();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    private void addMouseCursor() {//添加鼠标指针imageview到window上
        if (mCursorImage == null) {
            mCursorImage = new ImageView(this);
            mCursorImage.setImageResource(R.drawable.cursor);
        }

        if (mLayoutParam == null) {
            mLayoutParam = new WindowManager.LayoutParams(
                    WindowManager.LayoutParams.WRAP_CONTENT,
                    WindowManager.LayoutParams.WRAP_CONTENT,
                    WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY,
                    WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
                            | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
                    PixelFormat.TRANSLUCENT);
            mLayoutParam.gravity = Gravity.LEFT | Gravity.TOP;
            mLayoutParam.flags |= WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
        }

        if (mWindowManager == null) {
            mWindowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
            mWindowManager.addView(mCursorImage, mLayoutParam);
        }
    }

    @SuppressLint(&amp;quot;NewApi&amp;quot;)
    private void setCursorPosToCenter() {//初始化的时候将指针移动到中央
        if (mWindowManager == null || mCursorImage == null) {
            return;
        }

        Display display = mWindowManager.getDefaultDisplay();
        int x, y;

        if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.HONEYCOMB_MR2) {
            Point size = new Point();
            display.getSize(size);
            x = size.x;
            y = size.y;
        } else {
            x = display.getWidth();
            y = display.getHeight();
        }

        move(x &amp;gt;&amp;gt; 1, y &amp;gt;&amp;gt; 1);
    }

    private void removeMouseCursor() {//删除指针imageview
        if (mCursorImage != null &amp;amp;&amp;amp; mWindowManager != null) {
            mWindowManager.removeView(mCursorImage);
            mCursorImage = null;
        }
    }

    public void move(int touchX, int touchY) {//移动指针到指定的x,y坐标位置
        if (mLayoutParam == null || mWindowManager == null || mCursorImage == null) {
            return;
        }

        mLayoutParam.x = touchX;
        mLayoutParam.y = touchY;
        mWindowManager.updateViewLayout(mCursorImage, mLayoutParam);
    }

    private void startTailer() {//开始监听事件文件
        try {
            if (mEventFile.exists()) {
                mEventFile.delete();
            }
            mEventFile.createNewFile();
        } catch (IOException e) {
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();
            return;
        }

        if (mTailer != null) {
            mTailer.stop();
        }

        //这部分代码可以改成直接使用Tailer的create方法来创建Tailer
        mTailer = new Tailer(mEventFile, this, 10, true);
        Thread thread = new Thread(mTailer);
        thread.start();
    }

    private void stopTailer() {//停止监听事件文件
        if (mTailer != null) {
            mTailer.stop();
            mTailer = null;
        }

        if (mEventFile != null &amp;amp;&amp;amp; mEventFile.exists()) {
            mEventFile.delete();
        }
    }

    @Override
    public void init(Tailer tailer) {
    }

    @Override
    public void fileNotFound() {
        mTailer.stop();
    }

    @Override
    public void fileRotated() {
    }

    @Override
    public void handle(String s) {
        //TailerListener接口的回调，当事件文件发生变化的时候，这个方法会回调
        if (mPrevLine != null &amp;amp;&amp;amp; mPrevLine.equals(s)) {
            return;
        }

        String coords = Command.getCoordinates(s);
        if (coords != null) {
            moveCursor(coords);
        }

        mPrevLine = s;
    }

    private void moveCursor(String coords) {//根据解析得到的新坐标位置来移动指针
        try {
            final String[] points = coords.split(&amp;quot;,&amp;quot;);
            for (int i = 0; i &amp;lt; points.length; i += 2) {
                int x = Integer.parseInt(points[i]);
                int y = Integer.parseInt(points[i + 1]);
                Message msg = mHandler.obtainMessage();
                Bundle data = new Bundle();
                data.putInt(&amp;quot;x&amp;quot;, x);
                data.putInt(&amp;quot;y&amp;quot;, y);
                msg.setData(data);
                mHandler.sendMessage(msg);
            }
        } catch (Exception e) {
        }
    }

    private final Handler mHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            Bundle data = msg.getData();
            if (data != null) {
                int x = data.getInt(&amp;quot;x&amp;quot;, 0);
                int y = data.getInt(&amp;quot;y&amp;quot;, 0);
                move(x, y);
            }
        }
    };

    @Override
    public void handle(Exception e) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chromeadb_for_android应用的代码看起来很简单，那么chromeadb是如何将坐标发送到事件文件中的呢？其实就是执行类似下面的命令&lt;code&gt;adb shell echo move 522,1108,530,1108 &amp;gt;&amp;gt; /sdcard/chromeadb.event&lt;/code&gt;而已。ChromeAdbService这个服务会监听那个文件的变化，一旦有新的数据过来了就会解析参数执行相应的命令。&lt;/p&gt;

&lt;h3 id=&#34;4-与adbserver通信的秘密&#34;&gt;4.与adbserver通信的秘密&lt;/h3&gt;

&lt;p&gt;通过前面的分析我们知道了chromeadb实际上是连接adbserver，将命令通过socket发送给adbserver，然后adbserver去执行命令并返回结果给chromeadb。那通过socket发送的是什么内容呢？&lt;/p&gt;

&lt;p&gt;parse.js文件中有一个很重要的方法&lt;code&gt;makeCommand&lt;/code&gt;，这个方法用来构造发送的数据，从方法内容来看就是在命令的前面填充4位十六进制形式的数字，表示命令的总长度，方便server那边解析。例如想要发送&lt;code&gt;shell:dumpsys snowden&lt;/code&gt;命令，那么实际发送的数据是&lt;code&gt;0015shell:dumpsys snowden&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function makeCommand(cmd) {
  var hex = cmd.length.toString(16);//先计算命令长度对应的十六进制
  while (hex.length &amp;lt; 4) {//前面不足四位的话补0
    hex = &#39;0&#39; + hex;
  }
  cmd = hex + cmd;
  return cmd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那adbserver那边返回的数据又是什么形式的呢？从controllers.js文件中的&lt;code&gt;getReadAllPromise&lt;/code&gt;方法我们可以大致看出返回结果的结构，一般先是&lt;code&gt;OKAY&lt;/code&gt;，然后是返回结果的长度，最后是返回结果的内容。例如发送&lt;code&gt;000ehost:devices-l&lt;/code&gt;，得到的结果是&lt;code&gt;OKAY0054M96GAEP9PT63B          device usb:337641472X product:m9690 model:m9690 device:m9690&lt;/code&gt;，也就是当前有一个设备，序列号是&lt;code&gt;M96GAEP9PT63B&lt;/code&gt;，后面内容是它的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$scope.getNewCommandPromise = function (cmd) {
  return socketService.create()
    .then(function (createInfo) {
      return socketService.connect(createInfo, $scope.host, $scope.port);
    })
    .then(function (createInfo) {
      var cmdWidthLength = makeCommand(cmd);
      console.log(&#39;command:&#39;, cmdWidthLength);//hujiawei
      return socketService.write(createInfo, cmdWidthLength);
    })
    .then(function (param) {
      return socketService.read(param.createInfo, 4);//前四个字节 OKEY
    })
    .catch(function (param) {
      $scope.initVariables();
      $scope.logMessage = {
        cmd: &#39;Connection Error&#39;,
        res: &#39;run \&amp;quot;$ adb start-server\&amp;quot;&#39;
      };
    });
};

$scope.getCommandPromise = function (cmd, createInfo) {
  var cmdWidthLength = makeCommand(cmd);
  console.log(&#39;command:&#39;, cmdWidthLength);//hujiawei
  return socketService.write(createInfo, cmdWidthLength)
    .then(function (param) {
      return socketService.read(param.createInfo, 4);
    });
};

//先执行命令1，再执行命令2，都成功的话读取所有数据
$scope.getReadAllPromise = function (cmd1, cmd2) {
  return $scope.getNewCommandPromise(cmd1)
    .then(function (param) {
      //console.log(param);
      if (param.data === &#39;OKAY&#39;) {//成功执行命令1
        return $scope.getCommandPromise(cmd2, param.createInfo);
      }
    })
    .then(function (param) {
      //console.log(param);
      if (param &amp;amp;&amp;amp; param.data === &#39;OKAY&#39;) {//成功执行命令2
        return socketService.readAll(param.createInfo, arrayBufferToString);
      }
    })
    .catch(function (param) {
      $scope.initVariables();
      $scope.logMessage = {
        cmd: &#39;Connection Error&#39;,
        res: &#39;Cannot find any devices&#39;
      };
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用下面的代码来验证这个与adbserver通信方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Snowden {

    public static void main(String[] args) {
        try {

            Socket socket = new Socket();
            SocketAddress remoteAddr = new InetSocketAddress(&amp;quot;localhost&amp;quot;, 5037);
            socket.connect(remoteAddr, 60000);

            OutputStream os = socket.getOutputStream();
            InputStream is = socket.getInputStream();

            os.write(&amp;quot;000ehost:devices-l&amp;quot;.getBytes());
            //os.write(&amp;quot;001chost:transport:M96GAEP9PT63B&amp;quot;.getBytes());
            //os.write(&amp;quot;0015shell:dumpsys snowden&amp;quot;.getBytes());//OKAYOKAYCan&#39;t find service: snowden

            String line = null;
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
                //&amp;quot;OKAY0054M96GAEP9PT63B          device usb:337641472X product:m9690 model:m9690 device:m9690&amp;quot;;
            }

            is.close();
            os.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-总结&#34;&gt;5.总结&lt;/h3&gt;

&lt;p&gt;虽然chromeadb工具的功能有限而且未来可能真的不会再有新的进展，但是利用当前这个版本进行扩展使用更多有用的功能还是非常方便的，例如我最近利用之前开发的手机版本的悟空监视器改造了一个新的斯诺登监视器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/SnowdenMonitor.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pury Project Analysis</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/10/09/pury-project-analysis/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/10/09/pury-project-analysis/</guid>
      <description>&lt;p&gt;本文总结下对Android平台的性能分析工具Pury的源码分析。&lt;/p&gt;

&lt;p&gt;Pury的源码：&lt;a href=&#34;https://github.com/NikitaKozlov/Pury&#34;&gt;https://github.com/NikitaKozlov/Pury&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pury is a profiling library for measuring time between multiple independent events. Events can be triggered with one of the annotations or with a method call. All events for a single scenario are united into one report.&lt;/p&gt;

&lt;p&gt;感兴趣的话可以先阅读&lt;a href=&#34;https://medium.com/@nikita.kozlov/pury-new-way-to-profile-your-android-application-7e248b5f615e#.oozl48dch&#34;&gt;关于Pury作者为啥开发Pury的介绍&lt;/a&gt;，最精彩的是关于Pury的内部设计架构和它的局限性的介绍：&lt;/p&gt;

&lt;p&gt;Performance measurements are done by &lt;code&gt;Profilers&lt;/code&gt;. Each &lt;code&gt;Profiler&lt;/code&gt; contains a list of &lt;code&gt;Runs&lt;/code&gt;. Multiple &lt;code&gt;Profilers&lt;/code&gt; can work in parallel, but only a single &lt;code&gt;Run&lt;/code&gt; per each &lt;code&gt;Profiler&lt;/code&gt; can be active. Once all &lt;code&gt;Runs&lt;/code&gt; in a single &lt;code&gt;Profiler&lt;/code&gt; are finished, result is reported. Amount of runs defines by &lt;code&gt;runsCounter&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Run&lt;/code&gt; has a root &lt;code&gt;Stage&lt;/code&gt; inside. Each &lt;code&gt;Stage&lt;/code&gt; has a name, an order number and an arbitrary amount of nested &lt;code&gt;Stages&lt;/code&gt;. &lt;code&gt;Stage&lt;/code&gt; can have only one active nested &lt;code&gt;Stage&lt;/code&gt;. If you stop a parent &lt;code&gt;Stage&lt;/code&gt;, then all nested &lt;code&gt;Stages&lt;/code&gt; are also stopped.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/pury.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以下是我的源码阅读总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 源码结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.1 annotations：纯Java应用，已发布到maven上，名称是pury-annotations，其中主要是定义了&lt;code&gt;MethodProfiling&lt;/code&gt;，&lt;code&gt;StartProfiling&lt;/code&gt;和&lt;code&gt;StopProfiling&lt;/code&gt;三个注解&lt;/p&gt;

&lt;p&gt;1.2 pury：核心工程，依赖了annotations和aspectj，已发布到maven上，名称是pury&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;com.nikitakozlov.pury:annotations:1.0.1&#39;
compile &#39;org.aspectj:aspectjrt:1.8.6&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.3 example：应用示例，依赖了pury，演示了几个场景下的几个方法的监控示例&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 使用方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注解形式所支持的5个参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;profilerName&lt;/code&gt; — name of the profiler is displayed in the result. Along with runsCounter identifies the Profiler.
&lt;code&gt;runsCounter&lt;/code&gt; — amount of runs for Profiler to wait for. Result is available only after all runs are stopped.
&lt;code&gt;stageName&lt;/code&gt; — identifies a stage to start. Name is displayed in the result.
&lt;code&gt;stageOrder&lt;/code&gt; — stage order reflects the hierarchy of stages. In order to start a new stage, it must be bigger then order of current most nested active stage. Stage order is a subject to one more limitation: first start event must have order number equal zero.
&lt;code&gt;enabled&lt;/code&gt; — if set to false, an annotation is skipped.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Profiler is identified by combination of profilerName and runsCounter&lt;/code&gt;. So if you are using same profilerName, but different runsCounter, then you will get two separate results, instead of a combined one.&lt;/p&gt;

&lt;p&gt;profiler对应一个需要监控的场景，runsCounter是指监控场景需要执行的次数
stage对应这个场景下需要监控的方法，stageOrder是指监控方法的对应层级
&lt;strong&gt;需要注意的是Profiler是由profilerName和runsCounter两个共同决定的，也就是说如果profilerName相同但是runsCounter不同的话是两个不同的监控场景，最终会得到两个独立的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面是一个采用注解的方式实现监控的例子，它监控了数据加载这个事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@StartProfiling(profilerName = StartApp.PROFILER_NAME, stageName = StartApp.SPLASH_LOAD_DATA,
        stageOrder = StartApp.SPLASH_LOAD_DATA_ORDER)
private void loadData() {
    new Handler(Looper.getMainLooper()).postDelayed(new Runnable() {

        @Override
        public void run() {
            onDataLoaded();
            startMainActivity();
        }
    }, 1000);
}

@StopProfiling(profilerName = StartApp.PROFILER_NAME, stageName = StartApp.SPLASH_SCREEN)
private void onDataLoaded() {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;监控App Start场景下的方法调用时长的输出示例，它表示监控的场景名(ProfilerName)是&lt;code&gt;App Start&lt;/code&gt;，这个场景总共耗时1182ms，这个场景下有6个stage，分别是&lt;code&gt;App Start&lt;/code&gt;、&lt;code&gt;Splash Screen&lt;/code&gt;、&lt;code&gt;Splash Load Data&lt;/code&gt;、&lt;code&gt;Main Activity Launch&lt;/code&gt;、&lt;code&gt;onCreate()&lt;/code&gt;和&lt;code&gt;onStart()&lt;/code&gt;，下面的输出显示了每个stage的运行时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Profiling results for App Start:
App Start --&amp;gt; 0ms
  Splash Screen --&amp;gt; 5ms
    Splash Load Data --&amp;gt; 37ms
    Splash Load Data &amp;lt;-- 1042ms, execution = 1005ms
  Splash Screen &amp;lt;-- 1042ms, execution = 1037ms
  Main Activity Launch --&amp;gt; 1043ms 
    onCreate() --&amp;gt; 1077ms 
    onCreate() &amp;lt;-- 1100ms, execution = 23ms
    onStart() --&amp;gt; 1101ms 
    onStart() &amp;lt;-- 1131ms, execution = 30ms
  Main Activity Launch &amp;lt;-- 1182ms, execution = 139ms
App Start &amp;lt;-- 1182ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;监控Pagination场景下的方法调用时长的输出示例，它统计了Pagination这个场景下的3个stage，分别是&lt;code&gt;Get Next Page&lt;/code&gt;、&lt;code&gt;Load&lt;/code&gt;和&lt;code&gt;Process&lt;/code&gt;，每个stage都会运行5次并统计avg、min和max用时。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Profiling results for Pagination:
Get Next Page --&amp;gt; 0ms
  Load --&amp;gt; avg = 1.80ms, min = 1ms, max = 3ms, for 5 runs
  Load &amp;lt;-- avg = 258.40ms, min = 244ms, max = 278ms, for 5 runs
  Process --&amp;gt; avg = 261.00ms, min = 245ms, max = 280ms, for 5 runs
  Process &amp;lt;-- avg = 114.20ms, min = 99ms, max = 129ms, for 5 runs
Get Next Page &amp;lt;-- avg = 378.80ms, min = 353ms, max = 411ms, for 5 runs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 核心代码分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 annotations工程中的注解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;annotations中的注解有6个，分别是&lt;code&gt;MethodProfiling&lt;/code&gt;、&lt;code&gt;MethodProfilings&lt;/code&gt;、&lt;code&gt;StartProfiling&lt;/code&gt;、&lt;code&gt;StartProfilings&lt;/code&gt;、&lt;code&gt;StopProfiling&lt;/code&gt;和&lt;code&gt;StopProfilings&lt;/code&gt;，因为有些方法可能存在多个注解，所以每个都对应会有一个复数形式的。这些注解作用的对象可以是普通的方法，也可以是类的构造器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Combination of {@link StartProfiling} and {@link StopProfiling}. If stage name is empty, then stage name from method&#39;s name and class will be generated.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.CONSTRUCTOR, ElementType.METHOD })
public @interface MethodProfiling {
    /**
     * Profiler Name, used in results.
     */
    String profilerName() default &amp;quot;&amp;quot;;

    /**
     * Name of stage to start. Used in results. If stage name is empty, then stage name from method&#39;s name and class will be generated.
     */
    String stageName() default &amp;quot;&amp;quot;;

    /**
     * Stage order must be bigger then order of current most nested active stage.
     * First profiling must starts with value 0.
     */
    int stageOrder() default 0;

    /**
     * Amount of runs to average. Result will be available only after all runs are stopped.
     */
    int runsCounter() default 1;

    /**
     * Set to false if you want to skip this annotation.
     */
    boolean enabled() default true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.2 pury工程中的注解处理类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pury工程中的注解处理类有3个，分别是&lt;code&gt;ProfileMethodAspect&lt;/code&gt;、&lt;code&gt;StartProfilingAspect&lt;/code&gt;和&lt;code&gt;StopProfilingAspect&lt;/code&gt;类。&lt;/p&gt;

&lt;p&gt;下面是&lt;code&gt;ProfileMethodAspect&lt;/code&gt;的源码，其中定义了4个PointCut以及1个Around Advice。方法&lt;code&gt;weaveJoinPoint&lt;/code&gt;是核心方法，它的主要执行流程是：假设我们对方法M提供了MethodProfiling注解，weaveJointPoint先会根据注解提供的参数去获取并启动所有相关的stage，也就是该方法所在的所有场景(profiler)下的对应stage，然后调用方法M使其执行，最后再停止所有的stage。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Aspect
public class ProfileMethodAspect {
    private static final String POINTCUT_METHOD =
            &amp;quot;execution(@com.nikitakozlov.pury.annotations.MethodProfiling * *(..))&amp;quot;;

    private static final String POINTCUT_CONSTRUCTOR =
            &amp;quot;execution(@com.nikitakozlov.pury.annotations.MethodProfiling *.new(..))&amp;quot;;


    private static final String GROUP_ANNOTATION_POINTCUT_METHOD =
            &amp;quot;execution(@com.nikitakozlov.pury.annotations.MethodProfilings * *(..))&amp;quot;;

    private static final String GROUP_ANNOTATION_POINTCUT_CONSTRUCTOR =
            &amp;quot;execution(@com.nikitakozlov.pury.annotations.MethodProfilings *.new(..))&amp;quot;;

    @Pointcut(POINTCUT_METHOD)
    public void method() {
    }

    @Pointcut(POINTCUT_CONSTRUCTOR)
    public void constructor() {
    }

    @Pointcut(GROUP_ANNOTATION_POINTCUT_METHOD)
    public void methodWithMultipleAnnotations() {
    }

    @Pointcut(GROUP_ANNOTATION_POINTCUT_CONSTRUCTOR)
    public void constructorWithMultipleAnnotations() {
    }

    @Around(&amp;quot;constructor() || method() || methodWithMultipleAnnotations() || constructorWithMultipleAnnotations()&amp;quot;)
    public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {
        ProfilingManager profilingManager = ProfilingManager.getInstance();
        List&amp;lt;StageId&amp;gt; stageIds = getStageIds(joinPoint);
        for (StageId stageId : stageIds) {
            profilingManager.getProfiler(stageId.getProfilerId())
                    .startStage(stageId.getStageName(), stageId.getStageOrder());
        }

        Object result = joinPoint.proceed();

        for (StageId stageId : stageIds) {
            profilingManager.getProfiler(stageId.getProfilerId())
                    .stopStage(stageId.getStageName());
        }

        return result;
    }

    private List&amp;lt;StageId&amp;gt; getStageIds(ProceedingJoinPoint joinPoint) {
        if (!Pury.isEnabled()) {
            return Collections.emptyList();
        }

        Annotation[] annotations =
                ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotations();
        List&amp;lt;StageId&amp;gt; stageIds = new ArrayList&amp;lt;&amp;gt;();
        for (Annotation annotation : annotations) {
            if (annotation.annotationType() == MethodProfiling.class) {
                StageId stageId = getStageId((MethodProfiling) annotation, joinPoint);
                if (stageId != null) {
                    stageIds.add(stageId);
                }
            }
            if (annotation.annotationType() == MethodProfilings.class) {
                for (MethodProfiling methodProfiling : ((MethodProfilings) annotation).value()) {
                    StageId stageId = getStageId(methodProfiling, joinPoint);
                    if (stageId != null) {
                        stageIds.add(stageId);
                    }
                }
            }
        }
        return stageIds;
    }

    private StageId getStageId(MethodProfiling annotation, ProceedingJoinPoint joinPoint) {
        if (!annotation.enabled()) {
            return null;
        }
        ProfilerId profilerId = new ProfilerId(annotation.profilerName(), annotation.runsCounter());
        String stageName = annotation.stageName();
        if (stageName.isEmpty()) {
            CodeSignature codeSignature = (CodeSignature) joinPoint.getSignature();
            String className = codeSignature.getDeclaringType().getSimpleName();
            String methodName = codeSignature.getName();
            stageName = className + &amp;quot;.&amp;quot; + methodName;
        }

        return new StageId(profilerId, stageName, annotation.stageOrder());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StartProfilingAspect&lt;/code&gt;和&lt;code&gt;StopProfilingAspect&lt;/code&gt;与之类似，只不过前者定义的是&lt;code&gt;@Before&lt;/code&gt; advice，而后者定义的是&lt;code&gt;@After&lt;/code&gt; advice。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 核心类Pury&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pury是pury工程的核心工具类，除了可以设置自定义的Logger以及设置enabled状态之外，它还提供了&lt;code&gt;startProfiling&lt;/code&gt;和&lt;code&gt;stopProfiling&lt;/code&gt;两个方法来实现代码调用的方法来对方法进行监控。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Pury {
    static volatile Logger sLogger;
    static volatile boolean sEnabled = true;

    public static void setLogger(Logger logger) {
        sLogger = logger;
    }

    public synchronized static Logger getLogger() {
        if (sLogger == null) {
            sLogger = new DefaultLogger();
        }
        return sLogger;
    }

    public static boolean isEnabled() {
        return sEnabled;
    }

    public synchronized static void setEnabled(boolean enabled) {
        if (!enabled) {
            ProfilingManager.getInstance().clear();
        }
        sEnabled = enabled;
    }

    /**
     *
     * @param profilerName used to identify profiler. Used in results.
     * @param stageName Name of stage to start. Used in results.
     * @param stageOrder Stage order must be bigger then order of current most nested active stage.
     *                   First profiling must starts with value 0.
     * @param runsCounter used to identify profiler. Amount of runs to average.
     *                    Result will be available only after all runs are stopped.
     */
    public static void startProfiling(String profilerName, String stageName, int stageOrder, int runsCounter) {
        ProfilerId profilerId = new ProfilerId(profilerName, runsCounter);
        ProfilingManager.getInstance().getProfiler(profilerId).startStage(stageName, stageOrder);
    }

    /**
     *
     * @param profilerName used to identify profiler. Used in results.
     * @param stageName  Name of stage to stop. Used in results.
     * @param runsCounter used to identify profiler. Amount of runs to average.
     *                    Result will be available only after all runs are stopped.
     */
    public static void stopProfiling(String profilerName, String stageName, int runsCounter) {
        ProfilerId profilerId = new ProfilerId(profilerName, runsCounter);
        ProfilingManager.getInstance().getProfiler(profilerId).stopStage(stageName);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Profiler是由profilerName和runsCounter两个共同决定的&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ProfilerId profilerId = new ProfilerId(profilerName, runsCounter);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在某个监控场景下启动和停止某个方法的监控&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ProfilingManager.getInstance().getProfiler(profilerId).startStage(stageName, stageOrder);

ProfilingManager.getInstance().getProfiler(profilerId).stopStage(stageName, stageOrder);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.4 其他包和类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pury工程的其他类都存放在&lt;code&gt;internal.profile&lt;/code&gt;包和&lt;code&gt;internal.result&lt;/code&gt;两个包中，前者定义了&lt;code&gt;Profiler&lt;/code&gt;、&lt;code&gt;Stage&lt;/code&gt;、&lt;code&gt;StopWatch&lt;/code&gt;等相关类，后者定义了&lt;code&gt;ProfileResultProcessor&lt;/code&gt;、&lt;code&gt;ProfileResult&lt;/code&gt;等各种处理结果和相应的处理类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 其他内容&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;4.1 Pury的优缺点&lt;/p&gt;

&lt;p&gt;个人认为，pury提供了方法调用和注解两种使用形式，实现了对某个场景及该场景下方法级别的监控，甚至可以设置场景的出现次数并自动计算场景下方法的min/avg/max三种执行时长，其功能足以满足一般的应用的场景响应时间监控的需求。不同于&lt;a href=&#34;https://github.com/JakeWharton/hugo&#34;&gt;Hugo&lt;/a&gt;项目，后者只是对一个方法的监控，不能做到Pury这样针对场景的监控。&lt;/p&gt;

&lt;p&gt;Pury存在一个明显的缺点就是方法的层级必须指定，而且必须正确指定。一般来说，方法调用的堆栈往往可能会很深，明确指定方法的层级有时候会比较麻烦，当方法的调用流程发生变化的时候不易于维护。实际上，通过分析方法调用的情况来自动配置方法层级应该是可以做到的(类似TraceView工具)。&lt;/p&gt;

&lt;p&gt;4.2 Pury使用的gradle插件&lt;/p&gt;

&lt;p&gt;发布到maven使用的gradle插件是&lt;code&gt;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&lt;/code&gt;
实现注解解析的gradle插件是&lt;code&gt;com.nikitakozlov.weaverlite&lt;/code&gt;，这个是作者自己封装的插件&lt;a href=&#34;https://github.com/NikitaKozlov/WeaverLite&#34;&gt;WeaverLite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pury的源码就分析到这里吧，感兴趣的建议再扫一遍源码看下，还是会有挺多收获的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build Android Source Code on Mac</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/10/03/build-android-source-code-on-mac/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/10/03/build-android-source-code-on-mac/</guid>
      <description>&lt;p&gt;本文记录下搭建Android源码编译环境的流程。&lt;/p&gt;

&lt;p&gt;趁着国庆长假，抽出些时间来记录下最近倒腾的一些内容，第一个需要记录的自然是Android源码编译的流程。上班第一天就干了一件事，编译Android 6.0源码，第二天就是编译Flyme系统啦！但是编完系统之后刷到PRO6里面还有点小鸡冻呢！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu系统下的Android源码编译环境搭建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果是在Ubuntu系统下进行编译的话，中文文档请参考&lt;a href=&#34;http://blog.csdn.net/dd864140130/article/details/51718187&#34;&gt;自己动手编译最新Android源码及SDK&lt;/a&gt;或者Gityuan写的编译最新的7.0源码的文章&lt;a href=&#34;http://gityuan.com/2016/08/20/Android_N/&#34;&gt;搭建Android 7.0的源码环境&lt;/a&gt;，英文文档主要看Google官方的文档，包括&lt;a href=&#34;https://source.android.com/source/requirements.html&#34;&gt;前提要求篇&lt;/a&gt;、&lt;a href=&#34;https://source.android.com/source/initializing.html&#34;&gt;环境准备篇&lt;/a&gt;以及&lt;a href=&#34;https://source.android.com/source/building.html&#34;&gt;源码编译篇&lt;/a&gt;，如果磁盘空间充足并且网络环境通畅的话，编译通过是没啥问题的。&lt;/p&gt;

&lt;p&gt;特别需要注意以下几点：&lt;br /&gt;
0.磁盘空间的大小&lt;br /&gt;
按照Google官方的说法是，checkout代码至少需要100GB空间，单个编译的话至少需要150GB空间，多类型的编译的话至少需要200GB空间(实际我下载完代码之后大约占用了50GB左右)。而且，如果你是在虚拟机的Linux中编译的话，还需要满足至少有16GB的RAM/swap。&lt;/p&gt;

&lt;p&gt;1.Ubuntu系统的版本和JDK的版本&lt;br /&gt;
Ubuntu系统推荐使用14.04，而且安装好系统之后如果有提示软件更新，建议更新一下。此外，推荐在设置中设置软件更新的远程服务器，将其设置为China下的aliyun服务器，这样速度会快很多。&lt;/p&gt;

&lt;p&gt;JDK版本需要根据你要编译的Android系统版本来确定，而且还需要注意是Oracle JDK还是Open JDK！可以在系统中多安装几个版本的JDK，以后使用&lt;code&gt;update-alternatives --config&lt;/code&gt;命令来切换。&lt;/p&gt;

&lt;p&gt;2.Android源码的分支
详细的分支列表可以在&lt;a href=&#34;https://source.android.com/source/build-numbers.html#source-code-tags-and-builds&#34;&gt;这里&lt;/a&gt;查看，当然，repo init的时候也可以不指定分支。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mac系统下的Android源码编译环境搭建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于是否在自己的MBP上搭建android编译环境的问题我纠结了很久，原因是自己的磁盘剩余空间真的不多了，后来在网上找到了Mac笔记本的扩容卡，对于我这款MBP来说最大可以扩容256GB！虽然有点贵，但是，为了Android，豁出去啦！&lt;/p&gt;

&lt;p&gt;在Mac系统上进行Android源码编译的话可以参考&lt;a href=&#34;http://www.jianshu.com/p/f0356e3ea330&#34;&gt;Mac下设置Android源代码编译环境&lt;/a&gt;这篇文章，主要步骤分别是创建大小写敏感的磁盘、安装依赖包、下载Android源码然后编译就行了。&lt;/p&gt;

&lt;p&gt;对于第一步，创建磁盘操作我是直接将买来的扩容卡格式化成OS X Extended(Case-sensitive Journaled)格式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/osx_extended.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二步是安装JDK、Xcode、MacPorts，这三个在我当前的系统中都已经有了，检查下版本是否可以就行，之后就是通过MacPorts安装几个依赖包，&lt;code&gt;POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这一步我遇到了一个坑，简单描述下：我目前的系统一直以来都是通过系统的更新而升级过来的，所以大概有2年左右的时间没有重装了（嗯，我就是在夸Mac系统好☺️），系统环境也慢慢变得相当复杂了。之前用MacPorts，后来用Homebrew，但是大家都知道&lt;code&gt;brew doctor&lt;/code&gt;的时候总是会提醒MacPorts如何如何的，建议你移动它的位置，后来我貌似是移动了还是怎么的，系统的MacPorts不能正常工作了，利用安装工具反复安装了很多次都卡在了最后的&lt;code&gt;Running package scripts&lt;/code&gt;这个步骤，翻墙状态下安装也是如此，最后的解决方案是利用MacPorts的源码安装一次就好啦！还有就是，不管你的MacPorts是否正常，建议执行一次&lt;code&gt;sudo ports -v selfupdate&lt;/code&gt;进行更新升级一次，如果失败可能是网络连接的问题，可以试试MacPorts的其他镜像。&lt;/p&gt;

&lt;p&gt;第三步是下载Android源码，大家都知道在国内的话需要找镜像，我选择的是清华大学的&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/&#34;&gt;TUNA镜像&lt;/a&gt;。建议下载它的初始化包，大约20多GB，待解压并且完成repo sync之后建议将这个初始化包保存到移动硬盘中存起来，然后删除本地的初始化包，这样可以省下大量的磁盘空间。&lt;/p&gt;

&lt;p&gt;对于Mac系统最后还需要在&lt;code&gt;~/.bash_profile&lt;/code&gt;中设置&lt;code&gt;ulimit -S -n 1024&lt;/code&gt;以增加最大文件打开数量。&lt;/p&gt;

&lt;p&gt;最后一步是执行编译，lunch时我选择&lt;code&gt;aosp_arm64_eng&lt;/code&gt;为target，并启动6个线程进行编译&lt;code&gt;make -j6&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Anyway，最后我还是没能在Mac上编译成功，貌似机器的配置还是不够，算了，还是用来看代码吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Head First Systrace</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/10/03/head-first-systrace/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/10/03/head-first-systrace/</guid>
      <description>&lt;p&gt;深入浅出systrace（1）systrace的简单介绍和systrace工具源码分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.systrace工具简单介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;英文介绍文档推荐阅读官方文档&lt;a href=&#34;https://developer.android.com/studio/profile/systrace-commandline.html&#34;&gt;systrace-commandline&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The Systrace tool helps analyze the performance of your application by capturing and displaying execution times of your applications processes and other Android system processes. The tool combines data from the Android kernel such as the CPU scheduler, disk activity, and application threads to generate an HTML report that shows an overall picture of an Android device’s system processes for a given period of time.&lt;/p&gt;

&lt;p&gt;中文介绍文档推荐看&lt;a href=&#34;http://www.ithtw.com/1009.html&#34;&gt;这篇文章&lt;/a&gt;，从中我们可以知道&lt;/p&gt;

&lt;p&gt;systrace是&lt;code&gt;Android4.1(API 16)&lt;/code&gt;中新增的性能数据采样和分析工具，它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核部分&lt;/strong&gt;：systrace利用了Linux Kernel中的&lt;code&gt;ftrace&lt;/code&gt;功能，所以，如果要使用systrace的话，必须开启kernel中和ftrace相关的模块。
&lt;strong&gt;数据采集部分&lt;/strong&gt;：Android定义了一个Trace类，应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个&lt;code&gt;atrace&lt;/code&gt;程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。
&lt;strong&gt;数据分析工具&lt;/strong&gt;：Android SDK中提供一个systrace.py脚本用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从本质上说，systrace是对Linux Kernel中ftrace的封装，应用进程需要利用Android提供的Trace类来使用systrace。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.systrace数据抓取方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了使用Android Studio和Eclipse中集成的systrace工具之外，我们还可以使用Android SDK中提供的systrace工具来抓取性能日志。systrace.py是个脚本文件，位于&lt;code&gt;{Android SDK}/platform-tools/systrace&lt;/code&gt;文件夹中，它的作用是收集systrace数据并提供网页文件结果供用户查看。&lt;/p&gt;

&lt;p&gt;需要注意的是，不同版本的Android系统对应的systrace命令的参数形式略有不同，下面是常用的调用形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python systrace.py [options] [category1] [category2] ... [categoryN]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是Android 4.3及以上版本的Android系统的systrace命令参数形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/systrace_options_43.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是Android 4.2及以下版本的Android系统的systrace命令参数形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/systrace_options_41.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;systrace工具实际上是调用atrace命令来获取数据结果，所以其实也可以执行atrace命令来抓取数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  ~ adb shell atrace -h
atrace: invalid option -- h

usage: atrace [options] [categories...]
options include:
  -a appname      enable app-level tracing for a comma separated list of cmdlines
  -b N            use a trace buffer size of N KB
  -c              trace into a circular buffer
  -k fname,...    trace the listed kernel functions
  -n              ignore signals
  -s N            sleep for N seconds before tracing [default 0]
  -t N            trace for N seconds [defualt 5]
  -z              compress the trace dump
  --async_start   start circular trace and return immediatly
  --async_dump    dump the current contents of circular trace buffer
  --async_stop    stop tracing and dump the current contents of circular
                    trace buffer
  --list_categories
                  list the available tracing categories
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.systrace工具源码分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 systrace工具的源码目录结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  systrace tree
.
├── AUTHORS
├── LICENSE
├── NOTICE
├── UPSTREAM_REVISION
├── agents
│   ├── __init__.py
│   └── atrace_agent.py
├── prefix.html
├── suffix.html
├── systrace-legacy.py
├── systrace.py
├── systrace_agent.py
├── systrace_trace_viewer.html
├── trace.html
└── util.py

1 directory, 14 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;systrace工具中的主要类和类中的方法及其之间的关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/systrace.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 systrace.py文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2.1 python版本问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从systrace.py的脚本内容来看，systrace工具只支持Python 2.7版本，不支持其他的python版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Make sure we&#39;re using a new enough version of Python.
# The flags= parameter of re.sub() is new in Python 2.7. And Systrace does not
# support Python 3 yet.
version = sys.version_info[:2]
if version != (2, 7):
  sys.stderr.write(&#39;This script does not support Python %d.%d. &#39;
                   &#39;Please use Python 2.7.\n&#39; % version)
  sys.exit(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.2.2 systrace.py文件分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从main方法中可以看出抓取systrace的主流程是：
1.解析命令行中的参数，对应parse_options方法；
2.根据参数创建对应的agent，对应create_agents方法；
3.启动agent来抓取性能日志，对应agent的start方法；
4.收集agent抓取得到的性能日志，对应agent的collect_result方法；
5.将收集的数据写入到html文件中，对应write_trace_html方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def main():
  options, categories = parse_options(sys.argv)
  agents = create_agents(options, categories)

  if not agents:
    dirs = DEFAULT_AGENT_DIR
    if options.agent_dirs:
      dirs += &#39;,&#39; + options.agent_dirs
    sys.stderr.write(&#39;No systrace agent is available in directories |%s|.\n&#39; %
                     dirs)
    sys.exit(1)

  try:
    update_systrace_trace_viewer = __import__(&#39;update_systrace_trace_viewer&#39;)
  except ImportError:
    pass
  else:
    update_systrace_trace_viewer.update()

  for a in agents:
    a.start()

  for a in agents:
    a.collect_result()
    if not a.expect_trace():
      # Nothing more to do.
      return

  script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
  write_trace_html(options.output_file, script_dir, agents)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.parse_options方法使用的是&lt;code&gt;optparse&lt;/code&gt;模块来初始化命令参数和解析命令行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def parse_options(argv):
  &amp;quot;&amp;quot;&amp;quot;Parses and checks the command-line options.

  Returns:
    A tuple containing the options structure and a list of categories to
    be traced.
  &amp;quot;&amp;quot;&amp;quot;
  usage = &#39;Usage: %prog [options] [category1 [category2 ...]]&#39;
  desc = &#39;Example: %prog -b 32768 -t 15 gfx input view sched freq&#39;
  parser = optparse.OptionParser(usage=usage, description=desc)
  parser.add_option(&#39;-o&#39;, dest=&#39;output_file&#39;, help=&#39;write HTML to FILE&#39;,
                    default=&#39;trace.html&#39;, metavar=&#39;FILE&#39;)
  parser.add_option(&#39;-t&#39;, &#39;--time&#39;, dest=&#39;trace_time&#39;, type=&#39;int&#39;,
                    help=&#39;trace for N seconds&#39;, metavar=&#39;N&#39;)
  parser.add_option(&#39;-b&#39;, &#39;--buf-size&#39;, dest=&#39;trace_buf_size&#39;, type=&#39;int&#39;,
                    help=&#39;use a trace buffer size of N KB&#39;, metavar=&#39;N&#39;)
  ...... more options ......
  options, categories = parser.parse_args(argv[1:])

  if options.link_assets or options.asset_dir != &#39;trace-viewer&#39;:
    parser.error(&#39;--link-assets and --asset-dir are deprecated.&#39;)

  if (options.trace_time is not None) and (options.trace_time &amp;lt;= 0):
    parser.error(&#39;the trace time must be a positive number&#39;)

  if (options.trace_buf_size is not None) and (options.trace_buf_size &amp;lt;= 0):
    parser.error(&#39;the trace buffer size must be a positive number&#39;)

  return (options, categories)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.create_agents方法根据解析的命令行参数创建并初始化agents，所谓的agent就是一个用来获取systrace数据的本地代理。使用者可以通过&lt;code&gt;--agent-dirs&lt;/code&gt;来指定agent存放的目录，如果没有指定的话会默认加载并创建放在agents这个目录(package)下面的agents。其中的&lt;code&gt;try_create_agent&lt;/code&gt;方法的实现在&lt;code&gt;atrace_agent.py&lt;/code&gt;文件中，后面会介绍到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create_agents(options, categories):
  &amp;quot;&amp;quot;&amp;quot;Create systrace agents.

  This function will search systrace agent modules in agent directories and
  create the corresponding systrace agents.
  Args:
    options: The command-line options.
categories: &amp;quot;The&amp;quot;
  Returns:
    The list of systrace agents.
  &amp;quot;&amp;quot;&amp;quot;
  agent_dirs = [os.path.join(os.path.dirname(__file__), DEFAULT_AGENT_DIR)]
  if options.agent_dirs:
    agent_dirs.extend(options.agent_dirs.split(&#39;,&#39;))

  agents = []
  for agent_dir in agent_dirs:
    if not agent_dir:
      continue
    for filename in os.listdir(agent_dir):
      (module_name, ext) = os.path.splitext(filename)
      if (ext != &#39;.py&#39; or module_name == &#39;__init__&#39;
          or module_name.endswith(&#39;_unittest&#39;)):
        continue
      (f, pathname, data) = imp.find_module(module_name, [agent_dir])
      try:
        module = imp.load_module(module_name, f, pathname, data)
      finally:
        if f:
          f.close()
      if module:
        agent = module.try_create_agent(options, categories)
        if not agent:
          continue
        agents.append(agent)
  return agents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.write_trace_html方法用来将agents收集的数据写入到html文件中，通常我们得到的网页结果文件的开头和结尾都是一样的，因为这个方法生成html文件的方式是先写入&lt;code&gt;prefix.html&lt;/code&gt;文件，然后遍历agents得到的结果并写入，最后写入&lt;code&gt;suffix.html&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def write_trace_html(html_filename, script_dir, agents):
  &amp;quot;&amp;quot;&amp;quot;Writes out a trace html file.

  Args:
    html_filename: The name of the file to write.
    script_dir: The directory containing this script.
    agents: The systrace agents.
  &amp;quot;&amp;quot;&amp;quot;
  systrace_dir = os.path.abspath(os.path.dirname(__file__))
  html_prefix = read_asset(systrace_dir, &#39;prefix.html&#39;)
  html_suffix = read_asset(systrace_dir, &#39;suffix.html&#39;)
  trace_viewer_html = read_asset(script_dir, &#39;systrace_trace_viewer.html&#39;)

  # Open the file in binary mode to prevent python from changing the
  # line endings.
  html_file = open(html_filename, &#39;wb&#39;)
  html_file.write(html_prefix.replace(&#39;{{SYSTRACE_TRACE_VIEWER_HTML}}&#39;,
                                      trace_viewer_html))

  html_file.write(&#39;&amp;lt;!-- BEGIN TRACE --&amp;gt;\n&#39;)
  for a in agents:
    html_file.write(&#39;  &amp;lt;script class=&amp;quot;&#39;)
    html_file.write(a.get_class_name())
    html_file.write(&#39;&amp;quot; type=&amp;quot;application/text&amp;quot;&amp;gt;\n&#39;)
    html_file.write(a.get_trace_data())
    html_file.write(&#39;  &amp;lt;/script&amp;gt;\n&#39;)
  html_file.write(&#39;&amp;lt;!-- END TRACE --&amp;gt;\n&#39;)

  html_file.write(html_suffix)
  html_file.close()
  print(&#39;\n    wrote file://%s\n&#39; % os.path.abspath(html_filename))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.3 util.py文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;util.py从文件名字可知它是一个工具类，里面主要是定义了执行adb命令的方法&lt;code&gt;run_adb_shell&lt;/code&gt;和通过这个方法获取设备的sdk版本的方法&lt;code&gt;get_device_sdk_version&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.1 run_adb_shell方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该方法将传入的shell命令以及设备的序列号构建成&lt;code&gt;adb -s serial shell xxx&lt;/code&gt;的形式，然后利用&lt;code&gt;subprocess&lt;/code&gt;模块执行命令并获取得到输出的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def run_adb_shell(shell_args, device_serial):
  &amp;quot;&amp;quot;&amp;quot;Runs &amp;quot;adb shell&amp;quot; with the given arguments.

  Args:
    shell_args: array of arguments to pass to adb shell.
    device_serial: if not empty, will add the appropriate command-line
        parameters so that adb targets the given device.
  Returns:
    A tuple containing the adb output (stdout &amp;amp; stderr) and the return code
    from adb.  Will exit if adb fails to start.
  &amp;quot;&amp;quot;&amp;quot;
  adb_command = construct_adb_shell_command(shell_args, device_serial)

  adb_output = []
  adb_return_code = 0
  try:
    adb_output = subprocess.check_output(adb_command, stderr=subprocess.STDOUT,
                                         shell=False, universal_newlines=True)
  except OSError as error:
    # This usually means that the adb executable was not found in the path.
    print &amp;gt;&amp;gt; sys.stderr, (&#39;\nThe command &amp;quot;%s&amp;quot; failed with the following error:&#39;
                          % &#39; &#39;.join(adb_command))
    print &amp;gt;&amp;gt; sys.stderr, &#39;    %s&#39; % str(error)
    print &amp;gt;&amp;gt; sys.stderr, &#39;Is adb in your path?&#39;
    adb_return_code = error.errno
    adb_output = error
  except subprocess.CalledProcessError as error:
    # The process exited with an error.
    adb_return_code = error.returncode
    adb_output = error.output

  return (adb_output, adb_return_code)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.3.2 get_device_sdk_version方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该方法用来获取设备的sdk版本号，它先是利用OptionParser来解析出命令行中的设备序列号，然后调用run_adb_shell方法通过命令来获取sdk版本号。这个方法在&lt;code&gt;atrace_agent&lt;/code&gt;的&lt;code&gt;try_create_agent&lt;/code&gt;方法中被调用，因为对于不同版本号的Android系统其systrace命令的参数形式略有不同，导致处理方式也略有不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_device_sdk_version():
  &amp;quot;&amp;quot;&amp;quot;Uses adb to attempt to determine the SDK version of a running device.&amp;quot;&amp;quot;&amp;quot;

  getprop_args = [&#39;getprop&#39;, &#39;ro.build.version.sdk&#39;]

  # get_device_sdk_version() is called before we even parse our command-line
  # args.  Therefore, parse just the device serial number part of the
  # command-line so we can send the adb command to the correct device.
  parser = OptionParserIgnoreErrors()
  parser.add_option(&#39;-e&#39;, &#39;--serial&#39;, dest=&#39;device_serial&#39;, type=&#39;string&#39;)
  options, unused_args = parser.parse_args() # pylint: disable=unused-variable

  success = False

  adb_output, adb_return_code = run_adb_shell(getprop_args,
                                              options.device_serial)

  if adb_return_code == 0:
    # ADB may print output other than the version number (e.g. it chould
    # print a message about starting the ADB server).
    # Break the ADB output into white-space delimited segments.
    parsed_output = str.split(adb_output)
    if parsed_output:
      # Assume that the version number is the last thing printed by ADB.
      version_string = parsed_output[-1]
      if version_string:
        try:
          # Try to convert the text into an integer.
          version = int(version_string)
        except ValueError:
          version = -1
        else:
          success = True

  if not success:
    print &amp;gt;&amp;gt; sys.stderr, (
        &#39;\nThe command &amp;quot;%s&amp;quot; failed with the following message:&#39;
        % &#39; &#39;.join(getprop_args))
    print &amp;gt;&amp;gt; sys.stderr, adb_output
    sys.exit(1)

  return version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.4 systrace_agent.py文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;systrace_agent.py文件中定义了&lt;code&gt;SystraceAgent&lt;/code&gt;类，其中定义了agent的各个抽象方法，例如启动agent的&lt;code&gt;start&lt;/code&gt;方法、收集systrace数据的&lt;code&gt;collect_result&lt;/code&gt;方法以及获取systrace数据的&lt;code&gt;get_trace_data&lt;/code&gt;方法等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SystraceAgent(object):
  &amp;quot;&amp;quot;&amp;quot;The base class for systrace agents.

  A systrace agent contains the command-line options and trace categories to
  capture. Each systrace agent has its own tracing implementation.
  &amp;quot;&amp;quot;&amp;quot;

  def __init__(self, options, categories):
    &amp;quot;&amp;quot;&amp;quot;Initialize a systrace agent.

    Args:
      options: The command-line options.
categories: &amp;quot;The&amp;quot;
    &amp;quot;&amp;quot;&amp;quot;
    self._options = options
    self._categories = categories

  def start(self):
    &amp;quot;&amp;quot;&amp;quot;Start tracing.
    &amp;quot;&amp;quot;&amp;quot;
    raise NotImplementedError()

  def collect_result(self):
    &amp;quot;&amp;quot;&amp;quot;Collect the result of tracing.

    This function will block while collecting the result. For sync mode, it
    reads the data, e.g., from stdout, until it finishes. For async mode, it
    blocks until the agent is stopped and the data is ready.
    &amp;quot;&amp;quot;&amp;quot;
    raise NotImplementedError()

  def expect_trace(self):
    &amp;quot;&amp;quot;&amp;quot;Check if the agent is returning a trace or not.

    This will be determined in collect_result().
    Returns:
      Whether the agent is expecting a trace or not.
    &amp;quot;&amp;quot;&amp;quot;
    raise NotImplementedError()

  def get_trace_data(self):
    &amp;quot;&amp;quot;&amp;quot;Get the trace data.

    Returns:
      The trace data.
    &amp;quot;&amp;quot;&amp;quot;
    raise NotImplementedError()

  def get_class_name(self):
    &amp;quot;&amp;quot;&amp;quot;Get the class name

    The class name is used to identify the trace type when the trace is written
    to the html file
    Returns:
      The class name.
    &amp;quot;&amp;quot;&amp;quot;
    raise NotImplementedError()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5 atrace_agent.py文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.1 三个Agent类和一些Category&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该文件定义了三个agent类，首先是&lt;code&gt;AtraceAgent&lt;/code&gt;类，继承自&lt;code&gt;SystraceAgent&lt;/code&gt;，是一个核心agent；然后是&lt;code&gt;AtraceLegacyAgent&lt;/code&gt;，继承自&lt;code&gt;AtraceAgent&lt;/code&gt;，主要是为了兼容Android 4.1及以下版本的系统；最后是&lt;code&gt;BootAgent&lt;/code&gt;，继承自&lt;code&gt;AtraceAgent&lt;/code&gt;，主要是为了实现在系统启动时的systrace数据抓取。&lt;/p&gt;

&lt;p&gt;在命令执行的时候具体创建哪个agent是由方法&lt;code&gt;try_create_agent&lt;/code&gt;方法来决定的，该方法会先获取设备的sdk版本。如果版本号大于等于18(Android 4.3及以上版本)，再看参数中是否包含了&lt;code&gt;--boot&lt;/code&gt;选项，如果包含了的话就创建BootAgent，如果没有包含的话就创建AtraceAgent；如果版本号大于等于16且小于18(Android 4.1和Android 4.2版本)，就创建AtraceLegacyAgent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def try_create_agent(options, categories):
  if options.target != &#39;android&#39;:
    return False
  if options.from_file is not None:
    return AtraceAgent(options, categories)

  device_sdk_version = util.get_device_sdk_version()
  if device_sdk_version &amp;gt;= 18:
    if options.boot:
      # atrace --async_stop, which is used by BootAgent, does not work properly
      # on the device SDK version 22 or before.
      if device_sdk_version &amp;lt;= 22:
        print &amp;gt;&amp;gt; sys.stderr, (&#39;--boot option does not work on the device SDK &#39;
                              &#39;version 22 or before.\nYour device SDK version &#39;
                              &#39;is %d.&#39; % device_sdk_version)
        sys.exit(1)
      return BootAgent(options, categories)
    else:
      return AtraceAgent(options, categories)
  elif device_sdk_version &amp;gt;= 16:
    return AtraceLegacyAgent(options, categories)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;systrace抓取的时候一般会指定category，或者叫tag，这些tag是采用位的形式来定义的，和Android系统中的&lt;code&gt;system/core/include/cutils/trace.h&lt;/code&gt;文件中的tag一一对应(&lt;strong&gt;源码注释中的文件是错误的&lt;/strong&gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;LEGACY_TRACE_TAG_BITS = (
  (&#39;gfx&#39;,       1&amp;lt;&amp;lt;1),
  (&#39;input&#39;,     1&amp;lt;&amp;lt;2),
  (&#39;view&#39;,      1&amp;lt;&amp;lt;3),
  (&#39;webview&#39;,   1&amp;lt;&amp;lt;4),
  (&#39;wm&#39;,        1&amp;lt;&amp;lt;5),
  (&#39;am&#39;,        1&amp;lt;&amp;lt;6),
  (&#39;sm&#39;,        1&amp;lt;&amp;lt;7),
  (&#39;audio&#39;,     1&amp;lt;&amp;lt;8),
  (&#39;video&#39;,     1&amp;lt;&amp;lt;9),
  (&#39;camera&#39;,    1&amp;lt;&amp;lt;10),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.2 FileReaderThread类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该文件还定义了&lt;code&gt;FileReaderThread&lt;/code&gt;类，继承自&lt;code&gt;threading.Thread&lt;/code&gt;，用于在工作线程上不断地从文件或者管道中读取数据。&lt;code&gt;file_object&lt;/code&gt;是对应的文件或者管道对象，&lt;code&gt;output_queue&lt;/code&gt;是用来接收读取数据的队列，&lt;code&gt;text_file&lt;/code&gt;是用来标示文件是否是文本文件，&lt;code&gt;chunk_size&lt;/code&gt;是用来指定每次读取的数据的大小。如果text_file是True的话，说明是文本文件，那么chunk_size参数会被忽略，因为文本文件会一行一行地读取并处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class FileReaderThread(threading.Thread):
  &amp;quot;&amp;quot;&amp;quot;Reads data from a file/pipe on a worker thread.

  Use the standard threading. Thread object API to start and interact with the
  thread (start(), join(), etc.).
  &amp;quot;&amp;quot;&amp;quot;

  def __init__(self, file_object, output_queue, text_file, chunk_size=-1):
    &amp;quot;&amp;quot;&amp;quot;Initializes a FileReaderThread.

    Args:
      file_object: The file or pipe to read from.
      output_queue: A Queue.Queue object that will receive the data
      text_file: If True, the file will be read one line at a time, and
          chunk_size will be ignored.  If False, line breaks are ignored and
          chunk_size must be set to a positive integer.
      chunk_size: When processing a non-text file (text_file = False),
          chunk_size is the amount of data to copy into the queue with each
          read operation.  For text files, this parameter is ignored.
    &amp;quot;&amp;quot;&amp;quot;
    threading.Thread.__init__(self)
    self._file_object = file_object
    self._output_queue = output_queue
    self._text_file = text_file
    self._chunk_size = chunk_size
    assert text_file or chunk_size &amp;gt; 0

  def run(self):
    &amp;quot;&amp;quot;&amp;quot;Overrides Thread&#39;s run() function.

    Returns when an EOF is encountered.
    &amp;quot;&amp;quot;&amp;quot;
    if self._text_file:
      # Read a text file one line at a time.
      for line in self._file_object:
        self._output_queue.put(line)
    else:
      # Read binary or text data until we get to EOF.
      while True:
        chunk = self._file_object.read(self._chunk_size)
        if not chunk:
          break
        self._output_queue.put(chunk)

  def set_chunk_size(self, chunk_size):
    &amp;quot;&amp;quot;&amp;quot;Change the read chunk size.

    This function can only be called if the FileReaderThread object was
    created with an initial chunk_size &amp;gt; 0.
    Args:
      chunk_size: the new chunk size for this file.  Must be &amp;gt; 0.
    &amp;quot;&amp;quot;&amp;quot;
    # The chunk size can be changed asynchronously while a file is being read
    # in a worker thread.  However, type of file can not be changed after the
    # the FileReaderThread has been created.  These asserts verify that we are
    # only changing the chunk size, and not the type of file.
    assert not self._text_file
    assert chunk_size &amp;gt; 0
    self._chunk_size = chunk_size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.3 AtraceAgent类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AtraceAgent类的实现主要是在&lt;code&gt;start&lt;/code&gt;方法中构建对应的atrace命令，然后利用&lt;code&gt;subprocess&lt;/code&gt;模块去执行，最后在&lt;code&gt;collect_result&lt;/code&gt;方法中解析systrace结果即可。其中的内部变量&lt;code&gt;_expect_trace&lt;/code&gt;是用来指示这个命令是否会创建systrace数据，&lt;code&gt;_adb&lt;/code&gt;表示&lt;code&gt;subprocess&lt;/code&gt;执行的命令，&lt;code&gt;_trace_data&lt;/code&gt;是指systrace的数据，&lt;code&gt;_tracer_args&lt;/code&gt;是指systracer的参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class AtraceAgent(systrace_agent.SystraceAgent):
  def __init__(self, options, categories):
    super(AtraceAgent, self).__init__(options, categories)
    self._expect_trace = False
    self._adb = None
    self._trace_data = None
    self._tracer_args = None
    if not self._categories:
      self._categories = get_default_categories(self._options.device_serial)

  def start(self):
    self._tracer_args = self._construct_trace_command()

    self._adb = do_popen(self._tracer_args)

  def collect_result(self):
    trace_data = self._collect_trace_data()
    if self._expect_trace:
      self._trace_data = self._preprocess_trace_data(trace_data)

  def expect_trace(self):
    return self._expect_trace

  def get_trace_data(self):
    return self._trace_data

  def get_class_name(self):
    return &#39;trace-data&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.3.1 _construct_trace_command方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_construct_trace_command&lt;/code&gt;方法的作用是构建atrace命令，其大致流程是：如果命令行中包含了&lt;code&gt;--list_categories&lt;/code&gt;选项的话，那么就执行&lt;code&gt;adb [-e serial] shell atrace --list_categories&lt;/code&gt;命令来获取所有的categories；如果命令行中包含了&lt;code&gt;--from_file&lt;/code&gt;选项的话，那么就实际执行的是&lt;code&gt;cat {file}&lt;/code&gt;命令(这个命令经常用于将一个压缩的systrace数据文件转换成html网页结果文件)；如果不是上面两种特殊情况，那么就正常解析命令行参数构建成atrace命令的参数，如果需要压缩数据的话就加上&lt;code&gt;-z&lt;/code&gt;选项，如果设置了时间长度的话加上&lt;code&gt;-t {time}&lt;/code&gt;选项，如果设置了buffer_size的话就加上&lt;code&gt;-b {buffer_size}&lt;/code&gt;，而且如果设置了&lt;code&gt;sched&lt;/code&gt;这个tag的话，需要将buffer_size设置为4096，因为默认情况下buffer_size是2048，而sched开启的话需要抓取的数据量会很大，所以设置成默认值的2倍。这部分命令行参数解析完了之后会调用&lt;code&gt;_construct_extra_trace_command&lt;/code&gt;方法继续解析&lt;code&gt;-a&lt;/code&gt;指定应用以及&lt;code&gt;-k&lt;/code&gt;指定内核函数这两个参数。最后调用util.py中的&lt;code&gt;construct_adb_shell_command&lt;/code&gt;方法将其封装成一个adb shell命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _construct_trace_command(self):
&amp;quot;&amp;quot;&amp;quot;Builds a command-line used to invoke a trace process.

Returns:
 A tuple where the first element is an array of command-line arguments, and
 the second element is a boolean which will be true if the commend will
 stream trace data.
&amp;quot;&amp;quot;&amp;quot;
if self._options.list_categories:
 tracer_args = self._construct_list_categories_command()
 self._expect_trace = False
elif self._options.from_file is not None:
 tracer_args = [&#39;cat&#39;, self._options.from_file]
 self._expect_trace = True
else:
 atrace_args = ATRACE_BASE_ARGS[:]
 self._expect_trace = True
 if self._options.compress_trace_data:
   atrace_args.extend([&#39;-z&#39;])

 if ((self._options.trace_time is not None)
     and (self._options.trace_time &amp;gt; 0)):
   atrace_args.extend([&#39;-t&#39;, str(self._options.trace_time)])

 if ((self._options.trace_buf_size is not None)
     and (self._options.trace_buf_size &amp;gt; 0)):
   atrace_args.extend([&#39;-b&#39;, str(self._options.trace_buf_size)])
 elif &#39;sched&#39; in self._categories:
   # &#39;sched&#39; is a high-volume tag, double the default buffer size
   # to accommodate that
   atrace_args.extend([&#39;-b&#39;, &#39;4096&#39;])
 extra_args = self._construct_extra_trace_command()
 atrace_args.extend(extra_args)

 tracer_args = util.construct_adb_shell_command(
     atrace_args, self._options.device_serial)

return tracer_args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.3.2 _collect_trace_data方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;_collect_trace_data方法的作用是收集trace数据，它先会创建两个队列，一个是标准输出队列，另一个是错误输出队列，然后创建两个对应的工作线程FileReaderThread，它们分别监听标准输出流和错误输出流，前者不是文本数据类型，而后者是文本数据类型。方法中记录的时间的作用其实是为了在&lt;code&gt;status_update&lt;/code&gt;方法中检测距离上一次更新时间的时间段，如果超过了&lt;code&gt;MIN_TIME_BETWEEN_STATUS_UPDATES&lt;/code&gt;的话就输出一个&lt;code&gt;.&lt;/code&gt;以便让使用者知道程序还在执行，而不是挂了。方法中后半部分内容就是在循环读取流中的数据，将其放入到队列中，直到没有任何数据了就关闭流，结束命令返回结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _collect_trace_data(self):
  # Read the output from ADB in a worker thread.  This allows us to monitor
  # the progress of ADB and bail if ADB becomes unresponsive for any reason.

  # Limit the stdout_queue to 128 entries because we will initially be reading
  # one byte at a time.  When the queue fills up, the reader thread will
  # block until there is room in the queue.  Once we start downloading the
  # trace data, we will switch to reading data in larger chunks, and 128
  # entries should be plenty for that purpose.
  stdout_queue = Queue.Queue(maxsize=128)
  stderr_queue = Queue.Queue()

  if self._expect_trace:
    # Use stdout.write() (here and for the rest of this function) instead
    # of print() to avoid extra newlines.
    sys.stdout.write(&#39;Capturing trace...&#39;)

  # Use a chunk_size of 1 for stdout so we can display the output to
  # the user without waiting for a full line to be sent.
  stdout_thread = FileReaderThread(self._adb.stdout, stdout_queue,
                                   text_file=False, chunk_size=1)
  stderr_thread = FileReaderThread(self._adb.stderr, stderr_queue,
                                   text_file=True)
  stdout_thread.start()
  stderr_thread.start()

  # Holds the trace data returned by ADB.
  trace_data = []
  # Keep track of the current line so we can find the TRACE_START_REGEXP.
  current_line = &#39;&#39;
  # Set to True once we&#39;ve received the TRACE_START_REGEXP.
  reading_trace_data = False

  last_status_update_time = time.time()

  while (stdout_thread.isAlive() or stderr_thread.isAlive() or
         not stdout_queue.empty() or not stderr_queue.empty()):
    if self._expect_trace:
      last_status_update_time = status_update(last_status_update_time)

    while not stderr_queue.empty():
      # Pass along errors from adb.
      line = stderr_queue.get()
      sys.stderr.write(line)

    # Read stdout from adb.  The loop exits if we don&#39;t get any data for
    # ADB_STDOUT_READ_TIMEOUT seconds.
    while True:
      try:
        chunk = stdout_queue.get(True, ADB_STDOUT_READ_TIMEOUT)
      except Queue.Empty:
        # Didn&#39;t get any data, so exit the loop to check that ADB is still
        # alive and print anything sent to stderr.
        break

      if reading_trace_data:
        # Save, but don&#39;t print, the trace data.
        trace_data.append(chunk)
      else:
        if not self._expect_trace:
          sys.stdout.write(chunk)
        else:
          # Buffer the output from ADB so we can remove some strings that
          # don&#39;t need to be shown to the user.
          current_line += chunk
          if re.match(TRACE_START_REGEXP, current_line):
            # We are done capturing the trace.
            sys.stdout.write(&#39;Done.\n&#39;)
            # Now we start downloading the trace data.
            sys.stdout.write(&#39;Downloading trace...&#39;)

            current_line = &#39;&#39;
            # Use a larger chunk size for efficiency since we no longer
            # need to worry about parsing the stream.
            stdout_thread.set_chunk_size(4096)
            reading_trace_data = True
          elif chunk == &#39;\n&#39; or chunk == &#39;\r&#39;:
            # Remove ADB output that we don&#39;t care about.
            current_line = re.sub(ADB_IGNORE_REGEXP, &#39;&#39;, current_line)
            if len(current_line) &amp;gt; 1:
              # ADB printed something that we didn&#39;t understand, so show it
              # it to the user (might be helpful for debugging).
              sys.stdout.write(current_line)
            # Reset our current line.
            current_line = &#39;&#39;

  if self._expect_trace:
    if reading_trace_data:
      # Indicate to the user that the data download is complete.
      sys.stdout.write(&#39;Done.\n&#39;)
    else:
      # We didn&#39;t receive the trace start tag, so something went wrong.
      sys.stdout.write(&#39;ERROR.\n&#39;)
      # Show any buffered ADB output to the user.
      current_line = re.sub(ADB_IGNORE_REGEXP, &#39;&#39;, current_line)
      if current_line:
        sys.stdout.write(current_line)
        sys.stdout.write(&#39;\n&#39;)

  # The threads should already have stopped, so this is just for cleanup.
  stdout_thread.join()
  stderr_thread.join()

  self._adb.stdout.close()
  self._adb.stderr.close()

  # The adb process should be done since it&#39;s io pipes are closed.  Call
  # poll() to set the return code.
  self._adb.poll()

  if self._adb.returncode != 0:
    print &amp;gt;&amp;gt; sys.stderr, (&#39;The command &amp;quot;%s&amp;quot; returned error code %d.&#39; %
                          (&#39; &#39;.join(self._tracer_args), self._adb.returncode))
    sys.exit(1)

  return trace_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.3.3 _preprocess_trace_data方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;_preprocess_trace_data方法是用来预处理trace数据的，atrace_agent.py文件中定义了很多&lt;code&gt;fix_xxx&lt;/code&gt;的方法，用于修复trace数据中的部分数据，例如&lt;code&gt;fix_thread_names&lt;/code&gt;用来修复线程名字，修复的方法是调用&lt;code&gt;ps -t&lt;/code&gt;命令来获取当前系统中的线程的id及其对应的名称，其他的fix方法与之类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  def _preprocess_trace_data(self, trace_data):
    &amp;quot;&amp;quot;&amp;quot;Performs various processing on atrace data.

    Args:
      trace_data: The raw trace data.
    Returns:
      The processed trace data.
    &amp;quot;&amp;quot;&amp;quot;
    trace_data = &#39;&#39;.join(trace_data)
    if trace_data:
      trace_data = strip_and_decompress_trace(trace_data)

    if not trace_data:
      print &amp;gt;&amp;gt; sys.stderr, (&#39;No data was captured.  Output file was not &#39;
                            &#39;written.&#39;)
      sys.exit(1)

    if self._options.fix_threads:
      # Issue ps command to device and patch thread names
      ps_dump = do_preprocess_adb_cmd(&#39;ps -t&#39;, self._options.device_serial)
      if ps_dump is not None:
        thread_names = extract_thread_list(ps_dump)
        trace_data = fix_thread_names(trace_data, thread_names)

    if self._options.fix_tgids:
      # Issue printf command to device and patch tgids
      procfs_dump = do_preprocess_adb_cmd(&#39;printf &amp;quot;%s\n&amp;quot; &#39; +
                                          &#39;/proc/[0-9]*/task/[0-9]*&#39;,
                                          self._options.device_serial)
      if procfs_dump is not None:
        pid2_tgid = extract_tgids(procfs_dump)
        trace_data = fix_missing_tgids(trace_data, pid2_tgid)

    if self._options.fix_circular:
      trace_data = fix_circular_traces(trace_data)

    return trace_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.4 AtraceLegacyAgent类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AtraceLegacyAgent继承自AtraceAgent，区别在于它适用于Android 4.1及以下系统，实现方式是重写了AtraceAgent中的_construct_list_categories_command和_construct_extra_trace_command方法，因为它们的命令行的参数选项略有不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class AtraceLegacyAgent(AtraceAgent):
  def _construct_list_categories_command(self):
    LEGACY_CATEGORIES = &amp;quot;&amp;quot;&amp;quot;       sched - CPU Scheduling
        freq - CPU Frequency
        idle - CPU Idle
        load - CPU Load
        disk - Disk I/O (requires root)
         bus - Bus utilization (requires root)
   workqueue - Kernel workqueues (requires root)&amp;quot;&amp;quot;&amp;quot;
    return [&amp;quot;echo&amp;quot;, LEGACY_CATEGORIES]

  def start(self):
    super(AtraceLegacyAgent, self).start()
    if self.expect_trace():
      SHELL_ARGS = [&#39;getprop&#39;, &#39;debug.atrace.tags.enableflags&#39;]
      output, return_code = util.run_adb_shell(SHELL_ARGS,
                                               self._options.device_serial)
      if return_code != 0:
        print &amp;gt;&amp;gt; sys.stderr, (
            &#39;\nThe command &amp;quot;%s&amp;quot; failed with the following message:&#39;
            % &#39; &#39;.join(SHELL_ARGS))
        print &amp;gt;&amp;gt; sys.stderr, str(output)
        sys.exit(1)

      flags = 0
      try:
        if output.startswith(&#39;0x&#39;):
          flags = int(output, 16)
        elif output.startswith(&#39;0&#39;):
          flags = int(output, 8)
        else:
          flags = int(output)
      except ValueError:
        pass

      if flags:
        tags = []
        for desc, bit in LEGACY_TRACE_TAG_BITS:
          if bit &amp;amp; flags:
            tags.append(desc)
        categories = tags + self._categories
        print &#39;Collecting data with following categories:&#39;, &#39; &#39;.join(categories)

  def _construct_extra_trace_command(self):
    extra_args = []
    if not self._categories:
      self._categories = [&#39;sched&#39;, ]
    if &#39;sched&#39; in self._categories:
      extra_args.append(&#39;-s&#39;)
    if &#39;freq&#39; in self._categories:
      extra_args.append(&#39;-f&#39;)
    if &#39;idle&#39; in self._categories:
      extra_args.append(&#39;-i&#39;)
    if &#39;load&#39; in self._categories:
      extra_args.append(&#39;-l&#39;)
    if &#39;disk&#39; in self._categories:
      extra_args.append(&#39;-d&#39;)
    if &#39;bus&#39; in self._categories:
      extra_args.append(&#39;-u&#39;)
    if &#39;workqueue&#39; in self._categories:
      extra_args.append(&#39;-w&#39;)

    return extra_args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.5.5 BootAgent类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BootAgent同样继承自AtraceAgent，但是它适用于在设备启动的时候抓取systrace数据。它需要将指定的categories写入到&lt;code&gt;/data/misc/boottrace/categories&lt;/code&gt;文件中，然后将&lt;code&gt;persist.debug.atrace.boottrace&lt;/code&gt;属性置为1，最后执行重启&lt;code&gt;reboot&lt;/code&gt;即可。待系统启动之后，利用Ctrl+C来结束抓取，此时会执行&lt;code&gt;atrace --async_stop&lt;/code&gt;命令结束。在设备启动时抓取systrace数据的需求较少，所以&lt;code&gt;--boot&lt;/code&gt;这个选项很少使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BootAgent(AtraceAgent):
  &amp;quot;&amp;quot;&amp;quot;AtraceAgent that specializes in tracing the boot sequence.&amp;quot;&amp;quot;&amp;quot;

  def __init__(self, options, categories):
    super(BootAgent, self).__init__(options, categories)

  def start(self):
    try:
      setup_args = self._construct_setup_command()
      try:
        subprocess.check_call(setup_args)
        print &#39;Hit Ctrl+C once the device has booted up.&#39;
        while True:
          time.sleep(1)
      except KeyboardInterrupt:
        pass
      tracer_args = self._construct_trace_command()
      self._adb = subprocess.Popen(tracer_args, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
    except OSError as error:
      print &amp;gt;&amp;gt; sys.stderr, (
          &#39;The command &amp;quot;%s&amp;quot; failed with the following error:&#39; %
          &#39; &#39;.join(tracer_args))
      print &amp;gt;&amp;gt; sys.stderr, &#39;    &#39;, error
      sys.exit(1)

  def _construct_setup_command(self):
    echo_args = [&#39;echo&#39;] + self._categories + [&#39;&amp;gt;&#39;, BOOTTRACE_CATEGORIES]
    setprop_args = [&#39;setprop&#39;, BOOTTRACE_PROP, &#39;1&#39;]
    reboot_args = [&#39;reboot&#39;]
    return util.construct_adb_shell_command(
        echo_args + [&#39;&amp;amp;&amp;amp;&#39;] + setprop_args + [&#39;&amp;amp;&amp;amp;&#39;] + reboot_args,
        self._options.device_serial)

  def _construct_trace_command(self):
    self._expect_trace = True
    atrace_args = [&#39;atrace&#39;, &#39;--async_stop&#39;]
    setprop_args = [&#39;setprop&#39;, BOOTTRACE_PROP, &#39;0&#39;]
    rm_args = [&#39;rm&#39;, BOOTTRACE_CATEGORIES]
    return util.construct_adb_shell_command(
          atrace_args + [&#39;&amp;amp;&amp;amp;&#39;] + setprop_args + [&#39;&amp;amp;&amp;amp;&#39;] + rm_args,
          self._options.device_serial)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，本文的systrace工具源码分析结束，后面会抽空陆续加上Android系统中systrace相关的类和文件的源码解析，以及利用systrace数据来分析应用性能问题的方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ways to Use Icons on Android (2)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/06/25/ways-to-use-icons-on-android-2/</link>
      <pubDate>Sat, 25 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/06/25/ways-to-use-icons-on-android-2/</guid>
      <description>

&lt;p&gt;本节主要介绍几种图标字体的制作方法和Iconify扩展的使用姿势。&lt;/p&gt;

&lt;p&gt;本系列文章介绍的内容对应的Github项目地址：&lt;a href=&#34;https://github.com/hujiaweibujidao/IconFontApp&#34;&gt;IconFontApp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上一节提到，如果项目中很多自定义的图标，或者是各种不同来源的图标，我们可以通过对Iconify进行扩展来实现，但是在扩展之前我们需要制作自己的图标字体文件，那么图标字体文件该如何制作呢？这个可以试试Fontello、Icomoon或者IconFont吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(制作图标字体的方法有很多，可以参考&lt;a href=&#34;http://www.uisdc.com/4-icon-font-production-method&#34;&gt;这里&lt;/a&gt;，本文主要介绍的是如何快速利用已有的图标制作字体文件然后在应用中使用)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-fontello-icon-font-generator&#34;&gt;&lt;strong&gt;1.Fontello: icon font generator&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Fontello网址：&lt;a href=&#34;http://fontello.com/&#34;&gt;http://fontello.com/&lt;/a&gt;
Github地址：&lt;a href=&#34;https://github.com/fontello/fontello&#34;&gt;https://github.com/fontello/fontello&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Fontello是个图标字体生成器，通过它可以把一些图标作成字体放到自己的项目中。在Fontello主页上可以访问大量专业级的开源图标，并支持添加自定义的图标（SVG格式），而且可以在网站上选择不同来源的图标合并到单个字体文件中。此外，它还可以自定义每个图标的名称以及对应的Unicode码，一切配置好了之后可以将图标字体下载下来放到项目中使用。如下图所示，我添加了两个Custom Icons，从Fontelico中选了6个图标，从Font Awesome中选了3个图标等，最终导出得到的图标字体文件就会包含这些我需要的图标。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/fontello.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自定义图标名称和对应的Unicode：在页面顶部的配置中可以选择设置图标名称的前缀，例如&lt;code&gt;fe-&lt;/code&gt;
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/fontello-name.png&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/fontello-code.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下载之后得到一个zip文件，解压之后打开&lt;code&gt;demo.html&lt;/code&gt;可以看到该图标字体中的所有图标的名称和对应的Unicode
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/fontello-nocode.png&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/fontello-showcode.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时，在解压后的&lt;code&gt;font&lt;/code&gt;文件夹中有我们需要的ttf字体文件&lt;code&gt;fontello.ttf&lt;/code&gt;，下面介绍下详细的扩展实现步骤。&lt;/p&gt;

&lt;p&gt;(1)新建一个Android Studio项目，在&lt;code&gt;app&lt;/code&gt;中添加对Iconify的依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;com.joanzapata.iconify:android-iconify:2.2.2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)新建&lt;code&gt;assets&lt;/code&gt;文件夹，并将字体文件&lt;code&gt;fontello.ttf&lt;/code&gt;拷贝到文件夹下
(3)新建&lt;code&gt;FontelloModule&lt;/code&gt;类，实现&lt;code&gt;IconFontDescriptor&lt;/code&gt;接口，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class FontelloModule implements IconFontDescriptor {

    @Override
    public String ttfFileName() {
        return &amp;quot;fontello.ttf&amp;quot;;
    }

    @Override
    public Icon[] characters() {
        return FontelloIcons.values();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4)新建&lt;code&gt;FontelloIcons&lt;/code&gt;枚举，实现&lt;code&gt;Icon&lt;/code&gt;接口，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum FontelloIcons implements Icon {
    fe_spin1(&#39;\uE800&#39;),
    fe_spin2(&#39;\uE801&#39;),
    fe_spin3(&#39;\uE802&#39;),
    fe_spin4(&#39;\uE803&#39;),
    fe_spin5(&#39;\uE804&#39;),
    fe_github(&#39;\uE816&#39;);//注：这里我并没有把所有的图标都加上

    char character;

    FontelloIcons(char character) {
        this.character = character;
    }

    @Override
    public String key() {
        return name().replace(&#39;_&#39;, &#39;-&#39;);
    }

    @Override
    public char character() {
        return character;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(5)测试：在&lt;code&gt;activity_main.xml&lt;/code&gt;布局文件中添加一个IconTextView&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.joanzapata.iconify.widget.IconTextView
    android:id=&amp;quot;@+id/iconTextView&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:layout_centerInParent=&amp;quot;true&amp;quot;
    android:layout_centerHorizontal=&amp;quot;true&amp;quot;
    android:text=&amp;quot;{fe-github} {fe-spin1 spin} {fe-spin2 spin} {fe-spin3 spin} {fe-spin4 spin} {fe-spin5 spin}&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;MainActivity&lt;/code&gt;的&lt;code&gt;onCreate&lt;/code&gt;方法最后添加初始化操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Iconify.with(new FontelloModule());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行应用看到效果见文章末尾的截图，图标可以设置为旋转效果的哟，有点炫啊！&lt;/p&gt;

&lt;h4 id=&#34;2-icomoon&#34;&gt;&lt;strong&gt;2.IcoMoon&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;IcoMoon网址：&lt;a href=&#34;https://icomoon.io/app/&#34;&gt;https://icomoon.io/app/&lt;/a&gt;
IcoMoon和Fontello一样，既可以添加自己的图标，又可以从其他的图标库中选择图片，而且也支持设置图标的名称和Unicode，最终还能导出得到图标字体文件。IcoMoon导出得到的zip文件和Fontello导出的结果类似，使用它的ttf文件对Iconify进行扩展的方式也一样。&lt;/p&gt;

&lt;h4 id=&#34;3-iconfont&#34;&gt;&lt;strong&gt;3.IconFont&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;IconFont网址：&lt;a href=&#34;http://www.iconfont.cn/&#34;&gt;http://www.iconfont.cn/&lt;/a&gt;
IconFont可是中文的图标字体制作网站哟！该网站是阿里的UED团队做的吧，在该网站可以方便地管理图标和制作图标字体文件。网站的帮助中&lt;a href=&#34;http://www.iconfont.cn/help/iconuse.html&#34;&gt;Android端应用教程&lt;/a&gt;介绍了如何使用下载得到的IconFont，这个比较简单。但是，需要注意的是，下载下来的&lt;code&gt;demo.html&lt;/code&gt;中看到的图标对应的编码用的是&lt;code&gt;UTF-8&lt;/code&gt;表示的，并不是&lt;code&gt;Unicode&lt;/code&gt;编码。此外，TextView的setText方法在使用的时候，如果传递的参数是&lt;code&gt;R.string.xxx&lt;/code&gt;的形式的话，最终显示的时候对应的字符串会自动转成Unicode编码；但是如果传递的参数是某个字符串的话，该字符串默认会被视为Unicode编码，也就是说如果它原来不是Unicode编码这个时候显示就会出现异常！&lt;/p&gt;

&lt;p&gt;看下下面的代码就清楚了，下面显示了4中不同的调用方式，并给出了不同方式下的显示结果
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/iconfontapp_code.png&#34; alt=&#34;iconfontapp_code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关于如何将UTF-8编码的形式改成Unicode编码的形式可以参考其他的文档，但是这里的转换比较简单，只要抽取出其中的16位表示形式就行了，例如UTF-8编码的&lt;code&gt;&amp;amp;#xe601;&lt;/code&gt;对应的Unicode编码就是&lt;code&gt;\ue601&lt;/code&gt;，其中的16位表示形式是&lt;code&gt;e601&lt;/code&gt;，其他的同理。&lt;/p&gt;

&lt;p&gt;项目&lt;a href=&#34;https://github.com/hujiaweibujidao/IconFontApp&#34;&gt;IconFontApp&lt;/a&gt;运行起来的效果如下图所示：
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/iconfont.gif&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的分析可以看出，图标字体文件的制作以及利用字体文件对Iconify进行扩展都还比较简单，唯一比较麻烦的是，如果项目中使用了大量的图标的话，编写图标集合的枚举类会比较无聊，所以下节可能会开发一个小脚本或者小插件来完成这个无聊的任务，噢啦，晚安！&lt;/p&gt;

&lt;p&gt;余淮和耿耿终于在一起啦，好嗨森，嘿嘿，《最好的我们》和最好的我们真的快要结束啦，快要毕业咯！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ways to Use Icons on Android (1)</title>
      <link>https://hujiaweibujidao.github.io/blog/2016/06/24/ways-to-use-icons-on-android-1/</link>
      <pubDate>Fri, 24 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hujiaweibujidao.github.io/blog/2016/06/24/ways-to-use-icons-on-android-1/</guid>
      <description>

&lt;p&gt;本节主要介绍几种Material Design图标的使用姿势。&lt;/p&gt;

&lt;p&gt;本系列文章介绍的内容对应的Github项目地址：&lt;a href=&#34;https://github.com/hujiaweibujidao/IconFontApp&#34;&gt;IconFontApp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近对IconFont特别感兴趣，通过使用IconFont一些常见的制作精良的小图标就可以直接在代码中非常方便的使用，免去了找图标并添加到项目中的很多麻烦。本系列估计也会有三篇文章，结合实践分享下我的摸索过程，也许大家会觉得有用呢。本节主要从Material Design图标入手，介绍它的几种使用姿势。&lt;/p&gt;

&lt;h4 id=&#34;1-material-design图标简介&#34;&gt;&lt;strong&gt;1.Material Design图标简介&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Github网址：&lt;a href=&#34;https://github.com/google/material-design-icons&#34;&gt;https://github.com/google/material-design-icons&lt;/a&gt;
内容介绍网址：&lt;a href=&#34;http://google.github.io/material-design-icons/&#34;&gt;http://google.github.io/material-design-icons/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Material Design图标分为了&lt;code&gt;action&lt;/code&gt;、&lt;code&gt;alert&lt;/code&gt;、&lt;code&gt;file&lt;/code&gt;、&lt;code&gt;notification&lt;/code&gt;、&lt;code&gt;place&lt;/code&gt;等类型，每种类型下都有一定数量的图标，而且这些图标还按照平台的不同进行了整理，包括&lt;code&gt;android&lt;/code&gt;、&lt;code&gt;ios&lt;/code&gt;、&lt;code&gt;web&lt;/code&gt;平台，同时也包含了SVG格式的图片文件。其中&lt;code&gt;android&lt;/code&gt;平台的图标又包括两种类型的，一种是存放在&lt;code&gt;drawable-xxxdpi&lt;/code&gt;文件夹下的PNG格式文件，里面的图标有4种大小，分别是&lt;code&gt;18dp&lt;/code&gt;、&lt;code&gt;24dp&lt;/code&gt;、&lt;code&gt;36dp&lt;/code&gt;和&lt;code&gt;48dp&lt;/code&gt;；另一种是存放在&lt;code&gt;drawable-anydpi-v21&lt;/code&gt;文件夹下的XML格式文件（Vectore Drawable），里面的图标大小都是&lt;code&gt;24dp&lt;/code&gt;，颜色都是黑色。&lt;/p&gt;

&lt;h4 id=&#34;2-复制使用方式&#34;&gt;&lt;strong&gt;2.复制使用方式&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;复制使用方式就是如果项目中我们需要某张Material Design风格的图片的话，我们可以直接拷贝PNG格式的文件或者XML格式的文件，区别是后者只支持Android Lollipop及以上版本（但是可以通过support library进行兼容）。&lt;/p&gt;

&lt;p&gt;如果你不想进行复制操作的话，可以考虑Android Studio的&lt;code&gt;Android Drawable Importer&lt;/code&gt;插件。
插件的Github网址：&lt;a href=&#34;https://github.com/winterDroid/android-drawable-importer-intellij-plugin&#34;&gt;https://github.com/winterDroid/android-drawable-importer-intellij-plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利用这个插件的&lt;code&gt;Icon Pack Drawable Importer&lt;/code&gt;功能可以快速导入PNG或者JPG格式的图片文件，还可以设置大小和颜色。此外，利用它的&lt;code&gt;Vector Drawable Importer&lt;/code&gt;功能就可以导入XML格式的Vector Drawable文件，导入之后可以在项目的&lt;code&gt;res/drawable&lt;/code&gt;目录中看到导入的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hujiaweibujidao.github.io/images/drawable_importer.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-依赖使用方式&#34;&gt;&lt;strong&gt;3.依赖使用方式&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;依赖使用方式是通过依赖一些封装好的第三方库来使用Material Design图标，例如项目&lt;code&gt;MaterialDesignIcons&lt;/code&gt;和&lt;code&gt;Iconify&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;MaterialDesignIcons的Github网址：&lt;a href=&#34;https://github.com/MrBIMC/MaterialDesignIcons&#34;&gt;https://github.com/MrBIMC/MaterialDesignIcons&lt;/a&gt;
这个项目很简单，它完全复制Material Design图标的XML文件到res目录下作成一个library以供使用，所以我们都可以很快做出来。
此外，它的图标来源于&lt;a href=&#34;https://materialdesignicons.com/&#34;&gt;https://materialdesignicons.com/&lt;/a&gt;，除了Google官方的那些Material Design风格图标之外，还包含了一些社区（Community）创作的Material Design风格图标，加起来总共约有4000个图标，实在是够用了。&lt;/p&gt;

&lt;p&gt;Iconify的Github网址：&lt;a href=&#34;https://github.com/JoanZapata/android-iconify&#34;&gt;https://github.com/JoanZapata/android-iconify&lt;/a&gt;
这个项目非常棒，首先它将Font Awesome、Material Design等图标都封装成简单可用的字体，通过自定义的TextView去解析自定义字体的文本来显示出图标。而且它还自定义了&lt;code&gt;IconDrawable&lt;/code&gt;类，支持将图标作为Drawable使用，真的是炒鸡赞的项目！
该项目的设计非常好，易于扩展，它将来自Google的Material Design图标和来自Community的Material Design图标分拆成两个独立的模块以供使用。后面会简单介绍如何对它进行扩展。&lt;/p&gt;

&lt;p&gt;下图显示了Iconify的使用方式：
&lt;img src=&#34;https://hujiaweibujidao.github.io/images/iconify.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面通过Iconify中的几个主要的类来介绍下Iconify的内部实现：&lt;/p&gt;

&lt;h5 id=&#34;1-icon-接口&#34;&gt;（1）&lt;code&gt;Icon&lt;/code&gt;接口&lt;/h5&gt;

&lt;p&gt;描述图标的信息。每个图标都有一个key和character，key代表图标的名称，例如&lt;code&gt;fa-ok&lt;/code&gt;，character代表图标对应的Unicode，例如&lt;code&gt;\u4354&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Icon represents one icon in an icon font.
 */
public interface Icon {
    /** The key of icon, for example &#39;fa-ok&#39; */
    String key();//key代表图标字体的名称，例如`fa-ok`

    /** The character matching the key in the font, for example &#39;\u4354&#39; */
    char character();//character代表图标对应的Unicode码，例如`\u4354`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-iconfontdescriptor-接口&#34;&gt;（2）&lt;code&gt;IconFontDescriptor&lt;/code&gt;接口&lt;/h5&gt;

&lt;p&gt;描述图标字体的信息，包括它对应的ttf字体文件和图标集合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * An IconFontDescriptor defines a TTF font file
 * and is able to map keys with characters in this file.
 */
public interface IconFontDescriptor {
    /**
     * The TTF file name.
     * @return a name with no slash, present in the assets.
     */
    String ttfFileName();//assets目录下的字体文件

    Icon[] characters();//图标字体集合
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-iconify-类&#34;&gt;（3）&lt;code&gt;Iconify&lt;/code&gt;类&lt;/h5&gt;

&lt;p&gt;最主要的核心类，调用&lt;code&gt;with&lt;/code&gt;方法来添加图标字体集合。&lt;a href=&#34;https://github.com/JoanZapata/android-iconify/blob/master/android-iconify/src/main/java/com/joanzapata/iconify/Iconify.java&#34;&gt;查看源码&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Add support for a new icon font.
 * @param iconFontDescriptor The IconDescriptor holding the ttf file reference and its mappings.
 * @return An initializer instance for chain calls.
 */
public static IconifyInitializer with(IconFontDescriptor iconFontDescriptor) {
    return new IconifyInitializer(iconFontDescriptor);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-其他代码&#34;&gt;（4）其他代码&lt;/h5&gt;

&lt;p&gt;自定义的&lt;code&gt;IconTextView&lt;/code&gt;、&lt;code&gt;IconButton&lt;/code&gt;、&lt;code&gt;IconToggleButton&lt;/code&gt;以及&lt;code&gt;IconDrawable&lt;/code&gt;等，核心实现在&lt;code&gt;ParseUtil&lt;/code&gt;类中，它的&lt;code&gt;compute&lt;/code&gt;方法会去解析设置的文本内容，从中提取出不同字体对应的图标，甚至设置其大小和颜色以及旋转动画效果。
&lt;strong&gt;[简易版本的自定义字体的TextView可以参考&lt;a href=&#34;http://hujiaweibujidao.github.io/blog/2015/07/04/android-text-view-with-custom-font/&#34;&gt;这篇文章&lt;/a&gt;]&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-如何扩展&#34;&gt;（5）如何扩展？&lt;/h5&gt;

&lt;p&gt;如果想要扩展Iconify，只需要一个ttf字体文件和实现&lt;code&gt;IconFontDescriptor&lt;/code&gt;接口的类就行了，可以参考&lt;a href=&#34;https://github.com/JoanZapata/android-iconify/blob/master/android-iconify-fontawesome/src/main/java/com/joanzapata/iconify/fonts/FontAwesomeModule.java&#34;&gt;Font Awesome的图标字体集合的实现&lt;/a&gt;。
为了方便使用，一般还会添加一个枚举，列举出这个图标字体集合中所有图标的key和character对应关系，以Font Awesome图标字体为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum FontAwesomeIcons implements Icon {
    fa_glass(&#39;\uf000&#39;),
    fa_music(&#39;\uf001&#39;),
    fa_search(&#39;\uf002&#39;),
    fa_envelope_o(&#39;\uf003&#39;),
    fa_heart(&#39;\uf004&#39;),
    fa_star(&#39;\uf005&#39;),
    fa_star_o(&#39;\uf006&#39;),
    fa_user(&#39;\uf007&#39;),
    fa_film(&#39;\uf008&#39;),
    fa_th_large(&#39;\uf009&#39;),
    fa_th(&#39;\uf00a&#39;),
    fa_th_list(&#39;\uf00b&#39;),
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我比较喜欢Iconify的使用方式，简洁好用，嘿嘿，欢迎推荐其他的Material Design图标的使用姿势！&lt;/p&gt;

&lt;p&gt;在实际的项目开发中肯定会有很多自定义的小图标或者来自不同来源的小图标，如果遇到这种情况该怎么办呢？这个时候我们可以通过对Iconify进行扩展来实现，但是扩展之前我们需要制作出自己的图标字体文件，这个该如何制作呢？请看下节！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>