<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       Lint Tool Analysis (3) &middot;  Hujiawei Bujidao
    </title>

    <meta name="generator" content="Hugo 0.67.0" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" Lint Tool Analysis (3) &middot;  Hujiawei Bujidao" />
  	<meta property="og:site_name" content="Hujiawei Bujidao" />
  	<meta property="og:url" content="https://hujiaweibujidao.github.io/blog/2016/11/19/lint-tool-analysis-3/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2016-11-19T10:46:33&#43;08:00" />
    
    <meta property="og:article:tag" content="android" />
    
    

    <meta name="description" content="Happy Coding &amp; Enjoy Living" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hujiaweibujidao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hujiaweibujidao.github.io/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/highlight.css">
    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/github-gist.css">
    
    <script src="https://hujiaweibujidao.github.io/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

    
    

    

    <link rel="canonical" href="https://hujiaweibujidao.github.io/blog/2016/11/19/lint-tool-analysis-3/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/">Home</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/about">About</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">tags/algorithm</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/android/">tags/android</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/swift/">tags/swift</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/reactnative/">tags/reactnative</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/python/">tags/python</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/java/">tags/java</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/dev/">tags/dev</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/life/">tags/life</a></li>
    </ul>

    
    

    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Lint Tool Analysis (3)</h1>
            <h2 class="page-description">Hujiawei Bujidao</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/hujiaweibujidao" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


    <a class="bloglogo" href="https://weibo.com/hujiaweiyinger" target="_blank">
        <span class="icon-twitter" style="color:white;font-size:2em"></span>
    </a>
&nbsp;




    <a class="bloglogo" href="https://www.linkedin.com/in/hujiaweibujidao" target="_blank">
        <span class="icon-linkedin" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Lint Tool Analysis (3)</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/android/">#android</a></span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2016-11-19T10:46:33&#43;08:00">
            2016/11/19
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>Lint工具的源码分析(3)</p>
<p><strong>本系列的几篇源码分析文档意义不大，如果你正好也在研究lint源码，或者你想知道前面自定义lint规则中提出的那几个问题，抑或你只是想大致了解下lint的源码都有些什么内容的话，这些文章可能有还些作用，否则看了和没看差不多的，因为这几篇文章只是我在读源码的过程中记录下来的一些零碎的片段，方便以后看的时候能够迅速上手。</strong></p>
<p>前面我们提了很多lint工具中<code>detector.api</code>和<code>client.api</code>包下的类，但是还没介绍到lint检查器到底是如何对文件进行检查的，这也就是本节需要介绍的知识点。</p>
<h3 id="3-lint检查器的前提知识">3. Lint检查器的前提知识</h3>
<p>首先我们需要了解的是，lint工具在实现lint检查时使用了Visitor设计模式，推荐阅读<a href="http://en.wikipedia.org/wiki/Visitor_pattern">这篇文章</a>看下一般如何来实现这个设计模式。我们每个lint检查器在使用之前都要进行注册，注册的时候它也指明了它的工作范围以及它感兴趣的文件、方法甚至语句等。当lint工具开始扫描项目文件进行lint检查时，如果发现某个检查器感兴趣的内容就会交给对应的检查器去做相应的检查，如果有错就会报出错误，如果没有就表示代码通过检查，这就是一种visitor模式的体现。</p>
<p>其次我们需要知道的是关于Java代码的解析，一般来说，对代码的解析都是将其转换成抽象语法树，英文名是Abstract Syntax Tree，它是开发工具中很多功能的内部实现原理，例如删除无用的声明语句，变量重命名等。推荐阅读<a href="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/">Abstract Syntax Tree</a>这篇文章来了解AST，其中也介绍到了Visitor设计模式，并简单道出了lint检查的核心原理。</p>
<p>最后，关于lint工具的实现还有不少有意思的槽点，下面的几段英文内容摘录自<a href="http://code.google.com/p/android/issues/detail?id=224584">google code上关于lint工具的一个讨论</a>，其中lint开发者解释了他们在实现Java文件解析时的技术方案选型原因、目前存在的问题以及将来的开发方向。</p>
<p>In 2.2, I&rsquo;ve completely rewritten the Java handling in lint. This was necessary in order to support Java 8 (which Nougat now supports). To do this, I replaced the Lombok AST stuff (which didn&rsquo;t even properly support Java 7) with &ldquo;PSI&rdquo; (which are the same APIs as IntelliJ is using internally, except in lint&rsquo;s case, it&rsquo;s backed by a bridge to ECJ). This has a bunch of advantages: the PSI API is much cleaner, it contains type resolution right built in (instead of the ugly parallel ResolvedNode hierarchy I built up to augment Lombok which didn&rsquo;t support type resolution). So for example, when you&rsquo;re handed a method call node, you can call .resolve() on it and it will return the method the call invokes etc etc.</p>
<p><strong>[大致内容]</strong> 在Android Studio 2.2版本中，为了支持Java 8(Android Nougat支持Java 8)，开发者完全重写了lint工具中对Java代码的解析。以前使用的是<code>Lombok AST</code>(连Java 7都不支持)，现在使用的是<code>PSI</code>(和Intellij内部对Java代码解析使用的是同一套API，但是lint除外，它使用的是<code>ECJ [Eclipse Compiler for Java]</code>)。<br>
PSI API有很多好处，它更加简洁，并且内置了类型解析功能(Lombok不知道类型解析)。所以，开发者将原有的lint检查项基本上全部使用PSI API重写了一遍，下面是重写的<a href="https://android.googlesource.com/platform/tools/base/+/8cdccd1bdf595b9b5e9a040a380d5a3372807fb2">提交记录</a>。</p>
<p>However, I didn&rsquo;t actually delete the old Lombok code path, since some people my have custom rules using Lombok. So, if lint comes across a project that is using custom lint rules, it has to process the file TWICE: first using the PSI bridge, and then all over again with Lombok. This obviously slows downs things.</p>
<p><strong>[大致内容]</strong> 但是，考虑到还是有人会使用Lombok API来开发自定义的lint规则，所以开发者并没有删除旧的Lombok相关代码。这也导致如果项目中使用了旧的API自定义的lint规则的话，lint会对这个文件检查两次，从而使得lint检查的速度变慢。</p>
<p>I have a commented out warning in the lint driver which emits a warning when this is the case (basically explaining that lint came across a custom lint rule which is using the old APIs, which still works, but slows things down and may not work in the future.)</p>
<p>However, I disabled that because I may still do another big change to the APIs &ndash; and I don&rsquo;t want to force everyone to jump through hoops of porting their lint checks to the new 2.2 APIs, only to have them change them again shortly.</p>
<p>The API change I&rsquo;m referring to is UAST; a &ldquo;universal AST&rdquo; that JetBrains is working on. It&rsquo;s pretty similar to PSI (so certainly porting to the current PSI apis will make a much smaller migration to UAST than straight from Lombok), but the idea is that it&rsquo;s a bit more language agnostic, so for example a single lint AST check can work not just with Java but also transparently with Kotlin, etc.</p>
<p><strong>[大致内容]</strong> 虽然开发者目前已经将Lombok API升级到PSI API，但是他们正在计划着做另一个重大的变化，也就是升级到<code>UAST</code> API，这个是JetBrains目前正在做的。它和PSI API类似，但是思想上更加先进，更加与语言无关，例如一个简单的lint检查可能不止可以作用在Java代码上，也能作用在Kotlin代码上。</p>
<p>假设现在我们想要将原来的Lombok API形式的lint检查升级到PSI API形式，我们该如何做呢？<br>
详情可以参考<code>JavaPsiScanner</code>类的注释内容，其中详细介绍了如何将API轻松迁移，但是轻松只是相对于那些熟悉PSI API的开发者，对于不熟悉它的开发者来说，这种迁移还是比较困难的。当我们自定义lint检查器的时候需要注意 <strong>lint-api的版本问题</strong>，不同版本的Java检查器需要实现的接口有差异。<br>
(1) <code>compile 'com.android.tools.lint:lint-api:24.5.0'</code><br>
使用<code>JavaScanner</code> =&gt; older Lombok AST API<br>
(2) <code>compile 'com.android.tools.lint:lint-api:25.2.0'</code><br>
需要迁移到<code>JavaPsiScanner</code> =&gt; IntelliJ IDEA&rsquo;s &ldquo;PSI&rdquo; API</p>
<h3 id="4-java代码的lint检查器">4. Java代码的Lint检查器</h3>
<p>(1) <code>JavaParser</code><br>
解析Java文件的抽象类，实际实现类是<code>LombokPsiParser</code>，将来可能会被修改为其他的Parser。</p>
<p>(2) <code>JavaPsiScanner</code><br>
<strong>注意：在最新的25.2.0版本的lint-api中JavaScanner已经被注明为deprecated了，推荐使用JavaPsiScanner。</strong><br>
下面是<code>JavaPsiScanner</code>接口的源码，任何对Java源代码文件进行lint检查的Detector都需要实现这个接口，主要是定义了几个<code>visit</code>方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">JavaPsiScanner</span>  <span style="color:#f92672">{</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Create a parse tree visitor to process the parse tree. All
</span><span style="color:#75715e">     * {@link JavaScanner} detectors must provide a visitor, unless they
</span><span style="color:#75715e">     * either return true from {@link #appliesToResourceRefs()} or return
</span><span style="color:#75715e">     * non null from {@link #getApplicableMethodNames()}.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * If you return specific AST node types from
</span><span style="color:#75715e">     * {@link #getApplicablePsiTypes()}, then the visitor will &lt;b&gt;only&lt;/b&gt;
</span><span style="color:#75715e">     * be called for the specific requested node types. This is more
</span><span style="color:#75715e">     * efficient, since it allows many detectors that apply to only a small
</span><span style="color:#75715e">     * part of the AST (such as method call nodes) to share iteration of the
</span><span style="color:#75715e">     * majority of the parse tree.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * If you return null from {@link #getApplicablePsiTypes()}, then your
</span><span style="color:#75715e">     * visitor will be called from the top and all node types visited.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * Note that a new visitor is created for each separate compilation
</span><span style="color:#75715e">     * unit, so you can store per file state in the visitor.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * &lt;b&gt;
</span><span style="color:#75715e">     * NOTE: Your visitor should &lt;b&gt;NOT&lt;/b&gt; extend JavaRecursiveElementVisitor.
</span><span style="color:#75715e">     * Your visitor should only visit the current node type; the infrastructure
</span><span style="color:#75715e">     * will do the recursion. (Lint&#39;s unit test infrastructure will check and
</span><span style="color:#75715e">     * enforce this restriction.)
</span><span style="color:#75715e">     * &lt;/b&gt;
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context the {@link Context} for the file being analyzed
</span><span style="color:#75715e">     * @return a visitor, or null.
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    JavaElementVisitor <span style="color:#a6e22e">createPsiVisitor</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">);</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Return the types of AST nodes that the visitor returned from
</span><span style="color:#75715e">     * {@link #createJavaVisitor(JavaContext)} should visit. See the
</span><span style="color:#75715e">     * documentation for {@link #createJavaVisitor(JavaContext)} for details
</span><span style="color:#75715e">     * on how the shared visitor is used.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * If you return null from this method, then the visitor will process
</span><span style="color:#75715e">     * the full tree instead.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * Note that for the shared visitor, the return codes from the visit
</span><span style="color:#75715e">     * methods are ignored: returning true will &lt;b&gt;not&lt;/b&gt; prune iteration
</span><span style="color:#75715e">     * of the subtree, since there may be other node types interested in the
</span><span style="color:#75715e">     * children. If you need to ensure that your visitor only processes a
</span><span style="color:#75715e">     * part of the tree, use a full visitor instead. See the
</span><span style="color:#75715e">     * OverdrawDetector implementation for an example of this.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return the list of applicable node types (AST node classes), or null
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    List<span style="color:#f92672">&lt;</span>Class<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> PsiElement<span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">getApplicablePsiTypes</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Return the list of method names this detector is interested in, or
</span><span style="color:#75715e">     * null. If this method returns non-null, then any AST nodes that match
</span><span style="color:#75715e">     * a method call in the list will be passed to the
</span><span style="color:#75715e">     * {@link #visitMethod(JavaContext, JavaElementVisitor, PsiMethodCallExpression, PsiMethod)}
</span><span style="color:#75715e">     * method for processing. The visitor created by
</span><span style="color:#75715e">     * {@link #createPsiVisitor(JavaContext)} is also passed to that
</span><span style="color:#75715e">     * method, although it can be null.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * This makes it easy to write detectors that focus on some fixed calls.
</span><span style="color:#75715e">     * For example, the StringFormatDetector uses this mechanism to look for
</span><span style="color:#75715e">     * &#34;format&#34; calls, and when found it looks around (using the AST&#39;s
</span><span style="color:#75715e">     * {@link PsiElement#getParent()} method) to see if it&#39;s called on
</span><span style="color:#75715e">     * a String class instance, and if so do its normal processing. Note
</span><span style="color:#75715e">     * that since it doesn&#39;t need to do any other AST processing, that
</span><span style="color:#75715e">     * detector does not actually supply a visitor.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return a set of applicable method names, or null.
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getApplicableMethodNames</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Method invoked for any method calls found that matches any names
</span><span style="color:#75715e">     * returned by {@link #getApplicableMethodNames()}. This also passes
</span><span style="color:#75715e">     * back the visitor that was created by
</span><span style="color:#75715e">     * {@link #createJavaVisitor(JavaContext)}, but a visitor is not
</span><span style="color:#75715e">     * required. It is intended for detectors that need to do additional AST
</span><span style="color:#75715e">     * processing, but also want the convenience of not having to look for
</span><span style="color:#75715e">     * method names on their own.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context the context of the lint request
</span><span style="color:#75715e">     * @param visitor the visitor created from
</span><span style="color:#75715e">     *            {@link #createPsiVisitor(JavaContext)}, or null
</span><span style="color:#75715e">     * @param call the {@link PsiMethodCallExpression} node for the invoked method
</span><span style="color:#75715e">     * @param method the {@link PsiMethod} being called
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitMethod</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@Nullable</span> JavaElementVisitor visitor<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiMethodCallExpression call<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiMethod method<span style="color:#f92672">);</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Return the list of constructor types this detector is interested in, or
</span><span style="color:#75715e">     * null. If this method returns non-null, then any AST nodes that match
</span><span style="color:#75715e">     * a constructor call in the list will be passed to the
</span><span style="color:#75715e">     * {@link #visitConstructor(JavaContext, JavaElementVisitor, PsiNewExpression, PsiMethod)}
</span><span style="color:#75715e">     * method for processing. The visitor created by
</span><span style="color:#75715e">     * {@link #createJavaVisitor(JavaContext)} is also passed to that
</span><span style="color:#75715e">     * method, although it can be null.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * This makes it easy to write detectors that focus on some fixed constructors.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return a set of applicable fully qualified types, or null.
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getApplicableConstructorTypes</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Method invoked for any constructor calls found that matches any names
</span><span style="color:#75715e">     * returned by {@link #getApplicableConstructorTypes()}. This also passes
</span><span style="color:#75715e">     * back the visitor that was created by
</span><span style="color:#75715e">     * {@link #createPsiVisitor(JavaContext)}, but a visitor is not
</span><span style="color:#75715e">     * required. It is intended for detectors that need to do additional AST
</span><span style="color:#75715e">     * processing, but also want the convenience of not having to look for
</span><span style="color:#75715e">     * method names on their own.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context the context of the lint request
</span><span style="color:#75715e">     * @param visitor the visitor created from
</span><span style="color:#75715e">     *            {@link #createPsiVisitor(JavaContext)}, or null
</span><span style="color:#75715e">     * @param node the {@link PsiNewExpression} node for the invoked method
</span><span style="color:#75715e">     * @param constructor the called constructor method
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitConstructor</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@Nullable</span> JavaElementVisitor visitor<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiNewExpression node<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiMethod constructor<span style="color:#f92672">);</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Return the list of reference names types this detector is interested in, or null. If this
</span><span style="color:#75715e">     * method returns non-null, then any AST elements that match a reference in the list will be
</span><span style="color:#75715e">     * passed to the {@link #visitReference(JavaContext, JavaElementVisitor,
</span><span style="color:#75715e">     * PsiJavaCodeReferenceElement, PsiElement)} method for processing. The visitor created by
</span><span style="color:#75715e">     * {@link #createJavaVisitor(JavaContext)} is also passed to that method, although it can be
</span><span style="color:#75715e">     * null. &lt;p&gt; This makes it easy to write detectors that focus on some fixed references.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return a set of applicable reference names, or null.
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getApplicableReferenceNames</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Method invoked for any references found that matches any names returned by {@link
</span><span style="color:#75715e">     * #getApplicableReferenceNames()}. This also passes back the visitor that was created by
</span><span style="color:#75715e">     * {@link #createPsiVisitor(JavaContext)}, but a visitor is not required. It is intended for
</span><span style="color:#75715e">     * detectors that need to do additional AST processing, but also want the convenience of not
</span><span style="color:#75715e">     * having to look for method names on their own.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context    the context of the lint request
</span><span style="color:#75715e">     * @param visitor    the visitor created from {@link #createPsiVisitor(JavaContext)}, or
</span><span style="color:#75715e">     *                   null
</span><span style="color:#75715e">     * @param reference  the {@link PsiJavaCodeReferenceElement} element
</span><span style="color:#75715e">     * @param referenced the referenced element
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitReference</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@Nullable</span> JavaElementVisitor visitor<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiJavaCodeReferenceElement reference<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiElement referenced<span style="color:#f92672">);</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Returns whether this detector cares about Android resource references
</span><span style="color:#75715e">     * (such as {@code R.layout.main} or {@code R.string.app_name}). If it
</span><span style="color:#75715e">     * does, then the visitor will look for these patterns, and if found, it
</span><span style="color:#75715e">     * will invoke {@link #visitResourceReference} passing the resource type
</span><span style="color:#75715e">     * and resource name. It also passes the visitor, if any, that was
</span><span style="color:#75715e">     * created by {@link #createJavaVisitor(JavaContext)}, such that a
</span><span style="color:#75715e">     * detector can do more than just look for resources.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return true if this detector wants to be notified of R resource
</span><span style="color:#75715e">     *         identifiers found in the code.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">appliesToResourceRefs</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Called for any resource references (such as {@code R.layout.main}
</span><span style="color:#75715e">     * found in Java code, provided this detector returned {@code true} from
</span><span style="color:#75715e">     * {@link #appliesToResourceRefs()}.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context the lint scanning context
</span><span style="color:#75715e">     * @param visitor the visitor created from
</span><span style="color:#75715e">     *            {@link #createPsiVisitor(JavaContext)}, or null
</span><span style="color:#75715e">     * @param node the variable reference for the resource
</span><span style="color:#75715e">     * @param type the resource type, such as &#34;layout&#34; or &#34;string&#34;
</span><span style="color:#75715e">     * @param name the resource name, such as &#34;main&#34; from
</span><span style="color:#75715e">     *            {@code R.layout.main}
</span><span style="color:#75715e">     * @param isFramework whether the resource is a framework resource
</span><span style="color:#75715e">     *            (android.R) or a local project resource (R)
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitResourceReference</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@Nullable</span> JavaElementVisitor visitor<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiElement node<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> ResourceType type<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> String name<span style="color:#f92672">,</span>
            <span style="color:#66d9ef">boolean</span> isFramework<span style="color:#f92672">);</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Returns a list of fully qualified names for super classes that this
</span><span style="color:#75715e">     * detector cares about. If not null, this detector will &lt;b&gt;only&lt;/b&gt; be called
</span><span style="color:#75715e">     * if the current class is a subclass of one of the specified superclasses.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @return a list of fully qualified names
</span><span style="color:#75715e">     */</span>
    <span style="color:#a6e22e">@Nullable</span>
    List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">applicableSuperClasses</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Called for each class that extends one of the super classes specified with
</span><span style="color:#75715e">     * {@link #applicableSuperClasses()}.
</span><span style="color:#75715e">     * &lt;p&gt;
</span><span style="color:#75715e">     * Note: This method will not be called for {@link PsiTypeParameter} classes. These
</span><span style="color:#75715e">     * aren&#39;t really classes in the sense most lint detectors think of them, so these
</span><span style="color:#75715e">     * are excluded to avoid having lint checks that don&#39;t defensively code for these
</span><span style="color:#75715e">     * accidentally report errors on type parameters. If you really need to check these,
</span><span style="color:#75715e">     * use {@link #getApplicablePsiTypes} with {@code PsiTypeParameter.class} instead.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param context the lint scanning context
</span><span style="color:#75715e">     * @param declaration the class declaration node, or null for anonymous classes
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">checkClass</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span> <span style="color:#a6e22e">@NonNull</span> PsiClass declaration<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>(3) 下面以<code>LogDetector</code>为例，介绍下一个Java代码的Lint检查器的大致结构：<br>
① 首先声明<code>LogDetector</code>继承自<code>Detector</code>并实现了<code>JavaPsiScanner</code>接口，<code>Detector</code>类是检查器的适配器类，<code>JavaPsiScanner</code>接口是对Java代码文件进行检查的接口；<br>
② 接着定义一个<code>Implementation</code>实例，声明这个检查器的实现类是<code>LogDetector.class</code>，它的检查范围是<code>Scope.JAVA_FILE_SCOPE</code>，也就是Java代码文件；<br>
③ 然后定义这个检查器将会检查代码中是否存在的<code>Issue</code>，每个问题有名称(<code>LogConditional</code>)、描述、类别(<code>Category.PERFORMANCE</code>)、等级(<code>5</code>)、严重程度(<code>Severity.WARNING</code>)、检查器的实现类以及是否默认开启等信息；<br>
④ 接着在方法<code>getApplicableMethodNames</code>中声明这个检查器关心的方法，因为这个检查器是检查应用中的log是否符合规范，所以比较关心<code>d/e/i/v/w</code>等常见的log打印方法；<br>
⑤ 最后就是在方法<code>visitMethod</code>中对上面声明的并且在lint检查时遇到的那些方法进行检查，看它们是否符合规范，如果不符合规范的话就会report出错误信息。源代码文件中声明其他的变量和私有方法都是为了完成检查过程定义的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Detector for finding inefficiencies and errors in logging calls.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogDetector</span> <span style="color:#66d9ef">extends</span> Detector <span style="color:#66d9ef">implements</span> JavaPsiScanner <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Implementation IMPLEMENTATION <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Implementation<span style="color:#f92672">(</span>
          LogDetector<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span> Scope<span style="color:#f92672">.</span><span style="color:#a6e22e">JAVA_FILE_SCOPE</span><span style="color:#f92672">);</span>

    <span style="color:#75715e">/** Log call missing surrounding if */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Issue CONDITIONAL <span style="color:#f92672">=</span> Issue<span style="color:#f92672">.</span><span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>
            <span style="color:#e6db74">&#34;LogConditional&#34;</span><span style="color:#f92672">,</span> <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>            <span style="color:#e6db74">&#34;Unconditional Logging Calls&#34;</span><span style="color:#f92672">,</span>
            <span style="color:#e6db74">&#34;The BuildConfig class (available in Tools 17) provides a constant, \&#34;DEBUG\&#34;, &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;which indicates whether the code is being built in release mode or in debug &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;mode. In release mode, you typically want to strip out all the logging calls. &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;Since the compiler will automatically remove all code which is inside a &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;\&#34;if (false)\&#34; check, surrounding your logging calls with a check for &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;BuildConfig.DEBUG is a good idea.\n&#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;If you *really* intend for the logging to be present in release mode, you can &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;suppress this warning with a @SuppressLint annotation for the intentional &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;logging calls.&#34;</span><span style="color:#f92672">,</span>

            Category<span style="color:#f92672">.</span><span style="color:#a6e22e">PERFORMANCE</span><span style="color:#f92672">,</span>
            5<span style="color:#f92672">,</span>
            Severity<span style="color:#f92672">.</span><span style="color:#a6e22e">WARNING</span><span style="color:#f92672">,</span>
            IMPLEMENTATION<span style="color:#f92672">).</span><span style="color:#a6e22e">setEnabledByDefault</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>

    <span style="color:#75715e">/** Mismatched tags between isLogging and log calls within it */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Issue WRONG_TAG <span style="color:#f92672">=</span> Issue<span style="color:#f92672">.</span><span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>
            <span style="color:#e6db74">&#34;LogTagMismatch&#34;</span><span style="color:#f92672">,</span> <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>            <span style="color:#e6db74">&#34;Mismatched Log Tags&#34;</span><span style="color:#f92672">,</span>
            <span style="color:#e6db74">&#34;When guarding a `Log.v(tag, ...)` call with `Log.isLoggable(tag)`, the &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;tag passed to both calls should be the same. Similarly, the level passed &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;in to `Log.isLoggable` should typically match the type of `Log` call, e.g. &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;if checking level `Log.DEBUG`, the corresponding `Log` call should be `Log.d`, &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;not `Log.i`.&#34;</span><span style="color:#f92672">,</span>

            Category<span style="color:#f92672">.</span><span style="color:#a6e22e">CORRECTNESS</span><span style="color:#f92672">,</span>
            5<span style="color:#f92672">,</span>
            Severity<span style="color:#f92672">.</span><span style="color:#a6e22e">ERROR</span><span style="color:#f92672">,</span>
            IMPLEMENTATION<span style="color:#f92672">);</span>

    <span style="color:#75715e">/** Log tag is too long */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Issue LONG_TAG <span style="color:#f92672">=</span> Issue<span style="color:#f92672">.</span><span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>
            <span style="color:#e6db74">&#34;LongLogTag&#34;</span><span style="color:#f92672">,</span> <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>            <span style="color:#e6db74">&#34;Too Long Log Tags&#34;</span><span style="color:#f92672">,</span>
            <span style="color:#e6db74">&#34;Log tags are only allowed to be at most 23 tag characters long.&#34;</span><span style="color:#f92672">,</span>

            Category<span style="color:#f92672">.</span><span style="color:#a6e22e">CORRECTNESS</span><span style="color:#f92672">,</span>
            5<span style="color:#f92672">,</span>
            Severity<span style="color:#f92672">.</span><span style="color:#a6e22e">ERROR</span><span style="color:#f92672">,</span>
            IMPLEMENTATION<span style="color:#f92672">);</span>

    <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;SpellCheckingInspection&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String IS_LOGGABLE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;isLoggable&#34;</span><span style="color:#f92672">;</span>       <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String LOG_CLS <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;android.util.Log&#34;</span><span style="color:#f92672">;</span>     <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String PRINTLN <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;println&#34;</span><span style="color:#f92672">;</span>              <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// ---- Implements Detector.JavaScanner ----
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getApplicableMethodNames</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>
                <span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">,</span>           <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#34;e&#34;</span><span style="color:#f92672">,</span>           <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span>           <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#34;v&#34;</span><span style="color:#f92672">,</span>           <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#34;w&#34;</span><span style="color:#f92672">,</span>           <span style="color:#75715e">//$NON-NLS-1$
</span><span style="color:#75715e"></span>                PRINTLN<span style="color:#f92672">,</span>
                IS_LOGGABLE<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visitMethod</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Nullable</span> JavaElementVisitor visitor<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiMethodCallExpression node<span style="color:#f92672">,</span> <span style="color:#a6e22e">@NonNull</span> PsiMethod method<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        JavaEvaluator evaluator <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">getEvaluator</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>evaluator<span style="color:#f92672">.</span><span style="color:#a6e22e">isMemberInClass</span><span style="color:#f92672">(</span>method<span style="color:#f92672">,</span> LOG_CLS<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        String name <span style="color:#f92672">=</span> method<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">boolean</span> withinConditional <span style="color:#f92672">=</span> IS_LOGGABLE<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">||</span>
                checkWithinConditional<span style="color:#f92672">(</span>context<span style="color:#f92672">,</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">getParent</span><span style="color:#f92672">(),</span> node<span style="color:#f92672">);</span>

        <span style="color:#75715e">// See if it&#39;s surrounded by an if statement (and it&#39;s one of the non-error, spammy
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// log methods (info, verbose, etc))
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span><span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;v&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> PRINTLN<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">))</span>
                <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>withinConditional
                <span style="color:#f92672">&amp;&amp;</span> performsWork<span style="color:#f92672">(</span>context<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span>
                <span style="color:#f92672">&amp;&amp;</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">isEnabled</span><span style="color:#f92672">(</span>CONDITIONAL<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            String message <span style="color:#f92672">=</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;The log call Log.%1$s(...) should be &#34;</span> <span style="color:#f92672">+</span>
                            <span style="color:#e6db74">&#34;conditional: surround with `if (Log.isLoggable(...))` or &#34;</span> <span style="color:#f92672">+</span>
                            <span style="color:#e6db74">&#34;`if (BuildConfig.DEBUG) { ... }`&#34;</span><span style="color:#f92672">,</span>
                    node<span style="color:#f92672">.</span><span style="color:#a6e22e">getMethodExpression</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getReferenceName</span><span style="color:#f92672">());</span>
            context<span style="color:#f92672">.</span><span style="color:#a6e22e">report</span><span style="color:#f92672">(</span>CONDITIONAL<span style="color:#f92672">,</span> node<span style="color:#f92672">,</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">getLocation</span><span style="color:#f92672">(</span>node<span style="color:#f92672">),</span> message<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// Check tag length
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>context<span style="color:#f92672">.</span><span style="color:#a6e22e">isEnabled</span><span style="color:#f92672">(</span>LONG_TAG<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> tagArgumentIndex <span style="color:#f92672">=</span> PRINTLN<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> 0<span style="color:#f92672">;</span>
            PsiParameterList parameterList <span style="color:#f92672">=</span> method<span style="color:#f92672">.</span><span style="color:#a6e22e">getParameterList</span><span style="color:#f92672">();</span>
            PsiExpressionList argumentList <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">getArgumentList</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>evaluator<span style="color:#f92672">.</span><span style="color:#a6e22e">parameterHasType</span><span style="color:#f92672">(</span>method<span style="color:#f92672">,</span> tagArgumentIndex<span style="color:#f92672">,</span> TYPE_STRING<span style="color:#f92672">)</span>
                    <span style="color:#f92672">&amp;&amp;</span> parameterList<span style="color:#f92672">.</span><span style="color:#a6e22e">getParametersCount</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> argumentList<span style="color:#f92672">.</span><span style="color:#a6e22e">getExpressions</span><span style="color:#f92672">().</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                PsiExpression argument <span style="color:#f92672">=</span> argumentList<span style="color:#f92672">.</span><span style="color:#a6e22e">getExpressions</span><span style="color:#f92672">()[</span>tagArgumentIndex<span style="color:#f92672">];</span>
                String tag <span style="color:#f92672">=</span> ConstantEvaluator<span style="color:#f92672">.</span><span style="color:#a6e22e">evaluateString</span><span style="color:#f92672">(</span>context<span style="color:#f92672">,</span> argument<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tag <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> tag<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> 23<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    String message <span style="color:#f92672">=</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                            <span style="color:#e6db74">&#34;The logging tag can be at most 23 characters, was %1$d (%2$s)&#34;</span><span style="color:#f92672">,</span>
                            tag<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">(),</span> tag<span style="color:#f92672">);</span>
                    context<span style="color:#f92672">.</span><span style="color:#a6e22e">report</span><span style="color:#f92672">(</span>LONG_TAG<span style="color:#f92672">,</span> node<span style="color:#f92672">,</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">getLocation</span><span style="color:#f92672">(</span>node<span style="color:#f92672">),</span> message<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/** Returns true if the given logging call performs &#34;work&#34; to compute the message */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">performsWork</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span>
            <span style="color:#a6e22e">@NonNull</span> PsiMethodCallExpression node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">checkWithinConditional</span><span style="color:#f92672">(</span>
            <span style="color:#a6e22e">@NonNull</span> JavaContext context<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Nullable</span> PsiElement curr<span style="color:#f92672">,</span> <span style="color:#a6e22e">@NonNull</span> PsiMethodCallExpression logCall<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/** Checks that the tag passed to Log.s and Log.isLoggable match */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">checkTagConsistent</span><span style="color:#f92672">(</span>JavaContext context<span style="color:#f92672">,</span> PsiMethodCallExpression logCall<span style="color:#f92672">,</span>
            PsiMethodCallExpression isLoggableCall<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>上面是一个简单的Java检查器的实现，但是足以让我们理解lint检查是如何进行的，以及辅助我们去了解其他的检查器的实现，甚至是针对其他类型的文件比如XML文件的检查器，它们的实现过程也大致类似。那如果我们的检查器既需要检查Java文件，又需要检查XML文件怎么办呢？其实也就是多实现一个接口就行了，很多自带的检查器都是实现了<code>XmlScanner</code>和<code>JavaPsiScanner</code>两个接口的。</p>
<p>下一节我们会总结下lint工具中自带的一些和Android有关的检查器的功能。</p>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://hujiaweibujidao.github.io/" style="background-image: url(https://hujiaweibujidao.github.io/images/logo.gif)"><span class="hidden">hujiawei's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> Hujiawei is a mobile developer</span>
    <span class="author-location icon-location"> Guangdong, China</span>
    <span class="author-link icon-link"><a href="https://hujiaweibujidao.github.io/"> https://hujiaweibujidao.github.io/</a></span>
    

    
  </div>
  <br/>
</section>


      
        <aside class="read-next">
  
      <span class="readmore-prev readmore-meta">PREV: <a href="https://hujiaweibujidao.github.io/blog/2016/12/01/builtin-lint-detectors-1/"><h4>Builtin Lint Detectors (1)</h4></a></span>
      
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://hujiaweibujidao.github.io/blog/2016/11/18/lint-tool-analysis-2/"><h4>Lint Tool Analysis (2)</h4></a></span>
      
  
</aside>
<br/>

      
      
      
    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">Hujiawei Bujidao. </a> All rights reserved &copy; 2013 - 2020</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
            
            <script type="text/javascript">
                var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
                document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
            </script>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/index.js"></script>

    
    
    
    

    
</body>
</html>

