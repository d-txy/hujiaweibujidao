<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       Python Data Structures - C2 Sort &middot;  Hujiawei Bujidao
    </title>

    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" Python Data Structures - C2 Sort &middot;  Hujiawei Bujidao" />
  	<meta property="og:site_name" content="Hujiawei Bujidao" />
  	<meta property="og:url" content="https://hujiaweibujidao.github.io/blog/2014/05/07/python-data-structures-c2-sort/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2014-05-07T00:00:00Z" />
    
    <meta property="og:article:tag" content="algorithm" />
    
    <meta property="og:article:tag" content="python" />
    
    

    <meta name="description" content="Happy Coding &amp; Enjoy Living" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hujiaweibujidao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hujiaweibujidao.github.io/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/highlight.css">
    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/github-gist.css">
    
    <script src="https://hujiaweibujidao.github.io/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

    
    

    

    <link rel="canonical" href="https://hujiaweibujidao.github.io/blog/2014/05/07/python-data-structures-c2-sort/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/">首页</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/about">关于</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/android/">Android</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/python/">Python</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">算法</a></li>
        
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/dev/">开发</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/life/">生活</a></li>
    </ul>

    
    

    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">菜单</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Python Data Structures - C2 Sort</h1>
            <h2 class="page-description">Hujiawei Bujidao</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/hujiaweibujidao" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


    <a class="bloglogo" href="https://weibo.com/hujiaweiyinger" target="_blank">
        <span class="icon-twitter" style="color:white;font-size:2em"></span>
    </a>
&nbsp;




    <a class="bloglogo" href="https://www.linkedin.com/in/hujiaweibujidao" target="_blank">
        <span class="icon-linkedin" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Python Data Structures - C2 Sort</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">#algorithm</a></span>
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/python/">#python</a></span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2014-05-07T00:00:00Z">
            2014/5/7
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>Python数据结构篇(2) 排序</p>
<p>参考内容：<br>
1.<a href="http://interactivepython.org/courselib/static/pythonds/index.html">Problem Solving with Python</a><br>
Chapter5: Search and Sorting <a href="http://interactivepython.org/courselib/static/pythonds/SortSearch/sorting.html">online_link</a><br>
2.<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">算法导论</a></p>
<h4 id="排序总结">排序总结</h4>
<p>1.冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。时间复杂度$O(n^2)$</p>
<p><strong>Python支持对两个数字同时进行交换！<code>a,b = b,a</code>就可以交换a和b的值了。</strong></p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/bubblesort.png" alt="image"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">short_bubble_sort</span>(a_list):
    exchanges <span style="color:#f92672">=</span> True
    pass_num <span style="color:#f92672">=</span> len(a_list) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">while</span> pass_num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> exchanges:
        exchanges <span style="color:#f92672">=</span> False
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(pass_num):
            <span style="color:#66d9ef">if</span> a_list[i] <span style="color:#f92672">&gt;</span> a_list[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]:
                exchanges <span style="color:#f92672">=</span> True
                a_list[i],a_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> a_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], a_list[i]
        pass_num <span style="color:#f92672">=</span> pass_num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    a_list<span style="color:#f92672">=</span>[<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">70</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">110</span>, <span style="color:#ae81ff">100</span>]
    short_bubble_sort(a_list)
    <span style="color:#66d9ef">print</span>(a_list)
</code></pre></div><p>2.选择排序(selection sort)：每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。时间复杂度$O(n^2)$</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/selectionsort.png" alt="image"></p>
<pre><code>def selection_sort(a_list):
    for fill_slot in range(len(a_list) - 1, 0, -1):
        pos_of_max = 0
        for location in range(1, fill_slot + 1):
            if a_list[location] &gt; a_list[pos_of_max]:
                pos_of_max = location
        a_list[fill_slot],a_list[pos_of_max]=a_list[pos_of_max],a_list[fill_slot]


a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
selection_sort(a_list)
print(a_list)
</code></pre><p>3.插入排序(insertion sort)：每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到原来的序列中，为了尽快地查找合适的插入位置，可以使用二分查找。时间复杂度$O(n^2)$，别误以为二分查找可以降低它的复杂度，因为插入排序还需要移动元素的操作！</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/insertionsort.png" alt="image"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insertion_sort</span>(a_list):
    <span style="color:#66d9ef">for</span> index <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(a_list)):
        current_value <span style="color:#f92672">=</span> a_list[index]
        position <span style="color:#f92672">=</span> index
        <span style="color:#66d9ef">while</span> position <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> a_list[position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> current_value:
            a_list[position] <span style="color:#f92672">=</span> a_list[position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
            position <span style="color:#f92672">=</span> position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        a_list[position] <span style="color:#f92672">=</span> current_value


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insertion_sort_binarysearch</span>(a_list):
    <span style="color:#66d9ef">for</span> index <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(a_list)):
        current_value <span style="color:#f92672">=</span> a_list[index]
        position <span style="color:#f92672">=</span> index
        low<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
        high<span style="color:#f92672">=</span>index<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> low<span style="color:#f92672">&lt;=</span>high:
            mid<span style="color:#f92672">=</span>(low<span style="color:#f92672">+</span>high)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> a_list[mid]<span style="color:#f92672">&gt;</span>current_value:
                high<span style="color:#f92672">=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                low<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> position <span style="color:#f92672">&gt;</span> low:
            a_list[position] <span style="color:#f92672">=</span> a_list[position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
            position <span style="color:#f92672">=</span> position <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        a_list[position] <span style="color:#f92672">=</span> current_value


a_list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">93</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">20</span>]
insertion_sort(a_list)
<span style="color:#66d9ef">print</span>(a_list)
insertion_sort_binarysearch(a_list)
<span style="color:#66d9ef">print</span>(a_list)
</code></pre></div><p>4.合并排序(merge sort)：典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。时间复杂度$O(nlogn)$</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/mergesort.png" alt="image"></p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/mergesort2.png" alt="image"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">merge_sort</span>(a_list):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Splitting &#34;</span>, a_list)
    <span style="color:#66d9ef">if</span> len(a_list) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
        mid <span style="color:#f92672">=</span> len(a_list) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
        left_half <span style="color:#f92672">=</span> a_list[:mid]
        right_half <span style="color:#f92672">=</span> a_list[mid:]
        merge_sort(left_half)
        merge_sort(right_half)
        i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(left_half) <span style="color:#f92672">and</span> j <span style="color:#f92672">&lt;</span> len(right_half):
            <span style="color:#66d9ef">if</span> left_half[i] <span style="color:#f92672">&lt;</span> right_half[j]:
                a_list[k] <span style="color:#f92672">=</span> left_half[i]
                i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                a_list[k] <span style="color:#f92672">=</span> right_half[j]
                j<span style="color:#f92672">=</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            k<span style="color:#f92672">=</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(left_half):
            a_list[k] <span style="color:#f92672">=</span> left_half[i]
            i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            k<span style="color:#f92672">=</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&lt;</span> len(right_half):
            a_list[k] <span style="color:#f92672">=</span> right_half[j]
            j<span style="color:#f92672">=</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            k<span style="color:#f92672">=</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Merging &#34;</span>, a_list)


a_list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">93</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">20</span>]
merge_sort(a_list)
<span style="color:#66d9ef">print</span>(a_list)
</code></pre></div><p>算法导论2-4题利用合并排序可以在$O(nlogn)$的最坏情况下得到包含n个元素的数组的逆序对的数目。<br>
[下面使用的是C++来实现的，合并排序的代码格式类似算法导论]</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculateInversions</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> r);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mergeInversions</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> r);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[])
{
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">1</span>};
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> calculateInversions(arr, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;count inversions : &#34;</span> <span style="color:#f92672">&lt;&lt;</span> count <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculateInversions</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> r) {
	<span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">&lt;</span> r) {
	    <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> (p <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            count <span style="color:#f92672">+=</span> calculateInversions(arr, p, q);
            count <span style="color:#f92672">+=</span> calculateInversions(arr, q<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, r);
            count <span style="color:#f92672">+=</span> mergeInversions(arr, p, q, r);  
	}
	<span style="color:#66d9ef">return</span> count;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">mergeInversions</span>(<span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> r){
    <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> n1<span style="color:#f92672">=</span>q<span style="color:#f92672">-</span>p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n2<span style="color:#f92672">=</span>r<span style="color:#f92672">-</span>q;
    <span style="color:#66d9ef">int</span> left[n1<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], right[n2<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n1; i<span style="color:#f92672">++</span>) {
        left[i]<span style="color:#f92672">=</span>arr[p<span style="color:#f92672">+</span>i];
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>n2; j<span style="color:#f92672">++</span>) {
        right[j]<span style="color:#f92672">=</span>arr[q<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>j];
    }
    left[n1]<span style="color:#f92672">=</span>INT32_MAX;
    right[n2]<span style="color:#f92672">=</span>INT32_MAX;
    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>p; k<span style="color:#f92672">&lt;=</span>r; k<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (left[i]<span style="color:#f92672">&lt;=</span>right[j]) {
            arr[k]<span style="color:#f92672">=</span>left[i];
            i<span style="color:#f92672">++</span>;
        }<span style="color:#66d9ef">else</span>{
            arr[k]<span style="color:#f92672">=</span>right[j];
            count <span style="color:#f92672">+=</span> n1<span style="color:#f92672">-</span>i;
            j<span style="color:#f92672">++</span>;
        }
    }
    <span style="color:#66d9ef">return</span> count;
}
</code></pre></div><p>5.快速排序(quick sort)：</p>
<p>想法一：如下图所示，(它同样可以按照下面提到的算法导论中将数组分成了4个不同的部分，但是这里其实有更好的解释方法) <strong>首先，它每次都是选择第一个元素都为主元，这个回合就是要确定主元的位置；然后，有两个指针，一个leftmark指向主元的后面一个位置，另一个rightmark指向要排序的数组最后一个元素；接着，两个指针分别向中间移动，leftmark遇到比主元大的元素停止，rightmark遇到比主元小的元素停止，如果此时leftmark&lt;rightmark，也就是说中间还有未处理(未确定与主元大小关系)的元素，那么就交换leftmark和rightmark位置上的元素，然后重复刚才的移动操作，直到rightmark&lt;leftmark；最后，停止移动时候rightmark就是主元要放置的位置，因为它停在一个比主元小的元素的位置上，之后交换主元和rightmark指向的元素即可。完了之后，递归地对主元左右两边的数组进行排序即可。</strong></p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/quicksort.png" alt="image"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quick_sort</span>(a_list):
    quick_sort_helper(a_list, <span style="color:#ae81ff">0</span>, len(a_list) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quick_sort_helper</span>(a_list, first, last):
    <span style="color:#66d9ef">if</span> first <span style="color:#f92672">&lt;</span> last:
        split_point <span style="color:#f92672">=</span> partition(a_list, first, last)
        quick_sort_helper(a_list, first, split_point <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        quick_sort_helper(a_list, split_point <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, last)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(a_list, first, last):
    pivot_value <span style="color:#f92672">=</span> a_list[first]
    left_mark <span style="color:#f92672">=</span> first <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    right_mark <span style="color:#f92672">=</span> last
    done <span style="color:#f92672">=</span> False
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> done:
        <span style="color:#66d9ef">while</span> left_mark <span style="color:#f92672">&lt;=</span> right_mark <span style="color:#f92672">and</span> a_list[left_mark] <span style="color:#f92672">&lt;=</span> pivot_value:
            left_mark <span style="color:#f92672">=</span> left_mark <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> a_list[right_mark] <span style="color:#f92672">&gt;=</span> pivot_value <span style="color:#f92672">and</span> right_mark <span style="color:#f92672">&gt;=</span> left_mark:
            right_mark <span style="color:#f92672">=</span> right_mark <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">if</span> right_mark <span style="color:#f92672">&lt;</span> left_mark:
            done <span style="color:#f92672">=</span> True
        <span style="color:#66d9ef">else</span>:
            temp <span style="color:#f92672">=</span> a_list[left_mark]
            a_list[left_mark] <span style="color:#f92672">=</span> a_list[right_mark]
            a_list[right_mark] <span style="color:#f92672">=</span> temp
    temp <span style="color:#f92672">=</span> a_list[first]
    a_list[first] <span style="color:#f92672">=</span> a_list[right_mark]
    a_list[right_mark] <span style="color:#f92672">=</span> temp
    <span style="color:#66d9ef">return</span> right_mark

a_list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">93</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">20</span>]
quick_sort(a_list)
<span style="color:#66d9ef">print</span>(a_list)
</code></pre></div><p>想法二：(摘自算法导论)如下图所示，它选择最后的那个元素作为主元，它的思路是将数组划分成4部分：</p>
<p>第一部分：$p \le k \le i, A[k] \le pivot$<br>
第二部分：$i+1 \le k \le j-1, A[k] \gt pivot$<br>
第三部分：$j \le k \le r-1, A[k]$可以取任何值(因为它们还没有进行处理)<br>
第四部分：$p \le k \le i, A[k] = pivot$</p>
<p><strong>首先，让i指向要排序的数组的第一个元素的前面，p和j都指向第一个元素；然后，一直移动j直到主元前一个位置，一旦发现一个小于主元的元素就让i指向它的下一个位置，然后交换i和j对应位置上的元素。这样一定是可行的，因为i一直都是指向已发现的小于主元的元素中的最后一个，从i+1开始就大于主元了(或者还未确定/未处理)，而j一直都是指向大于主元的元素中最后一个的后面一个位置，所以i+1和j位置上的元素交换就可以使得j发现的这个小于主元的元素移动到第一部分，而i+1位置上大于主元的元素移动到j的位置上，即第二部分的最后一个位置上。</strong></p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/quicksort_cn.png" alt="image"></p>
<p>根据算法导论中的伪代码的C++版本实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">// partition, locate the pivot value in properate position
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high){
    <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> a[high];<span style="color:#75715e">//pivot
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>low<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, temp;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>low; j<span style="color:#f92672">&lt;</span>high; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (a[j]<span style="color:#f92672">&lt;</span>key) {
            i<span style="color:#f92672">++</span>;
            temp <span style="color:#f92672">=</span> a[j];
            a[j]<span style="color:#f92672">=</span>a[i];
            a[i]<span style="color:#f92672">=</span>temp;
        }
    }
    temp <span style="color:#f92672">=</span> a[high];
    a[high] <span style="color:#f92672">=</span> a[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
    a[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;<span style="color:#75715e">//i+1 is the split point
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#75715e">// quick sort
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quicksort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> partition(a,low,high);
        quicksort(a, low, p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        quicksort(a, p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, high);
    }
}

<span style="color:#75715e">// print array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> a[],<span style="color:#66d9ef">int</span> len){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>len; i<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[])
{
    <span style="color:#66d9ef">int</span> a[]<span style="color:#f92672">=</span>{<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">33</span>,<span style="color:#ae81ff">28</span>,<span style="color:#ae81ff">19</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">8</span>};
    quicksort(a, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>);
    print(a,<span style="color:#ae81ff">11</span>);
}
</code></pre></div><p>由于快排每次都能够确定一个元素在数组中最终的位置，所以可以用快排来解决很多变种问题，例如在线性时间内求中位数或者其他顺序统计量的问题(例如第k大或者第k小的元素)，该部分内容可以参考<a href="http://www.cnblogs.com/Anker/archive/2013/01/25/2877311.html">来自博客园</a></p>
<p>关于快排的性能分析可以参考<a href="http://www.cnblogs.com/Anker/archive/2013/01/24/2875234.html">来自博客园</a>，一般来说划分之后两边越均衡的话快排的性能更好。为了避免最坏的情况出现(原始的数组是已经是有序的)可以使用随机化版本的快排。</p>
<p>另外，为了减少快排调用的栈深度可以使用模拟尾递归技术，通过对快排的修改可以保证最坏情况下栈深度为O(nlgn)，该内容可以参见算法导论习题7-4。</p>
<p>6.希尔排序：类似合并排序和插入排序的结合体，二路合并排序将原来的数组分成左右两部分，希尔排序则将数组按照一定的间隔分成几部分，每部分采用插入排序来排序，有意思的是这样做了之后，元素很多情况下就差不多在它应该呆的位置，所以效率不一定比插入排序差。时间复杂度为$[O(n),O(n^2)]$。</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/shellsort.png" alt="image"></p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/shellsort2.png" alt="image"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shell_sort</span>(a_list):
    <span style="color:#75715e">#how many sublists, also how many elements in a sublist</span>
    sublist_count <span style="color:#f92672">=</span> len(a_list) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
    <span style="color:#66d9ef">while</span> sublist_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">for</span> start_position <span style="color:#f92672">in</span> range(sublist_count):
            gap_insertion_sort(a_list, start_position, sublist_count)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;After increments of size&#34;</span>, sublist_count, <span style="color:#e6db74">&#34;The list is&#34;</span>, a_list)
        sublist_count <span style="color:#f92672">=</span> sublist_count <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gap_insertion_sort</span>(a_list, start, gap):
    <span style="color:#75715e">#start+gap is the second element in this sublist</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start <span style="color:#f92672">+</span> gap, len(a_list), gap):
        current_value <span style="color:#f92672">=</span> a_list[i]
        position <span style="color:#f92672">=</span> i
        <span style="color:#66d9ef">while</span> position <span style="color:#f92672">&gt;=</span> gap <span style="color:#f92672">and</span> a_list[position <span style="color:#f92672">-</span> gap] <span style="color:#f92672">&gt;</span> current_value:
            a_list[position] <span style="color:#f92672">=</span> a_list[position <span style="color:#f92672">-</span> gap] <span style="color:#75715e">#move backward</span>
            position <span style="color:#f92672">=</span> position <span style="color:#f92672">-</span> gap
            a_list[position] <span style="color:#f92672">=</span> current_value


a_list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">93</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">77</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">88</span>]
shell_sort(a_list)
<span style="color:#66d9ef">print</span>(a_list)
</code></pre></div><p>7.堆排序请参见该系列文章中的<a href="https://hujiaweibujidao.github.io/blog/2014/05/08/python-data-structures---c3-data-structures/">DataStrctures章节中的二叉堆部分的内容</a>。</p>
<p>8.其他线性排序可以参见算法导论第8章或者看下<a href="http://www.cnblogs.com/Anker/archive/2013/01/25/2876397.html">这篇不错的文章</a></p>
<p>其实看个图就明白了，图摘自上面的博客，版权归原作者，谢谢！</p>
<p>计数排序：在数的范围很小时还是不错的，当数的范围很大的时候就不适用了，计数排序一般用于基数排序中。需要注意的是，计数完了之后进行插入时，为了保证排序的稳定性，需要从后往前插入。</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/sortcount.png" alt="image"></p>
<p>下面是计数排序的python实现，摘自<a href="http://link.springer.com/book/10.1007%2F978-1-4302-3238-4">Python Algorithms: Mastering Basic Algorithms in the Python Language</a></p>
<pre><code>from collections import defaultdict

def counting_sort(A, key=lambda x: x):
    B, C = [], defaultdict(list)  # Output and &quot;counts&quot;
    for x in A:
        C[key(x)].append(x)  # &quot;Count&quot; key(x)
    for k in range(min(C), max(C) + 1):  # For every key in the range
        B.extend(C[k])  # Add values in sorted order
    return B

seq = [randrange(100) for i in range(10)]
seq = counting_sort(seq)
</code></pre><p>基数排序：因为每位上的数字范围一般都是有限的，所以常配合使用计数排序对每位进行排序。
<img src="https://hujiaweibujidao.github.io/images/algos/sortradix.png" alt="image"></p>
<p>桶排序：适用于元素是均匀分布的，在每个桶内采用插入排序。</p>
<p><img src="https://hujiaweibujidao.github.io/images/algos/sortbucket.png" alt="image"></p>
<p>本节只是对各种排序进行一个介绍然后用python实现而已，更加详细地解释各种排序的内部思想的内容可以参见后面的<a href="https://hujiaweibujidao.github.io/blog/2014/07/01/python-algorithms---c4-induction-and-recursion-and-reduction/">Python算法设计篇之Induction&amp;Recursion&amp;Reduction</a></p>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://hujiaweibujidao.github.io/" style="background-image: url(https://hujiaweibujidao.github.io/images/logo.gif)"><span class="hidden">hujiawei's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> Hujiawei is a mobile developer</span>
    <span class="author-location icon-location"> Guangdong, China</span>
    <span class="author-link icon-link"><a href="https://hujiaweibujidao.github.io/"> https://hujiaweibujidao.github.io/</a></span>
    

    
  </div>
  <br/>
</section>


      
        <aside class="read-next">
  
      <span class="readmore-prev readmore-meta">PREV: <a href="https://hujiaweibujidao.github.io/blog/2014/05/08/python-data-structures-c3-data-structures/"><h4>Python Data Structures - C3 Data Structures</h4></a></span>
      
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://hujiaweibujidao.github.io/blog/2014/05/06/python-data-structures-c1-search/"><h4>Python Data Structures - C1 Search</h4></a></span>
      
  
</aside>
<br/>

      
      
      
    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">Hujiawei Bujidao. </a> All rights reserved &copy; 2013 - 2020</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
            
            <script type="text/javascript">
                var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
                document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
            </script>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/index.js"></script>

    
    
    
    

    
</body>
</html>

