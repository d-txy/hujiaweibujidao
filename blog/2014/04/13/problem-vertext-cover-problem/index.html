<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       Problem: Vertext Cover Problem &middot;  Hujiawei Bujidao
    </title>

    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" Problem: Vertext Cover Problem &middot;  Hujiawei Bujidao" />
  	<meta property="og:site_name" content="Hujiawei Bujidao" />
  	<meta property="og:url" content="https://hujiaweibujidao.github.io/blog/2014/04/13/problem-vertext-cover-problem/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2014-04-13T00:00:00Z" />
    
    <meta property="og:article:tag" content="algorithm" />
    
    

    <meta name="description" content="Happy Coding &amp; Enjoy Living" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hujiaweibujidao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hujiaweibujidao.github.io/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/highlight.css">
    
    <link rel="stylesheet" type="text/css" href="https://hujiaweibujidao.github.io/css/github-gist.css">
    
    <script src="https://hujiaweibujidao.github.io/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

    
    

    

    <link rel="canonical" href="https://hujiaweibujidao.github.io/blog/2014/04/13/problem-vertext-cover-problem/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/">首页</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hujiaweibujidao.github.io/about">关于</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/android/">Android</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/python/">Python</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">算法</a></li>
        
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/dev/">开发</a></li>
        <li class="nav-opened" role="presentation"><a href="https://hujiaweibujidao.github.io/tags/life/">生活</a></li>
    </ul>

    
    

    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">菜单</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">Problem: Vertext Cover Problem</h1>
            <h2 class="page-description">Hujiawei Bujidao</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/hujiaweibujidao" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


    <a class="bloglogo" href="https://weibo.com/hujiaweiyinger" target="_blank">
        <span class="icon-twitter" style="color:white;font-size:2em"></span>
    </a>
&nbsp;




    <a class="bloglogo" href="https://www.linkedin.com/in/hujiaweibujidao" target="_blank">
        <span class="icon-linkedin" style="color:white;font-size:2em"></span>
    </a>
&nbsp;


        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Problem: Vertext Cover Problem</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://hujiaweibujidao.github.io/tags/algorithm/">#algorithm</a></span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2014-04-13T00:00:00Z">
            2014/4/13
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>顶点覆盖问题可以用几种不同的算法来实现，本文使用的是分支限界法来实现</p>
<h4 id="1问题描述">1.问题描述</h4>
<p>给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。</p>
<p>例如，如下图所示的无向图G（报告中算法分析过程中一直使用下面的图G）</p>
<p>(1)如果选择包含点1,2,6这3个点的集合S不能满足条件，因为边(3,7)两个端点都不在S中。</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-3.png" alt="image"></p>
<p>(2)如果选择包含点1,2,6,7这4个点的集合S虽然满足条件，但是它使用了4个点，其实可以使用更少的点，如下面(3)所示</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-2.png" alt="image"></p>
<p>(3)如果选择包含点1,3,5这3个点的集合S便满足条件，使得G中的每条边都至少有一个点在集合S中。</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-1.png" alt="image"></p>
<h4 id="2解题思路">2.解题思路</h4>
<p>我的解题思路基于分支定界和贪心两个策略，用一个优先队列维护当前可行的节点，每个节点维护着该节点情况下还可以选择的顶点数目k、需要覆盖的剩余边数e、顶点的状态state、顶点的边数edge等信息，这些节点的排序遵循下面的贪心策略，节点的扩展遵循下面的分支定界策略。总体思路是：</p>
<p>①将原图数据构造成一个解空间树的节点，利用定界策略判断是否有解，如果无解直接退出，如果有可能有解则插入到优先队列中；
②若优先队列不为空，那么便从优先队列中取出第一个可行的节点，进入步骤③，如果优先队列为空则退出；
③判断当前节点是否满足解的条件，如果满足便输出解退出，如果不满足便进入步骤④；
④检查当前节点是否可以扩展，不能扩展的话便进入②继续循环，如果能扩展的话则扩展，然后验证扩展到左右节点是否有解，将有解的扩展节点插入到优先队列中，然后进入②继续循环。</p>
<p>下面分别介绍下分支定界和贪心这两个策略：</p>
<h5 id="1分支定界策略">(1)分支定界策略</h5>
<p>首先，界的选择。在一个确定的无向图G中，每个顶点的边即确定了，那么对于该无向图中k个顶点能够覆盖的最多的边数e也就可以确定了！只要对顶点按照边的数目降序排列，然后选择前k个顶点，将它们的边数相加即能得到一个边数上界！因为这k个顶点相互之间可能有边存在也可能没有，所以这是个上界，而且有可能达到。以图G为例，各个顶点的边数统计，并采用降序排列的结果如下：</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-f3.png" alt="image"></p>
<p>假设取k=3个点，那么有Up(e)=(3+3+2)=8 &gt; 7 条边（7为图G的总边数），也就是说，如果从图G中取3个点，要覆盖8条边是有可能的。但是，如果取k=2个点，那么有Up(e)=(3+3)=6 &lt; 7 条边，说明从图G中取2个点，是不可能覆盖G中的全部7条边的！基于这个上界，可以在分支树中扩展出来的节点进行验证，已知它还可以选择的顶点数目以及还需要覆盖的边的条数，加上顶点的状态（下面会分析说明）即可判断当前节点是否存在解！如果不存在即可进行剪枝了。</p>
<p>其次，顶点的状态。该策略中顶点有三种状态，分别为已经选择了的状态S1，不选择的状态S2，可以选择的状态S3。其中，不选择的状态S2对应解空间树中的右节点，不选择该节点，然后设置该节点为不选择状态S2。这点很重要，因为有了这个状态，可以使得上界的判断更为精确，因为只能从剩余顶点集中选择那些状态S3的顶点，状态S1和S2都不行，那么上界便会更小，也就更加精确，从而利于剪枝！</p>
<h5 id="2贪心策略">(2)贪心策略</h5>
<p>贪心的策略是指可行的结点都是按照还需要覆盖的剩余边数的降序排列，即，每次选择的节点都是可行节点中还需要覆盖的边数最小的那个节点，因为它最接近结果了。</p>
<h5 id="3例子分析">(3)例子分析</h5>
<p>以图G为例，此时e=7（要覆盖的边数），取k=3，图G用邻接矩阵保存为全局数据，计算每个顶点的边数，然后降序排列。</p>
<p>步骤①判断是否可能有解，Up(e)=3+3+2=8&gt;7，可能有解，那么将图G构造成一个解空间树的节点，它包含了还能选择的点数k=3，还需要覆盖的边数e=7，每个顶点的边数以及按边数大小的降序排列（上表），每个顶点的状态（初始时都是可选择的状态S3）。然后，将该节点插入到优先队列中，该优先队列是用最小堆实现的，按照前面的贪心策略对队列中的节点进行降序排列。</p>
<p>步骤②取出了优先队列中的根节点，很显然，还需要覆盖的边数为7，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点2，接着进行扩展，扩展左节点时将还能选择的点数k-1=2，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=4，然后更新所有其他顶点的边数，并重新排序，最后将顶点2的状态设置为已经选择了；扩展右节点时，只要将顶点2的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都有解，那么将左右节点都插入到优先队列中，因为左节点还需要覆盖的边数e=4小于右节点的e=7，所以根据贪心策略，左节点在右节点的前面。上面两个步骤的图示如下，其中标明了顶点状态颜色。</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-f1.png" alt="image"></p>
<p>算法然后继续进入步骤②，此时取出的是节点是刚才插入的左节点，很显然，还需要覆盖的边数为4，不为0，所以还不满足条件。接下来要检查是否能够进行扩展，从顶点集合中选择状态为可以选择的顶点中边数最多的点，该点存在为顶点3，接着进行扩展，扩展左节点时将还能选择的点数k-1=1，然后计算选择了该点之后删除了几条未覆盖的边，得到还需要覆盖的边数e=2，然后更新所有其他顶点的边数，并重新排序，最后将顶点3的状态设置为已经选择了；扩展右节点时，只要将顶点3的状态设置为不能选择，还能选择的点数k(=3)，还需要覆盖的边数e(=7)保持不变。扩展完了之后，同样判断左右节点是否可能有解，如果有解，将该节点插入到优先队列中。这里左右节点都不可能有解，那么直接进入步骤②继续循环。上面这一步的图示如下：</p>
<p><img src="https://hujiaweibujidao.github.io/images/exp1-f2.png" alt="image"></p>
<p>算法按照上面的方式不断进行，最后满足条件的分支的过程是：
①不选择顶点2；②选择顶点3；③选择顶点1；④选择顶点5。</p>
<p>最后得到的满足条件的解是选择顶点1,3,5。</p>
<h4 id="4复杂度分析">(4)复杂度分析</h4>
<p>该算法优先队列使用的是最小堆实现的(O(nlgn))，对顶点按照边排序使用的是快速排序算法(O(nlgn))，解空间树的深度最多为顶点数目n，每层都要进行分支定界，所以每层的时间复杂度为O(nlgn)，所以算法总的时间复杂度为O(n^2 lgn)。但是，为了实现分支定界，每个节点保存的信息量较多，空间复杂度较大。(有木有分析错了，我不太会分析复杂度)</p>
<p>青橙OJ系统的结果为：时间 156ms  空间 1.0MB</p>
<p>本人对指针领悟能力有限，C++也是一知半解，OJ只能用C或者C++，所以下面的C++代码效率不高，仅供参考，:-)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define MAX_NODE 101
</span><span style="color:#75715e">#define INDEBUG 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int8_t</span> graph[MAX_NODE][MAX_NODE];<span style="color:#75715e">//int -&gt; int8_t
</span><span style="color:#75715e">//int edges[MAX_NODE];//0 is redudent
</span><span style="color:#75715e">//int nodes[MAX_NODE];//the order of node
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> t,m,n,k,a,b;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VCNode</span> {<span style="color:#75715e">//Vertex Cover Node
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> p;<span style="color:#75715e">//points can be used
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> e;<span style="color:#75715e">//edges to cover!!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> index[MAX_NODE];<span style="color:#75715e">//the index of each node in array [node], index[k]=i!!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> edge[MAX_NODE];<span style="color:#75715e">//MAX_NODE the edge number of each node, edge[i]=j!!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> node[MAX_NODE];<span style="color:#75715e">//the order of the node
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> state[MAX_NODE];<span style="color:#75715e">//the state of each node ** 0 can be used / 1 used / -1 can not be used
</span><span style="color:#75715e">//    int graph[MAX_NODE][MAX_NODE];//the graph on the node//no need,just use the global graph
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// node k is in index[k]=i position in array [node]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// node i has number of edge[i]=j edges
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Minheap</span> {<span style="color:#75715e">//Min Heap
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span>VCNode<span style="color:#f92672">&gt;</span> nodes;

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(VCNode node);
    VCNode <span style="color:#a6e22e">popmin</span>();
<span style="color:#75715e">//  void print();
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">void</span> Minheap<span style="color:#f92672">::</span>insert(VCNode node) {
    nodes.push_back(node);
    <span style="color:#75715e">//  cout &lt;&lt; &#34;size is &#34; &lt;&lt; nodes.size() &lt;&lt; endl;//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> curpos <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)nodes.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// current position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> parent <span style="color:#f92672">=</span> (curpos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//parent position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (curpos <span style="color:#f92672">!=</span> parent <span style="color:#f92672">&amp;&amp;</span> parent <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">//parent is still in heap
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (nodes[parent].e <span style="color:#f92672">&gt;</span> nodes[curpos].e) { <span style="color:#75715e">//swap parent and child
</span><span style="color:#75715e"></span>            VCNode temp <span style="color:#f92672">=</span> nodes[parent];
            nodes[parent] <span style="color:#f92672">=</span> nodes[curpos];
            nodes[curpos] <span style="color:#f92672">=</span> temp;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">break</span>; <span style="color:#75715e">//no longer level up!!!
</span><span style="color:#75715e"></span>        }
        curpos <span style="color:#f92672">=</span> parent; <span style="color:#75715e">//when curpos=parent=0, exit!!!
</span><span style="color:#75715e"></span>        parent <span style="color:#f92672">=</span> (curpos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//relocate the parent position
</span><span style="color:#75715e"></span>    }
}
VCNode Minheap<span style="color:#f92672">::</span>popmin() {
    VCNode node;
    <span style="color:#66d9ef">if</span> (nodes.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">//have nodes left
</span><span style="color:#75715e"></span>        node <span style="color:#f92672">=</span> nodes[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">//get the first element
</span><span style="color:#75715e"></span>        nodes.erase(nodes.begin()); <span style="color:#75715e">//remove the first element
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (nodes.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">//at least have one element more
</span><span style="color:#75715e"></span>            VCNode last <span style="color:#f92672">=</span> nodes[nodes.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]; <span style="color:#75715e">//get the last element
</span><span style="color:#75715e"></span>            nodes.pop_back(); <span style="color:#75715e">//pop the last element
</span><span style="color:#75715e"></span>            nodes.insert(nodes.begin(), last); <span style="color:#75715e">//put it in the first place
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> csize <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)nodes.size(); <span style="color:#75715e">//current size
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> curpos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//current position
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">// rebuild the minheap
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (curpos <span style="color:#f92672">&lt;</span> (csize <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)) { <span style="color:#75715e">//reach to the last parent node!!
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> curpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//left child
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> curpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//right child
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> left; <span style="color:#75715e">//min store the min child
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">&lt;</span> csize) { <span style="color:#75715e">//have left and right childs
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (nodes[right].e <span style="color:#f92672">&lt;</span> nodes[left].e) {
                        min <span style="color:#f92672">=</span> right;
                    }
                }
                <span style="color:#66d9ef">if</span> (min <span style="color:#f92672">&lt;</span> csize) { <span style="color:#75715e">//min child exist!!
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (nodes[min].e <span style="color:#f92672">&lt;</span> nodes[curpos].e) { <span style="color:#75715e">//need to swap current position with child
</span><span style="color:#75715e"></span>                        VCNode temp <span style="color:#f92672">=</span> nodes[min];
                        nodes[min] <span style="color:#f92672">=</span> nodes[curpos];
                        nodes[curpos] <span style="color:#f92672">=</span> temp;
                    }<span style="color:#66d9ef">else</span> { <span style="color:#75715e">//min child no exits!! exit!!
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">break</span>; <span style="color:#75715e">//can break now!!
</span><span style="color:#75715e"></span>                    }
                }
                curpos <span style="color:#f92672">=</span> min;
            }
        }
    }
    <span style="color:#66d9ef">return</span> node;
}
<span style="color:#75715e">//void Minheap::print() {
</span><span style="color:#75715e">//  cout &lt;&lt; &#34;print heap&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//  for (int i = 0; i &lt; (int)nodes.size(); i++) {
</span><span style="color:#75715e">//      cout &lt;&lt; &#34;edge: &#34; &lt;&lt; nodes[i].e &lt;&lt; &#34; node: &#34; &lt;&lt; nodes[i].p &lt;&lt; endl;
</span><span style="color:#75715e">//  }
</span><span style="color:#75715e">//  cout &lt;&lt; &#34;heap end&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//}
</span><span style="color:#75715e">// print array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printArray</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
    <span style="color:#66d9ef">if</span> (INDEBUG) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;print array form &#34;</span> <span style="color:#f92672">&lt;&lt;</span> start <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">&lt;&lt;</span> end <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>start; i<span style="color:#f92672">&lt;=</span>end; i<span style="color:#f92672">++</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;print array end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}
<span style="color:#75715e">// print the graph
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printGraph</span>(<span style="color:#66d9ef">int</span> graph[][MAX_NODE]){
    <span style="color:#66d9ef">if</span> (INDEBUG) {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){<span style="color:#75715e">//0 no need
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>){
                cout <span style="color:#f92672">&lt;&lt;</span> graph[i][j] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
            }
            cout <span style="color:#f92672">&lt;&lt;</span> endl;
        }
    }
}
<span style="color:#75715e">// partition function for quick sort
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition2</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high, <span style="color:#66d9ef">int</span> b[]){
    <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> a[high];
    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>low<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>low; j<span style="color:#f92672">&lt;</span>high; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (a[j]<span style="color:#f92672">&gt;=</span>key) {
            i<span style="color:#f92672">++</span>;
            swap(a[i], a[j]);
            swap(b[i], b[j]);
        }
    }
    swap(a[high], a[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
    swap(b[high], b[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
    <span style="color:#66d9ef">return</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
}
<span style="color:#75715e">// quick sort
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quicksort2</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high, <span style="color:#66d9ef">int</span> b[]) {
    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> partition2(a,low,high, b);
        quicksort2(a, low, p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, b);
        quicksort2(a, p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, high, b);
    }
}
<span style="color:#75715e">// sum of the first k elements with state==0!!!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sumofkmax</span>(<span style="color:#66d9ef">int</span> edges[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> nodes[], <span style="color:#66d9ef">int</span> state[]){
    quicksort2(edges, <span style="color:#ae81ff">1</span>, n, nodes);
    <span style="color:#66d9ef">int</span> sum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#75715e">// edges[i] corresponse to nodes[i], its state is state[nodes[i]]
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){<span style="color:#75715e">//attention to i range!!
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (state[nodes[i]]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {
            sum<span style="color:#f92672">+=</span>edges[i];
            count<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> p) {<span style="color:#75715e">//enough!
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
            }
        }
    }
    <span style="color:#66d9ef">return</span> sum;
}
<span style="color:#75715e">// verify the current node can be achievable
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">verify</span>(<span style="color:#66d9ef">int</span> edges[], <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> e, <span style="color:#66d9ef">int</span> nodes[], <span style="color:#66d9ef">int</span> state[]){
    <span style="color:#75715e">//caculate the sum of the first p max elements in array edges!!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> sumofkmax(edges, p, nodes, state);
    <span style="color:#75715e">// edge of nodes[i] is edges[i]!!!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&gt;=</span> e){<span style="color:#75715e">// may be this can be achieved
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">return</span> false;
}
<span style="color:#75715e">// build the index of node in array [index]
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildIndex</span>(<span style="color:#66d9ef">int</span> node[],<span style="color:#66d9ef">int</span> index[]){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {
        index[node[i]] <span style="color:#f92672">=</span> i;
    }
}
<span style="color:#75715e">// get the next node: state==0 &amp;&amp; order first!!!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nextNode</span>(<span style="color:#66d9ef">int</span> state[], <span style="color:#66d9ef">int</span> nodes[]){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (state[nodes[i]]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">return</span> nodes[i];
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
<span style="color:#75715e">// generate the left child
</span><span style="color:#75715e"></span>VCNode <span style="color:#a6e22e">genLeft</span>(VCNode curnode, <span style="color:#66d9ef">int</span> label){
    VCNode left;<span style="color:#75715e">//choose node label!
</span><span style="color:#75715e"></span>    left.p <span style="color:#f92672">=</span> curnode.p <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//remove one node
</span><span style="color:#75715e"></span>    left.e <span style="color:#f92672">=</span> curnode.e;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {<span style="color:#75715e">//first copy all infos
</span><span style="color:#75715e"></span>        left.index[i]<span style="color:#f92672">=</span>curnode.index[i];
        left.state[i]<span style="color:#f92672">=</span>curnode.state[i];<span style="color:#75715e">//init node state
</span><span style="color:#75715e"></span>        left.edge[i]<span style="color:#f92672">=</span>curnode.edge[i];<span style="color:#75715e">//copy edge info
</span><span style="color:#75715e"></span>        left.node[i]<span style="color:#f92672">=</span>curnode.node[i];<span style="color:#75715e">//copy node info
</span><span style="color:#75715e">//        for (int j=0; j&lt;=n; j++) {
</span><span style="color:#75715e">//            left.graph[i][j] = curnode.graph[i][j];
</span><span style="color:#75715e">//        }
</span><span style="color:#75715e"></span>    }
    <span style="color:#75715e">// following code will not use curnode anymore!!
</span><span style="color:#75715e"></span>

    <span style="color:#75715e">///
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//removed edge
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&lt;=</span>n; j<span style="color:#f92672">++</span>) {
        <span style="color:#75715e">//new
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (label <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> left.state[j]<span style="color:#f92672">!=</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> graph[label][j]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> ) {<span style="color:#75715e">//row!
</span><span style="color:#75715e"></span>            sum<span style="color:#f92672">++</span>;
<span style="color:#75715e">//            left.graph[label][j]=0;
</span><span style="color:#75715e"></span>            left.edge[left.index[j]]<span style="color:#f92672">--</span>;<span style="color:#75715e">//how to cut it down
</span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(label <span style="color:#f92672">&gt;</span> j <span style="color:#f92672">&amp;&amp;</span> left.state[j]<span style="color:#f92672">!=</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> graph[j][label]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> ){ <span style="color:#75715e">// col
</span><span style="color:#75715e"></span>            sum<span style="color:#f92672">++</span>;
<span style="color:#75715e">//            left.graph[j][label]=0;
</span><span style="color:#75715e"></span>            left.edge[left.index[j]]<span style="color:#f92672">--</span>;<span style="color:#75715e">//how to cut it down
</span><span style="color:#75715e"></span>        }
    }
    <span style="color:#75715e">///
</span><span style="color:#75715e"></span>
    left.state[label] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//use label directly!
</span><span style="color:#75715e"></span>    left.edge[left.index[label]] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//only use index!!
</span><span style="color:#75715e">//    cout &lt;&lt; &#34;remove edge sum is &#34; &lt;&lt; sum &lt;&lt; endl;
</span><span style="color:#75715e"></span>    quicksort2(left.edge, <span style="color:#ae81ff">1</span>, n, left.node);
    left.e <span style="color:#f92672">=</span> left.e <span style="color:#f92672">-</span> sum;<span style="color:#75715e">//remove some edges
</span><span style="color:#75715e"></span>    buildIndex(left.node, left.index);

    <span style="color:#66d9ef">if</span> (INDEBUG) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======== &#34;</span> <span style="color:#f92672">&lt;&lt;</span> label <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; gen left begin===========&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;edge is &#34;</span> <span style="color:#f92672">&lt;&lt;</span> left.e <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; node is &#34;</span> <span style="color:#f92672">&lt;&lt;</span> left.p <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array edge:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        printArray(left.edge,<span style="color:#ae81ff">1</span>,n);
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array node:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        printArray(left.node, <span style="color:#ae81ff">1</span>, n);
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array index:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        printArray(left.index, <span style="color:#ae81ff">1</span>, n);
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array state:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        printArray(left.state, <span style="color:#ae81ff">1</span>, n);
<span style="color:#75715e">//        printGraph(left.graph);
</span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======== &#34;</span> <span style="color:#f92672">&lt;&lt;</span> label <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; gen left end===========&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">return</span> left;
}
<span style="color:#75715e">// generate the right child
</span><span style="color:#75715e"></span>VCNode <span style="color:#a6e22e">genRight</span>(VCNode curnode, <span style="color:#66d9ef">int</span> label){
    VCNode right;<span style="color:#75715e">//choose node label!
</span><span style="color:#75715e"></span>    right.p <span style="color:#f92672">=</span> curnode.p;<span style="color:#75715e">//remain
</span><span style="color:#75715e"></span>    right.e <span style="color:#f92672">=</span> curnode.e;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {<span style="color:#75715e">//first copy all infos
</span><span style="color:#75715e"></span>        right.index[i]<span style="color:#f92672">=</span>curnode.index[i];
        right.state[i]<span style="color:#f92672">=</span>curnode.state[i];<span style="color:#75715e">//init node state
</span><span style="color:#75715e"></span>        right.edge[i]<span style="color:#f92672">=</span>curnode.edge[i];<span style="color:#75715e">//copy edge info
</span><span style="color:#75715e"></span>        right.node[i]<span style="color:#f92672">=</span>curnode.node[i];<span style="color:#75715e">//copy node info
</span><span style="color:#75715e">//        for (int j=0; j&lt;=n; j++) {
</span><span style="color:#75715e">//            right.graph[i][j] = curnode.graph[i][j];
</span><span style="color:#75715e">//        }
</span><span style="color:#75715e"></span>    }
    <span style="color:#75715e">// following code will not use curnode anymore!!
</span><span style="color:#75715e"></span>    right.state[label] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//use label directly!
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (INDEBUG) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======== &#34;</span> <span style="color:#f92672">&lt;&lt;</span> label <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; gen right begin===========&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;edge is &#34;</span> <span style="color:#f92672">&lt;&lt;</span> right.e <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; node is &#34;</span> <span style="color:#f92672">&lt;&lt;</span> right.p <span style="color:#f92672">&lt;&lt;</span> endl;
<span style="color:#75715e">//        cout &lt;&lt; &#34;array edge:&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//        printArray(right.edge,1,n);
</span><span style="color:#75715e">//        cout &lt;&lt; &#34;array node:&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//        printArray(right.node, 1, n);
</span><span style="color:#75715e">//        cout &lt;&lt; &#34;array index:&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//        printArray(right.index, 1, n);
</span><span style="color:#75715e">//        cout &lt;&lt; &#34;array state:&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//        printArray(right.state, 1, n);
</span><span style="color:#75715e">//        printGraph(right.graph);
</span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======== &#34;</span> <span style="color:#f92672">&lt;&lt;</span> label <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; gen right end===========&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">return</span> right;
}
<span style="color:#75715e">// greedy find a way to solve VCP
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">greedyFind</span>(<span style="color:#66d9ef">int</span> edges[], <span style="color:#66d9ef">int</span> nodes[]<span style="color:#75715e">/*, int graph[][MAX_NODE]*/</span>){
    VCNode node;
    node.e <span style="color:#f92672">=</span> m;
    node.p <span style="color:#f92672">=</span> k;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {
        node.index[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        node.state[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//init node state
</span><span style="color:#75715e"></span>        node.edge[i]<span style="color:#f92672">=</span>edges[i];<span style="color:#75715e">//copy edge info
</span><span style="color:#75715e"></span>        node.node[i]<span style="color:#f92672">=</span>nodes[i];<span style="color:#75715e">//copy node info
</span><span style="color:#75715e">//        for (int j=0; j&lt;=n; j++) {
</span><span style="color:#75715e">//            node.graph[i][j] = graph[i][j];
</span><span style="color:#75715e">//        }
</span><span style="color:#75715e"></span>    }
    buildIndex(node.node, node.index);

    Minheap minheap;
    minheap.insert(node);

    <span style="color:#66d9ef">while</span> (minheap.nodes.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">// get the heap top node to extend
</span><span style="color:#75715e"></span>        VCNode curnode <span style="color:#f92672">=</span> minheap.popmin();

<span style="color:#75715e">//        if (INDEBUG) {
</span><span style="color:#75715e">//            cout &lt;&lt; &#34;...current graph...&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//            printGraph(curnode.graph);
</span><span style="color:#75715e">//        }
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// validate the current node
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (curnode.e <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">int</span> points <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> curnode.e;
            cout <span style="color:#f92672">&lt;&lt;</span> points <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">if</span> (curnode.state[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) {
                    <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> points){
                        cout <span style="color:#f92672">&lt;&lt;</span> i;
                    }<span style="color:#66d9ef">else</span>{
                        cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
                    }
                    count<span style="color:#f92672">++</span>;
                }
            }
            cout <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">return</span>;
        }

        <span style="color:#75715e">// generate child nodes
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> label <span style="color:#f92672">=</span> nextNode(curnode.state, curnode.node);<span style="color:#75715e">//the label of the node
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (label <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            <span style="color:#75715e">// node i is in index[k] position in array [node]
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// node i has number of edge[i] edges
</span><span style="color:#75715e"></span>            VCNode left <span style="color:#f92672">=</span> genLeft(curnode, label);
            VCNode right <span style="color:#f92672">=</span> genRight(curnode, label);
            <span style="color:#66d9ef">if</span> (verify(left.edge, left.p, left.e, left.node, left.state)) {
<span style="color:#75715e">//                cout &lt;&lt; &#34;insert &#34; &lt;&lt; label &lt;&lt; &#34; left&#34; &lt;&lt; endl;
</span><span style="color:#75715e"></span>                minheap.insert(left);
            }
            <span style="color:#66d9ef">if</span> (verify(right.edge, right.p, right.e, right.node, right.state)) {
<span style="color:#75715e">//                cout &lt;&lt; &#34;insert &#34; &lt;&lt; label &lt;&lt; &#34; right&#34; &lt;&lt; endl;
</span><span style="color:#75715e"></span>                minheap.insert(right);
            }
        }

    }

    <span style="color:#75715e">// if not find, then return -1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;

}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#75715e">//    freopen(&#34;/Volumes/hujiawei/Users/hujiawei/workspace/appleworkspace/algorithmworks/Exp1-2/Exp1-2/in3.txt&#34;, &#34;rt&#34;, stdin);//
</span><span style="color:#75715e"></span>    cin <span style="color:#f92672">&gt;&gt;</span> t;
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">--&gt;</span><span style="color:#ae81ff">0</span>){
        cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> k;
<span style="color:#75715e">//        int graph[n+1][MAX_NODE];
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
                graph[i][j]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
            }
        }
        <span style="color:#66d9ef">int</span> edges[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], nodes[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], state[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            edges[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
            state[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
            nodes[i]<span style="color:#f92672">=</span>i;
        }
        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> m;
        <span style="color:#66d9ef">while</span>(temp<span style="color:#f92672">--&gt;</span><span style="color:#ae81ff">0</span>){
            cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
            graph[min(a, b)][max(a,b)]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
<span style="color:#75715e">//          graph[a][b]=1;
</span><span style="color:#75715e">//          graph[b][a]=1;//just save half a&lt;=b
</span><span style="color:#75715e"></span>            edges[a]<span style="color:#f92672">++</span>;
            edges[b]<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> verify(edges, k, m, nodes, state);

        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>flag) {<span style="color:#75715e">//must not be achieved!!!
</span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        }<span style="color:#66d9ef">else</span>{
            greedyFind(edges,nodes<span style="color:#75715e">/*,graph*/</span>);
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://hujiaweibujidao.github.io/" style="background-image: url(https://hujiaweibujidao.github.io/images/logo.gif)"><span class="hidden">hujiawei's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> Hujiawei is a mobile developer</span>
    <span class="author-location icon-location"> Guangdong, China</span>
    <span class="author-link icon-link"><a href="https://hujiaweibujidao.github.io/"> https://hujiaweibujidao.github.io/</a></span>
    

    
  </div>
  <br/>
</section>


      
        <aside class="read-next">
  
      <span class="readmore-prev readmore-meta">PREV: <a href="https://hujiaweibujidao.github.io/blog/2014/04/15/mou-and-stackedit-and-mathjax/"><h4>Mou and StackEdit and Mathjax</h4></a></span>
      
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://hujiaweibujidao.github.io/blog/2014/04/08/setting-up-environments-on-new-mac/"><h4>Setting Up Environments on New Mac</h4></a></span>
      
  
</aside>
<br/>

      
      
      
    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">Hujiawei Bujidao. </a> All rights reserved &copy; 2013 - 2020</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
            
            <script type="text/javascript">
                var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
                document.write(unescape("%3Cspan id='cnzz_stat_icon_1000165127'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000165127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
            </script>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hujiaweibujidao.github.io/js/index.js"></script>

    
    
    
    

    
</body>
</html>

